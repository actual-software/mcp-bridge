id: "001_add_namespace_prefix"
description: "Add mcp: namespace prefix to all keys"
version: "1.0.0"
type: "schema"
script: |
  -- Add mcp: namespace prefix to existing keys
  -- This ensures all MCP keys are properly namespaced
  
  local count = 0
  local cursor = "0"
  
  -- Patterns to migrate
  local patterns = {
    "session:*",
    "ratelimit:*",
    "cache:*",
    "lock:*"
  }
  
  for _, pattern in ipairs(patterns) do
    cursor = "0"
    repeat
      local result = redis.call("SCAN", cursor, "MATCH", pattern, "COUNT", 100)
      cursor = result[1]
      local keys = result[2]
      
      for _, key in ipairs(keys) do
        -- Skip if already has mcp: prefix
        if string.sub(key, 1, 4) ~= "mcp:" then
          local new_key = "mcp:" .. key
          
          -- Get TTL
          local ttl = redis.call("TTL", key)
          
          -- Get value and type
          local key_type = redis.call("TYPE", key).ok
          
          if key_type == "string" then
            local value = redis.call("GET", key)
            redis.call("SET", new_key, value)
            if ttl > 0 then
              redis.call("EXPIRE", new_key, ttl)
            end
          elseif key_type == "hash" then
            local hash_data = redis.call("HGETALL", key)
            if #hash_data > 0 then
              redis.call("HSET", new_key, unpack(hash_data))
              if ttl > 0 then
                redis.call("EXPIRE", new_key, ttl)
              end
            end
          elseif key_type == "list" then
            local list_data = redis.call("LRANGE", key, 0, -1)
            if #list_data > 0 then
              redis.call("RPUSH", new_key, unpack(list_data))
              if ttl > 0 then
                redis.call("EXPIRE", new_key, ttl)
              end
            end
          elseif key_type == "set" then
            local set_data = redis.call("SMEMBERS", key)
            if #set_data > 0 then
              redis.call("SADD", new_key, unpack(set_data))
              if ttl > 0 then
                redis.call("EXPIRE", new_key, ttl)
              end
            end
          elseif key_type == "zset" then
            local zset_data = redis.call("ZRANGE", key, 0, -1, "WITHSCORES")
            if #zset_data > 0 then
              redis.call("ZADD", new_key, unpack(zset_data))
              if ttl > 0 then
                redis.call("EXPIRE", new_key, ttl)
              end
            end
          end
          
          -- Delete old key
          redis.call("DEL", key)
          count = count + 1
        end
      end
    until cursor == "0"
  end
  
  -- Set migration marker
  redis.call("SET", "mcp:migration:namespace_prefix", os.time())
  
  return count

rollback: |
  -- Remove mcp: namespace prefix
  local count = 0
  local cursor = "0"
  
  repeat
    local result = redis.call("SCAN", cursor, "MATCH", "mcp:*", "COUNT", 100)
    cursor = result[1]
    local keys = result[2]
    
    for _, key in ipairs(keys) do
      -- Skip migration markers
      if not string.match(key, "^mcp:migration:") then
        local new_key = string.sub(key, 5) -- Remove "mcp:" prefix
        
        -- Get TTL
        local ttl = redis.call("TTL", key)
        
        -- Rename key
        redis.call("RENAME", key, new_key)
        
        -- Restore TTL if needed
        if ttl > 0 then
          redis.call("EXPIRE", new_key, ttl)
        end
        
        count = count + 1
      end
    end
  until cursor == "0"
  
  -- Remove migration marker
  redis.call("DEL", "mcp:migration:namespace_prefix")
  
  return count

checksum: "a1b2c3d4e5f6"
metadata:
  author: "system"
  created_at: "2024-01-20T10:00:00Z"
  affects:
    - "session management"
    - "rate limiting"
    - "caching"
    - "distributed locks"