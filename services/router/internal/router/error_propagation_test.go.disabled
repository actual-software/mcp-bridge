// Package router provides error propagation tests for the MCP router functionality.
package router

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"net/http/httptest"
	"strings"
	"sync"
	"sync/atomic"
	"testing"
	"time"

	"github.com/gorilla/websocket"
	common "github.com/poiley/mcp-bridge/pkg/common/config"
	"github.com/poiley/mcp-bridge/services/router/internal/config"
	"github.com/poiley/mcp-bridge/services/router/internal/gateway"
	"github.com/poiley/mcp-bridge/services/router/pkg/mcp"
	"github.com/poiley/mcp-bridge/services/router/test/testutil"
)

// TestErrorPropagation_GatewayToStdout tests error propagation from gateway to stdout
func TestErrorPropagation_GatewayToStdout(t *testing.T) {
	tests := []struct {
		name            string
		gatewayResponse func(*websocket.Conn) error
		expectedError   string
		expectedCode    int
	}{
		{
			name: "gateway returns MCP error",
			gatewayResponse: func(conn *websocket.Conn) error {
				// Read request
				var msg gateway.WireMessage
				if err := conn.ReadJSON(&msg); err != nil {
					return err
				}

				// Send error response
				resp := gateway.WireMessage{
					ID:        msg.ID,
					Timestamp: time.Now().UTC().Format(time.RFC3339),
					Source:    "gateway",
					MCPPayload: mcp.Response{
						JSONRPC: "2.0",
						ID:      msg.ID,
						Error: &mcp.Error{
							Code:    -32601,
							Message: "Method not found",
							Data:    map[string]string{"method": "unknown"},
						},
					},
				}
				return conn.WriteJSON(resp)
			},
			expectedError: "Method not found",
			expectedCode:  -32601,
		},
		{
			name: "gateway returns invalid response",
			gatewayResponse: func(conn *websocket.Conn) error {
				// Read request
				var msg gateway.WireMessage
				if err := conn.ReadJSON(&msg); err != nil {
					return err
				}

				// Send malformed response
				return conn.WriteMessage(websocket.TextMessage, []byte("{invalid json"))
			},
			expectedError: "request timeout",
			expectedCode:  -32603,
		},
		{
			name: "gateway closes connection",
			gatewayResponse: func(conn *websocket.Conn) error {
				// Read request
				var msg gateway.WireMessage
				conn.ReadJSON(&msg)
				// Close connection abruptly
				return conn.Close()
			},
			expectedError: "request timeout",
			expectedCode:  -32603,
		},
		{
			name: "gateway timeout",
			gatewayResponse: func(conn *websocket.Conn) error {
				// Read request but never respond
				var msg gateway.WireMessage
				conn.ReadJSON(&msg)
				// Sleep longer than router timeout (3 seconds)
				time.Sleep(4 * time.Second)
				return nil
			},
			expectedError: "request timeout",
			expectedCode:  -32603,
		},
		{
			name: "context cancellation",
			gatewayResponse: func(conn *websocket.Conn) error {
				// Don't read anything, just sleep to trigger cancellation
				time.Sleep(5 * time.Second)
				return nil
			},
			expectedError: "context canceled",
			expectedCode:  -32603,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			gatewayReceived := make(chan bool, 1)

			// Create mock gateway
			server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				upgrader := websocket.Upgrader{}
				conn, err := upgrader.Upgrade(w, r, nil)
				if err != nil {
					return
				}
				defer conn.Close()

				// Call the test's gateway response function
				if err := tt.gatewayResponse(conn); err != nil {
					gatewayReceived <- false
				} else {
					gatewayReceived <- true
				}
			}))
			defer server.Close()

			// Create router
			wsURL := "ws" + strings.TrimPrefix(server.URL, "http")
			cfg := &config.Config{
				Gateway: config.GatewayConfig{
					URL: wsURL,
					Connection: common.ConnectionConfig{
						TimeoutMs: 5000,
					},
				},
				Local: config.LocalConfig{
					RequestTimeoutMs: 5000,
				},
			}

			router, err := New(cfg, testutil.NewTestLogger(t))
			if err != nil {
				t.Fatalf("Failed to create router: %v", err)
			}

			// Connect properly with context and wait for connection
			ctx, cancel := context.WithCancel(context.Background())
			defer cancel()
			router.ctx = ctx
			router.cancel = cancel

			// Start the router components which handle connection and message routing
			go router.Run(ctx)

			// Wait for connection to be established
			timeout := time.After(5 * time.Second)
			ticker := time.NewTicker(10 * time.Millisecond)
			defer ticker.Stop()

			for {
				select {
				case <-timeout:
					t.Fatal("Timeout waiting for connection")
				case <-ticker.C:
					if router.GetState() == StateConnected {
						goto connected
					}
				}
			}
		connected:

			// Ensure cleanup
			defer func() {
				cancel()
			}()

			// For context cancellation test, cancel the context after a brief delay
			if tt.name == "context cancellation" {
				go func() {
					time.Sleep(100 * time.Millisecond)
					cancel()
				}()
			}

			// Create a test request
			testReq := mcp.Request{
				JSONRPC: "2.0",
				Method:  "test.method",
				ID:      "test-1",
			}
			reqData, _ := json.Marshal(testReq)

			// Send request via stdin channel (simulating real usage)
			router.GetStdinChan() <- reqData

			// Check for expected error response on stdout channel
			if tt.expectedError != "" {
				select {
				case respData := <-router.GetStdoutChan():
					var resp mcp.Response
					json.Unmarshal(respData, &resp)
					if resp.Error == nil || !strings.Contains(resp.Error.Message, tt.expectedError) {
						t.Errorf("Expected error containing '%s' in response", tt.expectedError)
					}
				case <-time.After(1 * time.Second):
					t.Error("Expected error but got none")
				}
			}

			// Check if gateway received message (for successful cases)
			if tt.expectedError == "" {
				select {
				case <-gatewayReceived:
					// Expected for successful requests
				case <-time.After(100 * time.Millisecond):
					t.Error("Gateway did not receive message")
				}
			}
		})
	}
}

// TestErrorPropagation_ConcurrentErrors tests error handling with concurrent requests
func TestErrorPropagation_ConcurrentErrors(t *testing.T) {
	// Simplified concurrent test that avoids channel coordination issues
	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		upgrader := websocket.Upgrader{}
		conn, err := upgrader.Upgrade(w, r, nil)
		if err != nil {
			return
		}
		defer conn.Close()

		for {
			var msg gateway.WireMessage
			if err := conn.ReadJSON(&msg); err != nil {
				break
			}

			reqIDStr, ok := msg.ID.(string)
			if !ok {
				continue
			}

			// Determine response type based on request ID
			var resp gateway.WireMessage
			if strings.HasSuffix(reqIDStr, "-error") {
				resp = gateway.WireMessage{
					ID:        msg.ID,
					Timestamp: time.Now().UTC().Format(time.RFC3339),
					Source:    "gateway",
					MCPPayload: mcp.Response{
						JSONRPC: "2.0",
						ID:      msg.ID,
						Error: &mcp.Error{
							Code:    -32602,
							Message: "Invalid params",
						},
					},
				}
			} else {
				resp = gateway.WireMessage{
					ID:        msg.ID,
					Timestamp: time.Now().UTC().Format(time.RFC3339),
					Source:    "gateway",
					MCPPayload: mcp.Response{
						JSONRPC: "2.0",
						ID:      msg.ID,
						Result:  map[string]string{"status": "ok"},
					},
				}
			}

			if err := conn.WriteJSON(resp); err != nil {
				break
			}
		}
	}))
	defer server.Close()

	// Create router
	wsURL := "ws" + strings.TrimPrefix(server.URL, "http")
	cfg := &config.Config{
		Gateway: config.GatewayConfig{
			URL: wsURL,
			Connection: common.ConnectionConfig{
				TimeoutMs: 5000,
			},
		},
		Local: config.LocalConfig{
			RequestTimeoutMs:      2000, // Shorter timeout for faster test
			MaxConcurrentRequests: 10,
		},
	}

	router, err := New(cfg, testutil.NewTestLogger(t))
	if err != nil {
		t.Fatalf("Failed to create router: %v", err)
	}

	// Start the router components
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	go router.Run(ctx)

	// Wait for connection to be established
	timeout := time.After(2 * time.Second)
	ticker := time.NewTicker(10 * time.Millisecond)
	defer ticker.Stop()

	for {
		select {
		case <-timeout:
			t.Fatal("Timeout waiting for connection")
		case <-ticker.C:
			if router.GetState() == StateConnected {
				goto connected
			}
		}
	}
connected:

	// Test with just a few concurrent requests to avoid coordination issues
	const numRequests = 4
	var wg sync.WaitGroup
	results := make([]bool, numRequests) // true for success, false for error

	wg.Add(numRequests)
	for i := 0; i < numRequests; i++ {
		go func(idx int) {
			defer wg.Done()

			var reqID string
			expectError := (idx%2 == 0)
			if expectError {
				reqID = fmt.Sprintf("req-%d-error", idx)
			} else {
				reqID = fmt.Sprintf("req-%d-success", idx)
			}

			req := mcp.Request{
				JSONRPC: "2.0",
				Method:  "test.concurrent",
				ID:      reqID,
				Params:  map[string]int{"index": idx},
			}
			reqData, _ := json.Marshal(req)

			// Send request via stdin channel and wait for response
			router.GetStdinChan() <- reqData

			// Check for response or error
			select {
			case responseData := <-router.GetStdoutChan():
				var response mcp.Response
				if json.Unmarshal(responseData, &response) == nil {
					if expectError {
						results[idx] = response.Error != nil // We expect an error response
					} else {
						results[idx] = response.Error == nil // We expect success
					}
				} else {
					results[idx] = false // Invalid response
				}
			case <-time.After(500 * time.Millisecond):
				results[idx] = expectError // Timeout is expected for error cases
			}
		}(i)
	}

	// Wait for all requests with timeout
	done := make(chan struct{})
	go func() {
		wg.Wait()
		close(done)
	}()

	select {
	case <-done:
		// All requests completed
	case <-time.After(10 * time.Second):
		t.Fatal("Timeout waiting for concurrent requests to complete")
	}

	// Verify that we got both successes and appropriate handling
	successCount := 0
	for i, result := range results {
		if result {
			successCount++
		}
		t.Logf("Request %d: %v", i, result)
	}

	// We should have some successful request handling
	if successCount == 0 {
		t.Error("Expected at least some requests to be handled successfully")
	}

	// Clean up
	cancel()
	router.wg.Wait()
}

// TestErrorPropagation_HandlerPanics tests panic recovery in handlers
func TestErrorPropagation_HandlerPanics(t *testing.T) {
	// Create a gateway that sends malformed messages to trigger panic recovery
	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		upgrader := websocket.Upgrader{}
		conn, err := upgrader.Upgrade(w, r, nil)
		if err != nil {
			return
		}
		defer conn.Close()

		// Send a malformed message that will trigger error handling
		conn.WriteMessage(websocket.TextMessage, []byte("invalid json"))
	}))
	defer server.Close()

	// Create router
	wsURL := "ws" + strings.TrimPrefix(server.URL, "http")
	cfg := &config.Config{
		Gateway: config.GatewayConfig{
			URL: wsURL,
		},
		Local: config.LocalConfig{
			RequestTimeoutMs: 1000,
		},
	}

	router, err := New(cfg, testutil.NewTestLogger(t))
	if err != nil {
		t.Fatalf("Failed to create router: %v", err)
	}

	// Connect and setup properly
	ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
	defer cancel()
	router.ctx = ctx
	router.cancel = cancel

	if err := router.gwClient.Connect(ctx); err != nil {
		t.Fatalf("Failed to connect: %v", err)
	}
	defer router.gwClient.Close()
	router.setState(StateConnected)

	// Start handler
	router.wg.Add(1)
	go router.handleWSToStdout()

	// This should not panic the test - the router should handle errors gracefully
	req := mcp.Request{
		JSONRPC: "2.0",
		Method:  "test.panic",
		ID:      "panic-1",
	}
	reqData, _ := json.Marshal(req)

	// Process message - this should trigger the malformed response handling
	err = router.processStdinMessage(reqData)

	// The router should handle the error gracefully, not panic
	if err != nil && !strings.Contains(err.Error(), "timeout") && !strings.Contains(err.Error(), "context") {
		t.Errorf("Unexpected error type: %v", err)
	}

	// Clean up
	cancel()
	router.wg.Wait()

	// If we get here, error was handled gracefully
	t.Log("Error handling worked properly without panics")
}

// Helper types for testing

type mockRateLimiter struct {
	shouldReject bool
}

func (m *mockRateLimiter) Allow(ctx context.Context) error {
	if m.shouldReject {
		return errors.New("rate limit exceeded")
	}
	return nil
}

func (m *mockRateLimiter) Wait(ctx context.Context) error {
	if m.shouldReject {
		return errors.New("rate limit exceeded")
	}
	return nil
}

// NOTE: Removed panicStdioHandler as direct handler override is not supported
// with the current concrete type implementation

// TestErrorPropagation_MetricsUpdate tests that successful MCP error responses are handled properly
func TestErrorPropagation_MetricsUpdate(t *testing.T) {
	// Create gateway that can handle multiple connections and returns MCP error responses
	requestCount := int32(0)
	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		upgrader := websocket.Upgrader{}
		conn, err := upgrader.Upgrade(w, r, nil)
		if err != nil {
			return
		}
		defer conn.Close()

		// Handle multiple messages per connection
		for {
			var msg gateway.WireMessage
			if err := conn.ReadJSON(&msg); err != nil {
				break
			}

			atomic.AddInt32(&requestCount, 1)

			// Return MCP error response (this is still a successful response delivery)
			resp := gateway.WireMessage{
				ID:        msg.ID,
				Timestamp: time.Now().UTC().Format(time.RFC3339),
				Source:    "gateway",
				MCPPayload: mcp.Response{
					JSONRPC: "2.0",
					ID:      msg.ID,
					Error: &mcp.Error{
						Code:    -32603,
						Message: "Internal error",
					},
				},
			}
			if err := conn.WriteJSON(resp); err != nil {
				break
			}
		}
	}))
	defer server.Close()

	wsURL := "ws" + strings.TrimPrefix(server.URL, "http")
	cfg := &config.Config{
		Gateway: config.GatewayConfig{
			URL: wsURL,
		},
		Local: config.LocalConfig{
			RequestTimeoutMs: 1000,
		},
	}

	router, err := New(cfg, testutil.NewTestLogger(t))
	if err != nil {
		t.Fatalf("Failed to create router: %v", err)
	}

	// Connect and start handlers properly
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()
	router.ctx = ctx
	router.cancel = cancel

	if err := router.gwClient.Connect(ctx); err != nil {
		t.Fatalf("Failed to connect: %v", err)
	}
	defer router.gwClient.Close()
	router.setState(StateConnected)

	router.wg.Add(1)
	go router.handleWSToStdout()

	// Check initial metrics
	initialResponses := router.metrics.ResponsesTotal
	initialErrors := router.metrics.ErrorsTotal

	// Send requests that will receive MCP error responses
	for i := 0; i < 5; i++ {
		req := mcp.Request{
			JSONRPC: "2.0",
			Method:  "test.error",
			ID:      fmt.Sprintf("error-%d", i),
		}
		reqData, _ := json.Marshal(req)
		router.processStdinMessage(reqData)

		// Wait for response with timeout
		select {
		case responseData := <-router.stdoutChan:
			// Verify it's an MCP error response
			var resp mcp.Response
			if err := json.Unmarshal(responseData, &resp); err != nil {
				t.Errorf("Failed to unmarshal response: %v", err)
			} else if resp.Error == nil {
				t.Errorf("Expected error response, got success response")
			}
		case <-time.After(2 * time.Second):
			t.Fatalf("Timeout waiting for response %d", i)
		}
	}

	// MCP error responses are successfully delivered responses, not router errors
	// So ResponsesTotal should increase, but ErrorsTotal should not
	if router.metrics.ResponsesTotal != initialResponses+5 {
		t.Errorf("Expected ResponsesTotal to be %d, got %d", initialResponses+5, router.metrics.ResponsesTotal)
	}

	// ErrorsTotal should NOT increase because MCP errors are successful response deliveries
	if router.metrics.ErrorsTotal != initialErrors {
		t.Errorf("Expected ErrorsTotal to remain %d (MCP errors are not router errors), got %d", initialErrors, router.metrics.ErrorsTotal)
	}

	// Verify all requests were processed by the gateway
	if atomic.LoadInt32(&requestCount) != 5 {
		t.Errorf("Expected gateway to receive 5 requests, got %d", atomic.LoadInt32(&requestCount))
	}

	// Clean up
	cancel()
	router.wg.Wait()
}
