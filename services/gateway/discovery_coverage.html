
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>discovery: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/actual-software/mcp-bridge/services/gateway/internal/discovery/consul.go (46.7%)</option>
				
				<option value="file1">github.com/actual-software/mcp-bridge/services/gateway/internal/discovery/factory.go (100.0%)</option>
				
				<option value="file2">github.com/actual-software/mcp-bridge/services/gateway/internal/discovery/kubernetes.go (69.9%)</option>
				
				<option value="file3">github.com/actual-software/mcp-bridge/services/gateway/internal/discovery/sse_discovery.go (55.9%)</option>
				
				<option value="file4">github.com/actual-software/mcp-bridge/services/gateway/internal/discovery/static.go (96.7%)</option>
				
				<option value="file5">github.com/actual-software/mcp-bridge/services/gateway/internal/discovery/stdio_discovery.go (59.1%)</option>
				
				<option value="file6">github.com/actual-software/mcp-bridge/services/gateway/internal/discovery/websocket_discovery.go (60.5%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package discovery

import (
        "context"
        "encoding/json"
        "fmt"
        "strconv"
        "strings"
        "sync"
        "time"

        consulapi "github.com/hashicorp/consul/api"
        "go.uber.org/zap"

        "github.com/actual-software/mcp-bridge/services/gateway/internal/config"
)

// ConsulDiscovery implements service discovery using Consul.
type ConsulDiscovery struct {
        config config.ServiceDiscoveryConfig
        logger *zap.Logger
        client *consulapi.Client

        // Service registry
        endpoints map[string][]Endpoint // namespace -&gt; endpoints
        mu        sync.RWMutex

        // Watch management
        ctx       context.Context
        cancel    context.CancelFunc
        wg        sync.WaitGroup
        lastIndex uint64
}

// ConsulConfig contains Consul-specific configuration.
type ConsulConfig struct {
        Address       string `mapstructure:"address" yaml:"address"`
        ServicePrefix string `mapstructure:"service_prefix" yaml:"service_prefix"`
        Datacenter    string `mapstructure:"datacenter" yaml:"datacenter"`
        Token         string `mapstructure:"token" yaml:"token"`
        TLSEnabled    bool   `mapstructure:"tls_enabled" yaml:"tls_enabled"`
        TLSSkipVerify bool   `mapstructure:"tls_skip_verify" yaml:"tls_skip_verify"`
        WatchTimeout  string `mapstructure:"watch_timeout" yaml:"watch_timeout"`
}

// NewConsulDiscovery creates a new Consul service discovery.
func NewConsulDiscovery(cfg config.ServiceDiscoveryConfig, consulCfg ConsulConfig, logger *zap.Logger) (*ConsulDiscovery, error) <span class="cov8" title="1">{
        // Create Consul client configuration
        clientConfig := consulapi.DefaultConfig()

        if consulCfg.Address != "" </span><span class="cov8" title="1">{
                clientConfig.Address = consulCfg.Address
        }</span>
        <span class="cov8" title="1">if consulCfg.Datacenter != "" </span><span class="cov8" title="1">{
                clientConfig.Datacenter = consulCfg.Datacenter
        }</span>
        <span class="cov8" title="1">if consulCfg.Token != "" </span><span class="cov8" title="1">{
                clientConfig.Token = consulCfg.Token
        }</span>

        // Configure TLS
        <span class="cov8" title="1">if consulCfg.TLSEnabled </span><span class="cov8" title="1">{
                clientConfig.Scheme = "https"
                if consulCfg.TLSSkipVerify </span><span class="cov8" title="1">{
                        clientConfig.TLSConfig.InsecureSkipVerify = true
                }</span>
        }

        <span class="cov8" title="1">client, err := consulapi.NewClient(clientConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create Consul client: %w", err)
        }</span>

        <span class="cov8" title="1">ctx, cancel := context.WithCancel(context.Background())

        return &amp;ConsulDiscovery{
                config:    cfg,
                logger:    logger,
                client:    client,
                endpoints: make(map[string][]Endpoint),
                ctx:       ctx,
                cancel:    cancel,
        }, nil</span>
}

// Start starts the Consul service discovery.
func (d *ConsulDiscovery) Start(_ context.Context) error <span class="cov0" title="0">{
        d.logger.Info("Starting Consul service discovery")

        // Initial discovery
        if err := d.discoverServices(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("initial service discovery failed: %w", err)
        }</span>

        // Start service watcher
        <span class="cov0" title="0">d.wg.Add(1)
        go d.watchServices()

        // Start periodic health checks
        d.wg.Add(1)
        go d.periodicHealthCheck()

        return nil</span>
}

// Stop stops the Consul service discovery.
func (d *ConsulDiscovery) Stop() <span class="cov8" title="1">{
        d.logger.Info("Stopping Consul service discovery")

        // Cancel context to stop watchers
        d.cancel()

        // Wait for goroutines
        d.wg.Wait()
}</span>

// discoverServices performs initial service discovery from Consul.
func (d *ConsulDiscovery) discoverServices() error <span class="cov0" title="0">{
        // Get service prefix from config (default: "mcp/")
        servicePrefix := "mcp/"

        d.logger.Debug("Discovering Consul services", zap.String("prefix", servicePrefix))

        // List all services with the MCP prefix
        services, _, err := d.client.Catalog().Services(&amp;consulapi.QueryOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to list Consul services: %w", err)
        }</span>

        <span class="cov0" title="0">d.mu.Lock()
        defer d.mu.Unlock()

        // Clear existing endpoints
        d.endpoints = make(map[string][]Endpoint)

        for serviceName, tags := range services </span><span class="cov0" title="0">{
                // Skip services that don't match our prefix
                if !strings.HasPrefix(serviceName, servicePrefix) </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Check if service has MCP tag
                <span class="cov0" title="0">if !d.hasTag(tags, "mcp") </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Get healthy service instances
                <span class="cov0" title="0">serviceEntries, _, err := d.client.Health().Service(serviceName, "", true, &amp;consulapi.QueryOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        d.logger.Warn("Failed to get service health",
                                zap.String("service", serviceName),
                                zap.Error(err))
                        continue</span>
                }

                <span class="cov0" title="0">for _, entry := range serviceEntries </span><span class="cov0" title="0">{
                        endpoint, err := d.consulServiceToEndpoint(entry, servicePrefix)
                        if err != nil </span><span class="cov0" title="0">{
                                d.logger.Warn("Failed to convert Consul service to endpoint",
                                        zap.String("service", serviceName),
                                        zap.Error(err))
                                continue</span>
                        }

                        <span class="cov0" title="0">if endpoint.Namespace != "" </span><span class="cov0" title="0">{
                                d.endpoints[endpoint.Namespace] = append(d.endpoints[endpoint.Namespace], *endpoint)
                        }</span>
                }
        }

        // Log discovery results
        <span class="cov0" title="0">totalEndpoints := 0
        for ns, eps := range d.endpoints </span><span class="cov0" title="0">{
                d.logger.Info("Discovered MCP services in namespace",
                        zap.String("namespace", ns),
                        zap.Int("count", len(eps)))
                totalEndpoints += len(eps)
        }</span>

        <span class="cov0" title="0">d.logger.Info("Consul service discovery completed", zap.Int("total_endpoints", totalEndpoints))

        return nil</span>
}

// consulServiceToEndpoint converts a Consul service entry to our Endpoint format.
func (d *ConsulDiscovery) consulServiceToEndpoint(entry *consulapi.ServiceEntry, servicePrefix string) (*Endpoint, error) <span class="cov8" title="1">{
        service := entry.Service

        // Extract MCP namespace from service name (remove prefix)
        mcpNamespace := strings.TrimPrefix(service.Service, servicePrefix)
        if mcpNamespace == service.Service </span><span class="cov0" title="0">{
                // Prefix wasn't found, use metadata
                if ns, ok := service.Meta["mcp_namespace"]; ok </span><span class="cov0" title="0">{
                        mcpNamespace = ns
                }</span> else<span class="cov0" title="0"> {
                        mcpNamespace = "default"
                }</span>
        }

        // Determine scheme and port
        <span class="cov8" title="1">scheme := "http"
        port := service.Port

        if d.hasTag(service.Tags, "https") </span><span class="cov0" title="0">{
                scheme = "https"
        }</span> else<span class="cov8" title="1"> if d.hasTag(service.Tags, "websocket") || d.hasTag(service.Tags, "ws") </span><span class="cov8" title="1">{
                scheme = "ws"
                if d.hasTag(service.Tags, "tls") </span><span class="cov8" title="1">{
                        scheme = "wss"
                }</span>
        }

        // Parse tools from service metadata
        <span class="cov8" title="1">var tools []ToolInfo
        if toolsJSON, ok := service.Meta["mcp_tools"]; ok </span><span class="cov8" title="1">{
                if err := json.Unmarshal([]byte(toolsJSON), &amp;tools); err != nil </span><span class="cov0" title="0">{
                        d.logger.Warn("Failed to parse tools metadata",
                                zap.String("service", service.Service),
                                zap.Error(err))
                }</span>
        }

        // Parse weight
        <span class="cov8" title="1">weight := 100 // Default weight
        if weightStr, ok := service.Meta["mcp_weight"]; ok </span><span class="cov8" title="1">{
                if w, err := strconv.Atoi(weightStr); err == nil </span><span class="cov8" title="1">{
                        weight = w
                }</span>
        }

        // Parse path
        <span class="cov8" title="1">path := "/"
        if p, ok := service.Meta["mcp_path"]; ok </span><span class="cov8" title="1">{
                path = p
        }</span>

        <span class="cov8" title="1">endpoint := &amp;Endpoint{
                Service:   service.Service,
                Namespace: mcpNamespace,
                Address:   service.Address,
                Port:      port,
                Scheme:    scheme,
                Path:      path,
                Weight:    weight,
                Metadata: map[string]string{
                        "consul_id":         service.ID,
                        "consul_datacenter": entry.Node.Datacenter,
                        "consul_node":       entry.Node.Node,
                        "protocol":          d.inferProtocol(service),
                },
                Tools:   tools,
                Healthy: d.isHealthy(entry),
        }

        // Add service metadata
        for k, v := range service.Meta </span><span class="cov8" title="1">{
                endpoint.Metadata[k] = v
        }</span>

        <span class="cov8" title="1">return endpoint, nil</span>
}

// watchServices watches for service changes in Consul.
func (d *ConsulDiscovery) watchServices() <span class="cov0" title="0">{
        defer d.wg.Done()

        watchTimeout := 10 * time.Minute

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-d.ctx.Done():<span class="cov0" title="0">
                        return</span>
                default:<span class="cov0" title="0"></span>
                }

                // Watch for service changes
                <span class="cov0" title="0">opts := &amp;consulapi.QueryOptions{
                        WaitIndex: d.lastIndex,
                        WaitTime:  watchTimeout,
                }

                _, meta, err := d.client.Catalog().Services(opts)
                if err != nil </span><span class="cov0" title="0">{
                        d.logger.Error("Consul service watch failed", zap.Error(err))
                        time.Sleep(5 * time.Second) // Back off on error
                        continue</span>
                }

                // Update last index for long polling
                <span class="cov0" title="0">d.lastIndex = meta.LastIndex

                // Check if services changed
                if meta.LastIndex &gt; opts.WaitIndex </span><span class="cov0" title="0">{
                        d.logger.Debug("Consul services changed, updating discovery")
                        if err := d.discoverServices(); err != nil </span><span class="cov0" title="0">{
                                d.logger.Error("Failed to update service discovery", zap.Error(err))
                        }</span>
                }
        }
}

// periodicHealthCheck performs periodic health checks and cleanup.
func (d *ConsulDiscovery) periodicHealthCheck() <span class="cov0" title="0">{
        defer d.wg.Done()

        ticker := time.NewTicker(30 * time.Second)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-d.ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        if err := d.updateHealthStatus(); err != nil </span><span class="cov0" title="0">{
                                d.logger.Error("Failed to update health status", zap.Error(err))
                        }</span>
                }
        }
}

// updateHealthStatus updates the health status of all endpoints.
func (d *ConsulDiscovery) updateHealthStatus() error <span class="cov0" title="0">{
        d.mu.Lock()
        defer d.mu.Unlock()

        servicePrefix := "mcp/"

        for namespace, endpoints := range d.endpoints </span><span class="cov0" title="0">{
                for i := range endpoints </span><span class="cov0" title="0">{
                        endpoint := &amp;endpoints[i]

                        // Get current health from Consul
                        serviceName := servicePrefix + namespace
                        if endpoint.Metadata["consul_id"] != "" </span><span class="cov0" title="0">{
                                serviceName = endpoint.Service
                        }</span>

                        <span class="cov0" title="0">serviceEntries, _, err := d.client.Health().Service(serviceName, "", false, &amp;consulapi.QueryOptions{})
                        if err != nil </span><span class="cov0" title="0">{
                                d.logger.Warn("Failed to check service health",
                                        zap.String("service", serviceName),
                                        zap.Error(err))
                                continue</span>
                        }

                        // Find matching service instance
                        <span class="cov0" title="0">healthy := false
                        for _, entry := range serviceEntries </span><span class="cov0" title="0">{
                                if entry.Service.Address == endpoint.Address &amp;&amp; entry.Service.Port == endpoint.Port </span><span class="cov0" title="0">{
                                        healthy = d.isHealthy(entry)
                                        break</span>
                                }
                        }

                        <span class="cov0" title="0">if endpoint.Healthy != healthy </span><span class="cov0" title="0">{
                                d.logger.Debug("Endpoint health status changed",
                                        zap.String("endpoint", fmt.Sprintf("%s:%d", endpoint.Address, endpoint.Port)),
                                        zap.Bool("healthy", healthy))
                                endpoint.Healthy = healthy
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// hasTag checks if a tag exists in the tag list.
func (d *ConsulDiscovery) hasTag(tags []string, tag string) bool <span class="cov8" title="1">{
        for _, t := range tags </span><span class="cov8" title="1">{
                if strings.EqualFold(t, tag) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// isHealthy determines if a Consul service entry is healthy.
func (d *ConsulDiscovery) isHealthy(entry *consulapi.ServiceEntry) bool <span class="cov8" title="1">{
        for _, check := range entry.Checks </span><span class="cov8" title="1">{
                if check.Status != consulapi.HealthPassing </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// inferProtocol infers the MCP protocol from Consul service information.
func (d *ConsulDiscovery) inferProtocol(service *consulapi.AgentService) string <span class="cov8" title="1">{
        // Check explicit protocol metadata
        if protocol, ok := service.Meta["mcp_protocol"]; ok </span><span class="cov8" title="1">{
                return protocol
        }</span>

        // Infer from tags
        <span class="cov8" title="1">for _, tag := range service.Tags </span><span class="cov8" title="1">{
                switch strings.ToLower(tag) </span>{
                case "websocket", "ws":<span class="cov8" title="1">
                        return "websocket"</span>
                case "sse", "server-sent-events":<span class="cov8" title="1">
                        return "sse"</span>
                case "stdio", "process":<span class="cov8" title="1">
                        return "stdio"</span>
                case "http", "rest":<span class="cov8" title="1">
                        return "http"</span>
                }
        }

        // Default to HTTP
        <span class="cov8" title="1">return "http"</span>
}

// GetEndpoints returns endpoints for a specific namespace.
func (d *ConsulDiscovery) GetEndpoints(namespace string) []Endpoint <span class="cov8" title="1">{
        d.mu.RLock()
        defer d.mu.RUnlock()

        endpoints := d.endpoints[namespace]
        // Return a copy to avoid race conditions
        result := make([]Endpoint, len(endpoints))
        copy(result, endpoints)

        return result
}</span>

// GetAllEndpoints returns all discovered endpoints.
func (d *ConsulDiscovery) GetAllEndpoints() map[string][]Endpoint <span class="cov8" title="1">{
        d.mu.RLock()
        defer d.mu.RUnlock()

        // Return a copy
        result := make(map[string][]Endpoint)

        for k, v := range d.endpoints </span><span class="cov8" title="1">{
                endpoints := make([]Endpoint, len(v))
                copy(endpoints, v)
                result[k] = endpoints
        }</span>

        <span class="cov8" title="1">return result</span>
}

// ListNamespaces returns all namespaces with discovered services.
func (d *ConsulDiscovery) ListNamespaces() []string <span class="cov8" title="1">{
        d.mu.RLock()
        defer d.mu.RUnlock()

        namespaces := make([]string, 0, len(d.endpoints))
        for ns := range d.endpoints </span><span class="cov8" title="1">{
                namespaces = append(namespaces, ns)
        }</span>

        <span class="cov8" title="1">return namespaces</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Package discovery provides service discovery implementations for locating and managing MCP server endpoints.
package discovery

import (
        "fmt"

        "go.uber.org/zap"

        "github.com/actual-software/mcp-bridge/services/gateway/internal/config"
)

// NewServiceDiscovery creates a service discovery instance based on the provider configuration.
func NewServiceDiscovery(cfg config.ServiceDiscoveryConfig, logger *zap.Logger) (ServiceDiscovery, error) <span class="cov8" title="1">{
        // Get the effective provider (prefer Provider over Mode for consistency)
        provider := cfg.Provider
        if provider == "" &amp;&amp; cfg.Mode != "" </span><span class="cov8" title="1">{
                provider = cfg.Mode
        }</span>

        // Default to kubernetes if no provider specified
        <span class="cov8" title="1">if provider == "" </span><span class="cov8" title="1">{
                provider = "kubernetes"
        }</span>

        <span class="cov8" title="1">logger.Info("Initializing service discovery", zap.String("provider", provider))

        switch provider </span>{
        case "kubernetes":<span class="cov8" title="1">
                return NewKubernetesDiscovery(cfg, logger)</span>
        case "static":<span class="cov8" title="1">
                return NewStaticDiscovery(cfg, logger)</span>
        case "stdio":<span class="cov8" title="1">
                return NewStdioDiscovery(cfg.Stdio, logger)</span>
        case "websocket", "ws":<span class="cov8" title="1">
                return NewWebSocketDiscovery(cfg.WebSocket, logger)</span>
        case "sse", "server-sent-events":<span class="cov8" title="1">
                return NewSSEDiscovery(cfg.SSE, logger)</span>
        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("unsupported service discovery provider: %s", provider)</span>
        }
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package discovery

import (
        "context"
        "encoding/json"
        "fmt"
        "sync"
        "time"

        "go.uber.org/zap"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/labels"
        "k8s.io/apimachinery/pkg/watch"
        "k8s.io/client-go/kubernetes"
        "k8s.io/client-go/rest"

        "github.com/actual-software/mcp-bridge/services/gateway/internal/config"
)

// KubernetesDiscovery implements service discovery using Kubernetes API.
type KubernetesDiscovery struct {
        config config.ServiceDiscoveryConfig
        logger *zap.Logger
        client kubernetes.Interface

        // Service registry
        endpoints map[string][]Endpoint // namespace -&gt; endpoints
        mu        sync.RWMutex

        // Watchers
        watchers []watch.Interface
        ctx      context.Context
        cancel   context.CancelFunc
        wg       sync.WaitGroup
}

// NewKubernetesDiscovery creates a new Kubernetes service discovery.
func NewKubernetesDiscovery(cfg config.ServiceDiscoveryConfig, logger *zap.Logger) (*KubernetesDiscovery, error) <span class="cov8" title="1">{
        // Create Kubernetes client
        config, err := rest.InClusterConfig()
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to create in-cluster config: %w", err)
        }</span>

        <span class="cov0" title="0">client, err := kubernetes.NewForConfig(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create Kubernetes client: %w", err)
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithCancel(context.Background())

        return &amp;KubernetesDiscovery{
                config:    cfg,
                logger:    logger,
                client:    client,
                endpoints: make(map[string][]Endpoint),
                ctx:       ctx,
                cancel:    cancel,
        }, nil</span>
}

// Start starts the service discovery.
func (d *KubernetesDiscovery) Start(_ context.Context) error <span class="cov8" title="1">{
        d.logger.Info("Starting Kubernetes service discovery",
                zap.Strings("namespaces", d.config.NamespaceSelector),
                zap.Any("labels", d.config.LabelSelector),
        )

        // Initial discovery
        if err := d.discoverServices(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("initial service discovery failed: %w", err)
        }</span>

        // Start watchers for each namespace
        <span class="cov8" title="1">for _, namespace := range d.config.NamespaceSelector </span><span class="cov8" title="1">{
                if err := d.watchNamespace(namespace); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to watch namespace %s: %w", namespace, err)
                }</span>
        }

        // Start periodic resync
        <span class="cov8" title="1">d.wg.Add(1)
        go d.periodicResync()

        return nil</span>
}

// Stop stops the service discovery.
func (d *KubernetesDiscovery) Stop() <span class="cov8" title="1">{
        d.logger.Info("Stopping Kubernetes service discovery")

        // Cancel context
        d.cancel()

        // Stop all watchers
        for _, watcher := range d.watchers </span><span class="cov8" title="1">{
                watcher.Stop()
        }</span>

        // Wait for goroutines
        <span class="cov8" title="1">d.wg.Wait()</span>
}

// discoverServices performs initial service discovery.
func (d *KubernetesDiscovery) discoverServices() error <span class="cov8" title="1">{
        d.mu.Lock()
        defer d.mu.Unlock()

        // Clear existing endpoints
        d.endpoints = make(map[string][]Endpoint)

        // Discover services in each namespace with retry
        for _, namespace := range d.config.NamespaceSelector </span><span class="cov8" title="1">{
                retryCount := 0
                maxRetries := 3

                var endpoints []Endpoint

                var err error

                for retryCount &lt; maxRetries </span><span class="cov8" title="1">{
                        endpoints, err = d.discoverNamespaceServices(namespace)
                        if err != nil </span><span class="cov0" title="0">{
                                retryCount++
                                d.logger.Warn("Failed to discover services in namespace, retrying",
                                        zap.String("namespace", namespace),
                                        zap.Error(err),
                                        zap.Int("retry", retryCount),
                                        zap.Int("max_retries", maxRetries),
                                )

                                if retryCount &lt; maxRetries </span><span class="cov0" title="0">{
                                        // Exponential backoff: 1s, 2s, 4s
                                        time.Sleep(time.Duration(1&lt;&lt;uint(retryCount-1)) * time.Second) // #nosec G115 - retryCount is bounded

                                        continue</span>
                                }

                                // All retries failed
                                <span class="cov0" title="0">d.logger.Error("Failed to discover services in namespace after retries",
                                        zap.String("namespace", namespace),
                                        zap.Error(err),
                                )

                                continue</span>
                        }
                        // Discovery succeeded
                        <span class="cov8" title="1">break</span>
                }

                // Group endpoints by MCP namespace
                <span class="cov8" title="1">for _, ep := range endpoints </span><span class="cov8" title="1">{
                        d.endpoints[ep.Namespace] = append(d.endpoints[ep.Namespace], ep)
                }</span>

                <span class="cov8" title="1">if len(endpoints) &gt; 0 </span><span class="cov8" title="1">{
                        d.logger.Info("Discovered MCP services",
                                zap.String("k8s_namespace", namespace),
                                zap.Int("count", len(endpoints)),
                        )
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// discoverNamespaceServices discovers services in a specific namespace.
func (d *KubernetesDiscovery) discoverNamespaceServices(namespace string) ([]Endpoint, error) <span class="cov8" title="1">{
        // List services with label selector
        labelSelector := labels.SelectorFromSet(d.config.LabelSelector).String()

        services, err := d.client.CoreV1().Services(namespace).List(d.ctx, metav1.ListOptions{
                LabelSelector: labelSelector,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list services: %w", err)
        }</span>

        <span class="cov8" title="1">var endpoints []Endpoint

        for _, svc := range services.Items </span><span class="cov8" title="1">{
                // Skip services without the MCP annotation
                if svc.Annotations["mcp.bridge/enabled"] != "true" </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Get the MCP namespace from annotations
                <span class="cov8" title="1">mcpNamespace := svc.Annotations["mcp.bridge/namespace"]
                if mcpNamespace == "" </span><span class="cov8" title="1">{
                        d.logger.Warn("Service missing MCP namespace annotation",
                                zap.String("service", svc.Name),
                                zap.String("namespace", namespace),
                        )

                        continue</span>
                }

                // Parse tools from annotations
                <span class="cov8" title="1">var tools []ToolInfo
                if toolsJSON := svc.Annotations["mcp.bridge/tools"]; toolsJSON != "" </span><span class="cov8" title="1">{
                        if err := json.Unmarshal([]byte(toolsJSON), &amp;tools); err != nil </span><span class="cov8" title="1">{
                                d.logger.Error("Failed to parse tools annotation",
                                        zap.String("service", svc.Name),
                                        zap.Error(err),
                                )
                        }</span>
                }

                // Get endpoints for the service
                <span class="cov8" title="1">endpointList, err := d.client.CoreV1().Endpoints(namespace).Get(d.ctx, svc.Name, metav1.GetOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        d.logger.Error("Failed to get endpoints",
                                zap.String("service", svc.Name),
                                zap.Error(err),
                        )

                        continue</span>
                }

                // Create endpoint entries
                <span class="cov8" title="1">for _, subset := range endpointList.Subsets </span><span class="cov8" title="1">{
                        for _, addr := range subset.Addresses </span><span class="cov8" title="1">{
                                for _, port := range subset.Ports </span><span class="cov8" title="1">{
                                        if port.Name != "mcp" </span><span class="cov8" title="1">{
                                                continue</span>
                                        }

                                        <span class="cov8" title="1">endpoint := Endpoint{
                                                Service:   svc.Name,
                                                Namespace: mcpNamespace,
                                                Address:   addr.IP,
                                                Port:      int(port.Port),
                                                Weight:    100, // Default weight
                                                Metadata: map[string]string{
                                                        "k8s_namespace": namespace,
                                                        "k8s_service":   svc.Name,
                                                },
                                                Tools:   tools,
                                                Healthy: true,
                                        }

                                        // Parse weight from annotations
                                        if weight := svc.Annotations["mcp.bridge/weight"]; weight != "" </span><span class="cov8" title="1">{
                                                if _, err := fmt.Sscanf(weight, "%d", &amp;endpoint.Weight); err != nil </span><span class="cov0" title="0">{
                                                        // Use default weight if parsing fails
                                                        endpoint.Weight = 1
                                                }</span>
                                        }

                                        <span class="cov8" title="1">endpoints = append(endpoints, endpoint)</span>
                                }
                        }
                }
        }

        <span class="cov8" title="1">return endpoints, nil</span>
}

// watchNamespace starts watching for service changes in a namespace.
func (d *KubernetesDiscovery) watchNamespace(namespace string) error <span class="cov8" title="1">{
        labelSelector := labels.SelectorFromSet(d.config.LabelSelector).String()

        // Watch services
        serviceWatcher, err := d.client.CoreV1().Services(namespace).Watch(d.ctx, metav1.ListOptions{
                LabelSelector: labelSelector,
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create service watcher: %w", err)
        }</span>

        <span class="cov8" title="1">d.watchers = append(d.watchers, serviceWatcher)

        // Watch endpoints
        endpointWatcher, err := d.client.CoreV1().Endpoints(namespace).Watch(d.ctx, metav1.ListOptions{
                LabelSelector: labelSelector,
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create endpoint watcher: %w", err)
        }</span>

        <span class="cov8" title="1">d.watchers = append(d.watchers, endpointWatcher)

        // Handle service events
        d.wg.Add(1)

        go func() </span><span class="cov8" title="1">{
                defer d.wg.Done()
                d.handleServiceEvents(namespace, serviceWatcher.ResultChan())
        }</span>()

        // Handle endpoint events
        <span class="cov8" title="1">d.wg.Add(1)

        go func() </span><span class="cov8" title="1">{
                defer d.wg.Done()
                d.handleEndpointEvents(namespace, endpointWatcher.ResultChan())
        }</span>()

        <span class="cov8" title="1">return nil</span>
}

// handleServiceEvents handles service watch events.
func (d *KubernetesDiscovery) handleServiceEvents(namespace string, events &lt;-chan watch.Event) <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-d.ctx.Done():<span class="cov8" title="1">
                        return</span>
                case event, ok := &lt;-events:<span class="cov8" title="1">
                        if !ok </span><span class="cov0" title="0">{
                                d.logger.Warn("Service watch channel closed", zap.String("namespace", namespace))

                                return
                        }</span>

                        <span class="cov8" title="1">switch event.Type </span>{
                        case watch.Added, watch.Modified, watch.Deleted:<span class="cov8" title="1">
                                // Resync the namespace
                                endpoints, err := d.discoverNamespaceServices(namespace)
                                if err != nil </span><span class="cov0" title="0">{
                                        d.logger.Error("Failed to resync namespace",
                                                zap.String("namespace", namespace),
                                                zap.Error(err),
                                        )

                                        continue</span>
                                }

                                <span class="cov8" title="1">d.mu.Lock()
                                if len(endpoints) &gt; 0 </span><span class="cov0" title="0">{
                                        d.endpoints[namespace] = endpoints
                                }</span> else<span class="cov8" title="1"> {
                                        delete(d.endpoints, namespace)
                                }</span>
                                <span class="cov8" title="1">d.mu.Unlock()

                                d.logger.Debug("Service discovery updated",
                                        zap.String("namespace", namespace),
                                        zap.String("event", string(event.Type)),
                                        zap.Int("endpoints", len(endpoints)),
                                )</span>
                        }
                }
        }
}

// handleEndpointEvents handles endpoint watch events.
func (d *KubernetesDiscovery) handleEndpointEvents(namespace string, events &lt;-chan watch.Event) <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-d.ctx.Done():<span class="cov8" title="1">
                        return</span>
                case event, ok := &lt;-events:<span class="cov0" title="0">
                        if !ok </span><span class="cov0" title="0">{
                                d.logger.Warn("Endpoint watch channel closed", zap.String("namespace", namespace))

                                return
                        }</span>

                        // For endpoint changes, resync the namespace
                        <span class="cov0" title="0">if event.Type == watch.Added || event.Type == watch.Modified || event.Type == watch.Deleted </span><span class="cov0" title="0">{
                                endpoints, err := d.discoverNamespaceServices(namespace)
                                if err != nil </span><span class="cov0" title="0">{
                                        d.logger.Error("Failed to resync namespace after endpoint change",
                                                zap.String("namespace", namespace),
                                                zap.Error(err),
                                        )

                                        continue</span>
                                }

                                <span class="cov0" title="0">d.mu.Lock()
                                if len(endpoints) &gt; 0 </span><span class="cov0" title="0">{
                                        d.endpoints[namespace] = endpoints
                                }</span> else<span class="cov0" title="0"> {
                                        delete(d.endpoints, namespace)
                                }</span>
                                <span class="cov0" title="0">d.mu.Unlock()</span>
                        }
                }
        }
}

// periodicResync performs periodic full resync.
func (d *KubernetesDiscovery) periodicResync() <span class="cov8" title="1">{
        defer d.wg.Done()

        ticker := time.NewTicker(5 * time.Minute)
        defer ticker.Stop()

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-d.ctx.Done():<span class="cov8" title="1">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        d.logger.Debug("Performing periodic resync")
                        // Retry resync with exponential backoff
                        retryCount := 0
                        maxRetries := 3

                        for retryCount &lt; maxRetries </span><span class="cov0" title="0">{
                                if err := d.discoverServices(); err != nil </span><span class="cov0" title="0">{
                                        retryCount++
                                        d.logger.Warn("Periodic resync failed, retrying",
                                                zap.Error(err),
                                                zap.Int("retry", retryCount),
                                                zap.Int("max_retries", maxRetries),
                                        )

                                        if retryCount &lt; maxRetries </span><span class="cov0" title="0">{
                                                // Exponential backoff: 5s, 10s, 20s
                                                time.Sleep(time.Duration(5&lt;&lt;uint(retryCount-1)) * time.Second) // #nosec G115 - retryCount is bounded

                                                continue</span>
                                        }

                                        // All retries failed
                                        <span class="cov0" title="0">d.logger.Error("Periodic resync failed after retries", zap.Error(err))</span>
                                }
                                // Resync succeeded
                                <span class="cov0" title="0">break</span>
                        }
                }
        }
}

// GetEndpoints returns endpoints for a specific namespace.
func (d *KubernetesDiscovery) GetEndpoints(namespace string) []Endpoint <span class="cov8" title="1">{
        d.mu.RLock()
        defer d.mu.RUnlock()

        endpoints := d.endpoints[namespace]
        // Return a copy to avoid race conditions
        result := make([]Endpoint, len(endpoints))
        copy(result, endpoints)

        return result
}</span>

// GetAllEndpoints returns all discovered endpoints.
func (d *KubernetesDiscovery) GetAllEndpoints() map[string][]Endpoint <span class="cov8" title="1">{
        d.mu.RLock()
        defer d.mu.RUnlock()

        // Return a copy
        result := make(map[string][]Endpoint)

        for k, v := range d.endpoints </span><span class="cov8" title="1">{
                endpoints := make([]Endpoint, len(v))
                copy(endpoints, v)
                result[k] = endpoints
        }</span>

        <span class="cov8" title="1">return result</span>
}

// ListNamespaces returns all namespaces with discovered services.
func (d *KubernetesDiscovery) ListNamespaces() []string <span class="cov8" title="1">{
        d.mu.RLock()
        defer d.mu.RUnlock()

        namespaces := make([]string, 0, len(d.endpoints))
        for ns := range d.endpoints </span><span class="cov8" title="1">{
                namespaces = append(namespaces, ns)
        }</span>

        <span class="cov8" title="1">return namespaces</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package discovery

import (
        "context"
        "fmt"
        "net/http"
        "net/url"
        "strconv"
        "strings"
        "time"

        "github.com/actual-software/mcp-bridge/services/gateway/internal/config"
        "go.uber.org/zap"
)

// SSEDiscovery implements service discovery for SSE-based MCP servers
type SSEDiscovery struct {
        config     config.SSEDiscoveryConfig
        logger     *zap.Logger
        services   map[string]*config.SSEServiceConfig
        httpClient *http.Client
}

// NewSSEDiscovery creates a new SSE service discovery instance
func NewSSEDiscovery(cfg config.SSEDiscoveryConfig, logger *zap.Logger) (ServiceDiscovery, error) <span class="cov8" title="1">{
        services := make(map[string]*config.SSEServiceConfig)
        for i := range cfg.Services </span><span class="cov8" title="1">{
                service := &amp;cfg.Services[i]

                // Set defaults
                if service.Weight == 0 </span><span class="cov8" title="1">{
                        service.Weight = 1
                }</span>
                <span class="cov8" title="1">if service.Namespace == "" </span><span class="cov8" title="1">{
                        service.Namespace = "default"
                }</span>
                <span class="cov8" title="1">if service.StreamEndpoint == "" </span><span class="cov8" title="1">{
                        service.StreamEndpoint = "/events"
                }</span>
                <span class="cov8" title="1">if service.RequestEndpoint == "" </span><span class="cov8" title="1">{
                        service.RequestEndpoint = "/api/v1/request"
                }</span>
                <span class="cov8" title="1">if service.Timeout == 0 </span><span class="cov8" title="1">{
                        service.Timeout = 10 * time.Second
                }</span>
                <span class="cov8" title="1">if service.HealthCheck.Interval == 0 </span><span class="cov8" title="1">{
                        service.HealthCheck.Interval = 30 * time.Second
                }</span>
                <span class="cov8" title="1">if service.HealthCheck.Timeout == 0 </span><span class="cov8" title="1">{
                        service.HealthCheck.Timeout = 5 * time.Second
                }</span>

                <span class="cov8" title="1">services[service.Name] = service</span>
        }

        // Create HTTP client for health checks
        <span class="cov8" title="1">httpClient := &amp;http.Client{
                Timeout: 10 * time.Second,
        }

        return &amp;SSEDiscovery{
                config:     cfg,
                logger:     logger.With(zap.String("discovery", "sse")),
                services:   services,
                httpClient: httpClient,
        }, nil</span>
}

// GetServices returns all discovered SSE services as endpoints
func (s *SSEDiscovery) GetServices(ctx context.Context) ([]Endpoint, error) <span class="cov8" title="1">{
        var endpoints []Endpoint

        for _, service := range s.services </span><span class="cov8" title="1">{
                u, err := url.Parse(service.BaseURL)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("invalid base URL",
                                zap.String("service", service.Name),
                                zap.String("url", service.BaseURL),
                                zap.Error(err))
                        continue</span>
                }

                // Determine port
                <span class="cov8" title="1">port := 80
                if u.Scheme == "https" </span><span class="cov8" title="1">{
                        port = 443
                }</span>
                <span class="cov8" title="1">if u.Port() != "" </span><span class="cov8" title="1">{
                        if p, err := strconv.Atoi(u.Port()); err == nil </span><span class="cov8" title="1">{
                                port = p
                        }</span>
                }

                <span class="cov8" title="1">endpoint := Endpoint{
                        Service:   service.Name,
                        Namespace: service.Namespace,
                        Address:   u.Hostname(),
                        Port:      port,
                        Scheme:    u.Scheme,
                        Path:      u.Path,
                        Weight:    service.Weight,
                        Metadata:  s.createMetadata(service),
                        Healthy:   true, // Assume healthy initially
                }

                // Perform basic connectivity check
                if err := s.checkServiceConnectivity(ctx, service); err != nil </span><span class="cov8" title="1">{
                        s.logger.Warn("service connectivity check failed",
                                zap.String("service", service.Name),
                                zap.String("base_url", service.BaseURL),
                                zap.Error(err))
                        endpoint.Healthy = false
                }</span>

                <span class="cov8" title="1">endpoints = append(endpoints, endpoint)</span>
        }

        <span class="cov8" title="1">s.logger.Debug("discovered SSE services", zap.Int("count", len(endpoints)))
        return endpoints, nil</span>
}

// GetService returns a specific service by name
func (s *SSEDiscovery) GetService(ctx context.Context, serviceName string) (*Endpoint, error) <span class="cov0" title="0">{
        service, exists := s.services[serviceName]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("service %s not found", serviceName)
        }</span>

        <span class="cov0" title="0">u, err := url.Parse(service.BaseURL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid base URL: %w", err)
        }</span>

        <span class="cov0" title="0">port := 80
        if u.Scheme == "https" </span><span class="cov0" title="0">{
                port = 443
        }</span>
        <span class="cov0" title="0">if u.Port() != "" </span><span class="cov0" title="0">{
                if p, err := strconv.Atoi(u.Port()); err == nil </span><span class="cov0" title="0">{
                        port = p
                }</span>
        }

        <span class="cov0" title="0">endpoint := &amp;Endpoint{
                Service:   service.Name,
                Namespace: service.Namespace,
                Address:   u.Hostname(),
                Port:      port,
                Scheme:    u.Scheme,
                Path:      u.Path,
                Weight:    service.Weight,
                Metadata:  s.createMetadata(service),
                Healthy:   true,
        }

        // Check connectivity
        if err := s.checkServiceConnectivity(ctx, service); err != nil </span><span class="cov0" title="0">{
                endpoint.Healthy = false
        }</span>

        <span class="cov0" title="0">return endpoint, nil</span>
}

// Watch monitors for changes in SSE service configuration
func (s *SSEDiscovery) Watch(ctx context.Context) (&lt;-chan []Endpoint, error) <span class="cov0" title="0">{
        ch := make(chan []Endpoint, 1)

        go func() </span><span class="cov0" title="0">{
                defer close(ch)

                ticker := time.NewTicker(30 * time.Second)
                defer ticker.Stop()

                // Send initial list
                if endpoints, err := s.GetServices(ctx); err == nil </span><span class="cov0" title="0">{
                        select </span>{
                        case ch &lt;- endpoints:<span class="cov0" title="0"></span>
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        }
                }

                // Periodically check and update
                <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        case &lt;-ticker.C:<span class="cov0" title="0">
                                if endpoints, err := s.GetServices(ctx); err == nil </span><span class="cov0" title="0">{
                                        select </span>{
                                        case ch &lt;- endpoints:<span class="cov0" title="0"></span>
                                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                                return</span>
                                        }
                                }
                        }
                }
        }()

        <span class="cov0" title="0">return ch, nil</span>
}

// HealthCheck performs a health check on an SSE service endpoint
func (s *SSEDiscovery) HealthCheck(ctx context.Context, endpoint *Endpoint) error <span class="cov0" title="0">{
        serviceName := endpoint.Service
        service, exists := s.services[serviceName]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("service %s not found for health check", serviceName)
        }</span>

        <span class="cov0" title="0">if !service.HealthCheck.Enabled </span><span class="cov0" title="0">{
                return nil // Health check disabled
        }</span>

        <span class="cov0" title="0">return s.checkServiceConnectivity(ctx, service)</span>
}

// checkServiceConnectivity performs connectivity checks for an SSE service
func (s *SSEDiscovery) checkServiceConnectivity(ctx context.Context, service *config.SSEServiceConfig) error <span class="cov8" title="1">{
        // Create a context with timeout for the health check
        healthCtx, cancel := context.WithTimeout(ctx, service.HealthCheck.Timeout)
        defer cancel()

        // Check both the stream endpoint and request endpoint
        streamURL := service.BaseURL + service.StreamEndpoint
        requestURL := service.BaseURL + service.RequestEndpoint

        // Check stream endpoint (should accept SSE connections)
        if err := s.checkSSEEndpoint(healthCtx, streamURL, service); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("stream endpoint check failed: %w", err)
        }</span>

        // Check request endpoint (should accept HTTP POST)
        <span class="cov0" title="0">if err := s.checkHTTPEndpoint(healthCtx, requestURL, service); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("request endpoint check failed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// checkSSEEndpoint checks if the SSE stream endpoint is accessible
func (s *SSEDiscovery) checkSSEEndpoint(ctx context.Context, streamURL string, service *config.SSEServiceConfig) error <span class="cov8" title="1">{
        req, err := http.NewRequestWithContext(ctx, "GET", streamURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create SSE request: %w", err)
        }</span>

        // Set SSE headers
        <span class="cov8" title="1">req.Header.Set("Accept", "text/event-stream")
        req.Header.Set("Cache-Control", "no-cache")

        // Add custom headers
        for k, v := range service.Headers </span><span class="cov8" title="1">{
                req.Header.Set(k, v)
        }</span>

        <span class="cov8" title="1">resp, err := s.httpClient.Do(req)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to connect to SSE stream: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := resp.Body.Close(); err != nil </span><span class="cov0" title="0">{
                        s.logger.Debug("Failed to close response body", zap.Error(err))
                }</span>
        }()

        // Check status code
        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return fmt.Errorf("SSE stream returned status %d", resp.StatusCode)
        }</span>

        // Check content type
        <span class="cov0" title="0">contentType := resp.Header.Get("Content-Type")
        if !strings.HasPrefix(contentType, "text/event-stream") </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid content type for SSE: %s", contentType)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// checkHTTPEndpoint checks if the HTTP request endpoint is accessible
func (s *SSEDiscovery) checkHTTPEndpoint(ctx context.Context, requestURL string, service *config.SSEServiceConfig) error <span class="cov0" title="0">{
        // Try a HEAD request first to avoid sending actual data
        req, err := http.NewRequestWithContext(ctx, "HEAD", requestURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create HTTP request: %w", err)
        }</span>

        // Add custom headers
        <span class="cov0" title="0">for k, v := range service.Headers </span><span class="cov0" title="0">{
                req.Header.Set(k, v)
        }</span>

        <span class="cov0" title="0">resp, err := s.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to connect to HTTP endpoint: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := resp.Body.Close(); err != nil </span><span class="cov0" title="0">{
                        s.logger.Debug("Failed to close response body", zap.Error(err))
                }</span>
        }()

        // For HEAD requests, we expect either 200 or 405 (Method Not Allowed)
        // 405 is acceptable because it means the endpoint exists but doesn't support HEAD
        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK &amp;&amp; resp.StatusCode != http.StatusMethodNotAllowed </span><span class="cov0" title="0">{
                return fmt.Errorf("HTTP endpoint returned status %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// createMetadata creates metadata map with SSE-specific information
func (s *SSEDiscovery) createMetadata(service *config.SSEServiceConfig) map[string]string <span class="cov8" title="1">{
        metadata := make(map[string]string)

        // Copy user-defined metadata
        for k, v := range service.Metadata </span><span class="cov8" title="1">{
                metadata[k] = v
        }</span>

        // Add SSE-specific metadata
        <span class="cov8" title="1">metadata["protocol"] = "sse"
        metadata["base_url"] = service.BaseURL
        metadata["stream_endpoint"] = service.StreamEndpoint
        metadata["request_endpoint"] = service.RequestEndpoint
        metadata["health_check_enabled"] = strconv.FormatBool(service.HealthCheck.Enabled)
        metadata["timeout"] = service.Timeout.String()

        // Add header information (excluding sensitive data)
        for k, v := range service.Headers </span><span class="cov8" title="1">{
                // Only include non-sensitive headers
                if !strings.Contains(strings.ToLower(k), "authorization") &amp;&amp;
                        !strings.Contains(strings.ToLower(k), "password") &amp;&amp;
                        !strings.Contains(strings.ToLower(k), "secret") &amp;&amp;
                        !strings.Contains(strings.ToLower(k), "token") &amp;&amp;
                        !strings.Contains(strings.ToLower(k), "key") </span><span class="cov8" title="1">{
                        metadata["header_"+strings.ToLower(k)] = v
                }</span>
        }

        <span class="cov8" title="1">return metadata</span>
}

// GetAllEndpoints returns all endpoints from all namespaces
func (s *SSEDiscovery) GetAllEndpoints() map[string][]Endpoint <span class="cov8" title="1">{
        endpoints, _ := s.GetServices(context.Background()) //nolint:errcheck // Service discovery - error handled by caller
        result := make(map[string][]Endpoint)
        for _, endpoint := range endpoints </span><span class="cov8" title="1">{
                result[endpoint.Namespace] = append(result[endpoint.Namespace], endpoint)
        }</span>
        <span class="cov8" title="1">return result</span>
}

// Start starts the discovery service
func (s *SSEDiscovery) Start(ctx context.Context) error <span class="cov8" title="1">{
        return nil
}</span>

// Stop stops the discovery service
func (s *SSEDiscovery) Stop() {<span class="cov8" title="1">
}</span>

// GetEndpoints returns endpoints for a specific namespace
func (s *SSEDiscovery) GetEndpoints(namespace string) []Endpoint <span class="cov8" title="1">{
        endpoints, _ := s.GetServices(context.Background()) //nolint:errcheck // Service discovery - error handled by caller
        var result []Endpoint
        for _, endpoint := range endpoints </span><span class="cov8" title="1">{
                if endpoint.Namespace == namespace </span><span class="cov8" title="1">{
                        result = append(result, endpoint)
                }</span>
        }
        <span class="cov8" title="1">return result</span>
}

// ListNamespaces returns all available namespaces
func (s *SSEDiscovery) ListNamespaces() []string <span class="cov8" title="1">{
        endpoints, _ := s.GetServices(context.Background()) //nolint:errcheck // Service discovery - error handled by caller
        namespaces := make(map[string]bool)
        for _, endpoint := range endpoints </span><span class="cov8" title="1">{
                namespaces[endpoint.Namespace] = true
        }</span>
        <span class="cov8" title="1">var result []string
        for namespace := range namespaces </span><span class="cov8" title="1">{
                result = append(result, namespace)
        }</span>
        <span class="cov8" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package discovery

import (
        "context"
        "fmt"
        "net/url"
        "strconv"
        "sync"

        "go.uber.org/zap"

        "github.com/actual-software/mcp-bridge/services/gateway/internal/config"
)

// StaticDiscovery implements service discovery using static configuration.
type StaticDiscovery struct {
        config    config.ServiceDiscoveryConfig
        logger    *zap.Logger
        endpoints map[string][]Endpoint
        mu        sync.RWMutex
}

// NewStaticDiscovery creates a new static service discovery instance.
func NewStaticDiscovery(cfg config.ServiceDiscoveryConfig, logger *zap.Logger) (*StaticDiscovery, error) <span class="cov8" title="1">{
        if cfg.Static.Endpoints == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("static endpoints configuration is required")
        }</span>

        <span class="cov8" title="1">sd := &amp;StaticDiscovery{
                config:    cfg,
                logger:    logger,
                endpoints: make(map[string][]Endpoint),
        }

        // Convert configuration to internal endpoints
        if err := sd.loadEndpoints(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to load static endpoints: %w", err)
        }</span>

        <span class="cov8" title="1">return sd, nil</span>
}

// loadEndpoints converts configuration endpoints to internal endpoint format.
func (sd *StaticDiscovery) loadEndpoints() error <span class="cov8" title="1">{
        sd.mu.Lock()
        defer sd.mu.Unlock()

        for namespace, configs := range sd.config.Static.Endpoints </span><span class="cov8" title="1">{
                var endpoints []Endpoint

                for _, cfg := range configs </span><span class="cov8" title="1">{
                        endpoint, err := sd.configToEndpoint(namespace, cfg)
                        if err != nil </span><span class="cov8" title="1">{
                                sd.logger.Error("Failed to parse endpoint configuration",
                                        zap.String("namespace", namespace),
                                        zap.String("url", cfg.URL),
                                        zap.Error(err))

                                continue</span>
                        }

                        <span class="cov8" title="1">endpoints = append(endpoints, endpoint)</span>
                }

                <span class="cov8" title="1">if len(endpoints) &gt; 0 </span><span class="cov8" title="1">{
                        sd.endpoints[namespace] = endpoints
                        sd.logger.Info("Loaded static endpoints",
                                zap.String("namespace", namespace),
                                zap.Int("count", len(endpoints)))
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// configToEndpoint converts a configuration endpoint to an internal Endpoint.
func (sd *StaticDiscovery) configToEndpoint(namespace string, cfg config.EndpointConfig) (Endpoint, error) <span class="cov8" title="1">{
        parsedURL, err := url.Parse(cfg.URL)
        if err != nil </span><span class="cov8" title="1">{
                return Endpoint{}, fmt.Errorf("invalid URL %s: %w", cfg.URL, err)
        }</span>

        // Extract port from URL
        <span class="cov8" title="1">port := 80 // default

        if parsedURL.Port() != "" </span><span class="cov8" title="1">{
                if p, err := strconv.Atoi(parsedURL.Port()); err == nil </span><span class="cov8" title="1">{
                        port = p
                }</span>
        } else<span class="cov8" title="1"> if parsedURL.Scheme == "https" </span><span class="cov8" title="1">{
                port = 443
        }</span>

        // Convert labels to metadata
        <span class="cov8" title="1">metadata := make(map[string]string)

        for k, v := range cfg.Labels </span><span class="cov8" title="1">{
                if s, ok := v.(string); ok </span><span class="cov8" title="1">{
                        metadata[k] = s
                }</span> else<span class="cov0" title="0"> {
                        metadata[k] = fmt.Sprintf("%v", v)
                }</span>
        }

        <span class="cov8" title="1">return Endpoint{
                Service:   fmt.Sprintf("%s-service", namespace), // Generate service name
                Namespace: namespace,
                Address:   parsedURL.Hostname(),
                Port:      port,
                Scheme:    parsedURL.Scheme, // Store URL scheme (ws, wss, http, https)
                Path:      parsedURL.Path,   // Store URL path (/mcp)
                Weight:    100,              // Default weight
                Metadata:  metadata,
                Tools:     []ToolInfo{}, // Static discovery doesn't provide tool info
                Healthy:   true,         // Assume healthy for static endpoints
        }, nil</span>
}

// Start implements ServiceDiscovery interface.
func (sd *StaticDiscovery) Start(_ context.Context) error <span class="cov8" title="1">{
        sd.logger.Info("Starting static service discovery")

        return nil // Static discovery doesn't need to start any background processes
}</span>

// Stop implements ServiceDiscovery interface.
func (sd *StaticDiscovery) Stop() <span class="cov8" title="1">{
        sd.logger.Info("Stopping static service discovery")
        // Static discovery doesn't have background processes to stop
}</span>

// GetEndpoints implements ServiceDiscovery interface.
func (sd *StaticDiscovery) GetEndpoints(namespace string) []Endpoint <span class="cov8" title="1">{
        sd.mu.RLock()
        defer sd.mu.RUnlock()

        endpoints, exists := sd.endpoints[namespace]
        if !exists </span><span class="cov8" title="1">{
                return []Endpoint{}
        }</span>

        // Return a copy to avoid concurrent access issues
        <span class="cov8" title="1">result := make([]Endpoint, len(endpoints))
        copy(result, endpoints)

        return result</span>
}

// GetAllEndpoints implements ServiceDiscovery interface.
func (sd *StaticDiscovery) GetAllEndpoints() map[string][]Endpoint <span class="cov8" title="1">{
        sd.mu.RLock()
        defer sd.mu.RUnlock()

        // Return a deep copy to avoid concurrent access issues
        result := make(map[string][]Endpoint)

        for namespace, endpoints := range sd.endpoints </span><span class="cov8" title="1">{
                endpointsCopy := make([]Endpoint, len(endpoints))
                copy(endpointsCopy, endpoints)
                result[namespace] = endpointsCopy
        }</span>

        <span class="cov8" title="1">return result</span>
}

// ListNamespaces implements ServiceDiscovery interface.
func (sd *StaticDiscovery) ListNamespaces() []string <span class="cov8" title="1">{
        sd.mu.RLock()
        defer sd.mu.RUnlock()

        namespaces := make([]string, 0, len(sd.endpoints))
        for namespace := range sd.endpoints </span><span class="cov8" title="1">{
                namespaces = append(namespaces, namespace)
        }</span>

        <span class="cov8" title="1">return namespaces</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package discovery

import (
        "context"
        "fmt"
        "os/exec"
        "strconv"
        "strings"
        "time"

        "github.com/actual-software/mcp-bridge/services/gateway/internal/config"
        "go.uber.org/zap"
)

// StdioDiscovery implements service discovery for stdio-based MCP servers
type StdioDiscovery struct {
        config   config.StdioDiscoveryConfig
        logger   *zap.Logger
        services map[string]*config.StdioServiceConfig
}

// NewStdioDiscovery creates a new stdio service discovery instance
func NewStdioDiscovery(cfg config.StdioDiscoveryConfig, logger *zap.Logger) (ServiceDiscovery, error) <span class="cov8" title="1">{
        services := make(map[string]*config.StdioServiceConfig)
        for i := range cfg.Services </span><span class="cov8" title="1">{
                service := &amp;cfg.Services[i]

                // Set defaults
                if service.Weight == 0 </span><span class="cov8" title="1">{
                        service.Weight = 1
                }</span>
                <span class="cov8" title="1">if service.Namespace == "" </span><span class="cov8" title="1">{
                        service.Namespace = "default"
                }</span>
                <span class="cov8" title="1">if service.HealthCheck.Interval == 0 </span><span class="cov8" title="1">{
                        service.HealthCheck.Interval = 30 * time.Second
                }</span>
                <span class="cov8" title="1">if service.HealthCheck.Timeout == 0 </span><span class="cov8" title="1">{
                        service.HealthCheck.Timeout = 5 * time.Second
                }</span>

                <span class="cov8" title="1">services[service.Name] = service</span>
        }

        <span class="cov8" title="1">return &amp;StdioDiscovery{
                config:   cfg,
                logger:   logger.With(zap.String("discovery", "stdio")),
                services: services,
        }, nil</span>
}

// GetServices returns all discovered stdio services as endpoints
func (s *StdioDiscovery) GetServices(ctx context.Context) ([]Endpoint, error) <span class="cov8" title="1">{
        var endpoints []Endpoint

        for _, service := range s.services </span><span class="cov8" title="1">{
                endpoint := Endpoint{
                        Service:   service.Name,
                        Namespace: service.Namespace,
                        Address:   strings.Join(service.Command, " "), // Store command as address
                        Port:      0,                                  // Not applicable for stdio
                        Scheme:    "stdio",
                        Path:      service.WorkingDir,
                        Weight:    service.Weight,
                        Metadata:  s.createMetadata(service),
                        Healthy:   true, // Assume healthy initially
                }

                // Check if the command is available
                if len(service.Command) &gt; 0 </span><span class="cov8" title="1">{
                        if _, err := exec.LookPath(service.Command[0]); err != nil </span><span class="cov0" title="0">{
                                s.logger.Warn("command not found in PATH",
                                        zap.String("service", service.Name),
                                        zap.String("command", service.Command[0]),
                                        zap.Error(err))
                                endpoint.Healthy = false
                        }</span>
                }

                <span class="cov8" title="1">endpoints = append(endpoints, endpoint)</span>
        }

        <span class="cov8" title="1">s.logger.Debug("discovered stdio services", zap.Int("count", len(endpoints)))
        return endpoints, nil</span>
}

// GetService returns a specific service by name
func (s *StdioDiscovery) GetService(ctx context.Context, serviceName string) (*Endpoint, error) <span class="cov0" title="0">{
        service, exists := s.services[serviceName]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("service %s not found", serviceName)
        }</span>

        <span class="cov0" title="0">endpoint := &amp;Endpoint{
                Service:   service.Name,
                Namespace: service.Namespace,
                Address:   strings.Join(service.Command, " "),
                Port:      0,
                Scheme:    "stdio",
                Path:      service.WorkingDir,
                Weight:    service.Weight,
                Metadata:  s.createMetadata(service),
                Healthy:   true,
        }

        // Check command availability
        if len(service.Command) &gt; 0 </span><span class="cov0" title="0">{
                if _, err := exec.LookPath(service.Command[0]); err != nil </span><span class="cov0" title="0">{
                        endpoint.Healthy = false
                }</span>
        }

        <span class="cov0" title="0">return endpoint, nil</span>
}

// Watch monitors for changes in stdio service configuration
func (s *StdioDiscovery) Watch(ctx context.Context) (&lt;-chan []Endpoint, error) <span class="cov0" title="0">{
        ch := make(chan []Endpoint, 1)

        // For stdio discovery, we'll just send the initial list and then
        // periodically check command availability
        go func() </span><span class="cov0" title="0">{
                defer close(ch)

                ticker := time.NewTicker(30 * time.Second)
                defer ticker.Stop()

                // Send initial list
                if endpoints, err := s.GetServices(ctx); err == nil </span><span class="cov0" title="0">{
                        select </span>{
                        case ch &lt;- endpoints:<span class="cov0" title="0"></span>
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        }
                }

                // Periodically check and update
                <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        case &lt;-ticker.C:<span class="cov0" title="0">
                                if endpoints, err := s.GetServices(ctx); err == nil </span><span class="cov0" title="0">{
                                        select </span>{
                                        case ch &lt;- endpoints:<span class="cov0" title="0"></span>
                                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                                return</span>
                                        }
                                }
                        }
                }
        }()

        <span class="cov0" title="0">return ch, nil</span>
}

// HealthCheck performs a health check on a stdio service
func (s *StdioDiscovery) HealthCheck(ctx context.Context, endpoint *Endpoint) error <span class="cov0" title="0">{
        serviceName := endpoint.Service
        service, exists := s.services[serviceName]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("service %s not found for health check", serviceName)
        }</span>

        <span class="cov0" title="0">if !service.HealthCheck.Enabled </span><span class="cov0" title="0">{
                return nil // Health check disabled
        }</span>

        <span class="cov0" title="0">if len(service.Command) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no command configured for service %s", serviceName)
        }</span>

        // Check if command is available
        <span class="cov0" title="0">if _, err := exec.LookPath(service.Command[0]); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("command %s not found: %w", service.Command[0], err)
        }</span>

        // For stdio services, we can't easily do a deep health check without starting the process
        // So we just verify the command exists and is executable
        <span class="cov0" title="0">return nil</span>
}

// createMetadata creates metadata map with stdio-specific information
func (s *StdioDiscovery) createMetadata(service *config.StdioServiceConfig) map[string]string <span class="cov8" title="1">{
        metadata := make(map[string]string)

        // Copy user-defined metadata
        for k, v := range service.Metadata </span><span class="cov8" title="1">{
                metadata[k] = v
        }</span>

        // Add stdio-specific metadata
        <span class="cov8" title="1">metadata["protocol"] = "stdio"
        metadata["command"] = strings.Join(service.Command, " ")
        metadata["working_dir"] = service.WorkingDir
        metadata["health_check_enabled"] = strconv.FormatBool(service.HealthCheck.Enabled)

        // Add environment variables as metadata (be careful with sensitive data)
        for k, v := range service.Env </span><span class="cov8" title="1">{
                // Only include non-sensitive environment variables
                if !strings.Contains(strings.ToLower(k), "password") &amp;&amp;
                        !strings.Contains(strings.ToLower(k), "secret") &amp;&amp;
                        !strings.Contains(strings.ToLower(k), "token") &amp;&amp;
                        !strings.Contains(strings.ToLower(k), "key") </span><span class="cov8" title="1">{
                        metadata["env_"+strings.ToLower(k)] = v
                }</span>
        }

        <span class="cov8" title="1">return metadata</span>
}

// GetAllEndpoints returns all endpoints from all namespaces
func (s *StdioDiscovery) GetAllEndpoints() map[string][]Endpoint <span class="cov8" title="1">{
        endpoints, _ := s.GetServices(context.Background()) //nolint:errcheck // Service discovery - error handled by caller
        result := make(map[string][]Endpoint)
        for _, endpoint := range endpoints </span><span class="cov8" title="1">{
                result[endpoint.Namespace] = append(result[endpoint.Namespace], endpoint)
        }</span>
        <span class="cov8" title="1">return result</span>
}

// Start starts the discovery service
func (s *StdioDiscovery) Start(ctx context.Context) error <span class="cov8" title="1">{
        // For stdio discovery, no initialization is needed
        return nil
}</span>

// Stop stops the discovery service
func (s *StdioDiscovery) Stop() {<span class="cov8" title="1">
        // For stdio discovery, no cleanup is needed
}</span>

// GetEndpoints returns endpoints for a specific namespace
func (s *StdioDiscovery) GetEndpoints(namespace string) []Endpoint <span class="cov8" title="1">{
        endpoints, _ := s.GetServices(context.Background()) //nolint:errcheck // Service discovery - error handled by caller
        var result []Endpoint
        for _, endpoint := range endpoints </span><span class="cov8" title="1">{
                if endpoint.Namespace == namespace </span><span class="cov8" title="1">{
                        result = append(result, endpoint)
                }</span>
        }
        <span class="cov8" title="1">return result</span>
}

// ListNamespaces returns all available namespaces
func (s *StdioDiscovery) ListNamespaces() []string <span class="cov8" title="1">{
        endpoints, _ := s.GetServices(context.Background()) //nolint:errcheck // Service discovery - error handled by caller
        namespaces := make(map[string]bool)
        for _, endpoint := range endpoints </span><span class="cov8" title="1">{
                namespaces[endpoint.Namespace] = true
        }</span>
        <span class="cov8" title="1">var result []string
        for namespace := range namespaces </span><span class="cov8" title="1">{
                result = append(result, namespace)
        }</span>
        <span class="cov8" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package discovery

import (
        "context"
        "fmt"
        "net/http"
        "net/url"
        "strconv"
        "strings"
        "time"

        "github.com/gorilla/websocket"
        "github.com/actual-software/mcp-bridge/services/gateway/internal/config"
        "go.uber.org/zap"
)

// WebSocketDiscovery implements service discovery for WebSocket-based MCP servers
type WebSocketDiscovery struct {
        config   config.WebSocketDiscoveryConfig
        logger   *zap.Logger
        services map[string]*config.WebSocketServiceConfig
}

// NewWebSocketDiscovery creates a new WebSocket service discovery instance
func NewWebSocketDiscovery(cfg config.WebSocketDiscoveryConfig, logger *zap.Logger) (ServiceDiscovery, error) <span class="cov8" title="1">{
        services := make(map[string]*config.WebSocketServiceConfig)
        for i := range cfg.Services </span><span class="cov8" title="1">{
                service := &amp;cfg.Services[i]

                // Set defaults
                if service.Weight == 0 </span><span class="cov8" title="1">{
                        service.Weight = 1
                }</span>
                <span class="cov8" title="1">if service.Namespace == "" </span><span class="cov8" title="1">{
                        service.Namespace = "default"
                }</span>
                <span class="cov8" title="1">if service.HealthCheck.Interval == 0 </span><span class="cov8" title="1">{
                        service.HealthCheck.Interval = 30 * time.Second
                }</span>
                <span class="cov8" title="1">if service.HealthCheck.Timeout == 0 </span><span class="cov8" title="1">{
                        service.HealthCheck.Timeout = 5 * time.Second
                }</span>

                <span class="cov8" title="1">services[service.Name] = service</span>
        }

        <span class="cov8" title="1">return &amp;WebSocketDiscovery{
                config:   cfg,
                logger:   logger.With(zap.String("discovery", "websocket")),
                services: services,
        }, nil</span>
}

// GetServices returns all discovered WebSocket services as endpoints
func (w *WebSocketDiscovery) GetServices(ctx context.Context) ([]Endpoint, error) <span class="cov8" title="1">{
        var endpoints []Endpoint

        for _, service := range w.services </span><span class="cov8" title="1">{
                // Create an endpoint for each configured endpoint URL
                for _, endpointURL := range service.Endpoints </span><span class="cov8" title="1">{
                        u, err := url.Parse(endpointURL)
                        if err != nil </span><span class="cov0" title="0">{
                                w.logger.Warn("invalid endpoint URL",
                                        zap.String("service", service.Name),
                                        zap.String("url", endpointURL),
                                        zap.Error(err))
                                continue</span>
                        }

                        // Determine port
                        <span class="cov8" title="1">port := 80
                        if u.Scheme == "wss" </span><span class="cov8" title="1">{
                                port = 443
                        }</span>
                        <span class="cov8" title="1">if u.Port() != "" </span><span class="cov8" title="1">{
                                if p, err := strconv.Atoi(u.Port()); err == nil </span><span class="cov8" title="1">{
                                        port = p
                                }</span>
                        }

                        <span class="cov8" title="1">endpoint := Endpoint{
                                Service:   service.Name,
                                Namespace: service.Namespace,
                                Address:   u.Hostname(),
                                Port:      port,
                                Scheme:    u.Scheme,
                                Path:      u.Path,
                                Weight:    service.Weight,
                                Metadata:  w.createMetadata(service, endpointURL),
                                Healthy:   true, // Assume healthy initially
                        }

                        // Perform basic connectivity check
                        if w.config.Services != nil </span><span class="cov8" title="1">{
                                if err := w.checkEndpointConnectivity(ctx, endpointURL, service); err != nil </span><span class="cov8" title="1">{
                                        w.logger.Warn("endpoint connectivity check failed",
                                                zap.String("service", service.Name),
                                                zap.String("endpoint", endpointURL),
                                                zap.Error(err))
                                        endpoint.Healthy = false
                                }</span>
                        }

                        <span class="cov8" title="1">endpoints = append(endpoints, endpoint)</span>
                }
        }

        <span class="cov8" title="1">w.logger.Debug("discovered WebSocket services", zap.Int("count", len(endpoints)))
        return endpoints, nil</span>
}

// GetService returns a specific service by name
func (w *WebSocketDiscovery) GetService(ctx context.Context, serviceName string) (*Endpoint, error) <span class="cov0" title="0">{
        service, exists := w.services[serviceName]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("service %s not found", serviceName)
        }</span>

        <span class="cov0" title="0">if len(service.Endpoints) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no endpoints configured for service %s", serviceName)
        }</span>

        // Return the first endpoint as primary
        <span class="cov0" title="0">endpointURL := service.Endpoints[0]
        u, err := url.Parse(endpointURL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid endpoint URL: %w", err)
        }</span>

        <span class="cov0" title="0">port := 80
        if u.Scheme == "wss" </span><span class="cov0" title="0">{
                port = 443
        }</span>
        <span class="cov0" title="0">if u.Port() != "" </span><span class="cov0" title="0">{
                if p, err := strconv.Atoi(u.Port()); err == nil </span><span class="cov0" title="0">{
                        port = p
                }</span>
        }

        <span class="cov0" title="0">endpoint := &amp;Endpoint{
                Service:   service.Name,
                Namespace: service.Namespace,
                Address:   u.Hostname(),
                Port:      port,
                Scheme:    u.Scheme,
                Path:      u.Path,
                Weight:    service.Weight,
                Metadata:  w.createMetadata(service, endpointURL),
                Healthy:   true,
        }

        // Check connectivity
        if err := w.checkEndpointConnectivity(ctx, endpointURL, service); err != nil </span><span class="cov0" title="0">{
                endpoint.Healthy = false
        }</span>

        <span class="cov0" title="0">return endpoint, nil</span>
}

// Watch monitors for changes in WebSocket service configuration
func (w *WebSocketDiscovery) Watch(ctx context.Context) (&lt;-chan []Endpoint, error) <span class="cov0" title="0">{
        ch := make(chan []Endpoint, 1)

        go func() </span><span class="cov0" title="0">{
                defer close(ch)

                ticker := time.NewTicker(30 * time.Second)
                defer ticker.Stop()

                // Send initial list
                if endpoints, err := w.GetServices(ctx); err == nil </span><span class="cov0" title="0">{
                        select </span>{
                        case ch &lt;- endpoints:<span class="cov0" title="0"></span>
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        }
                }

                // Periodically check and update
                <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        case &lt;-ticker.C:<span class="cov0" title="0">
                                if endpoints, err := w.GetServices(ctx); err == nil </span><span class="cov0" title="0">{
                                        select </span>{
                                        case ch &lt;- endpoints:<span class="cov0" title="0"></span>
                                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                                return</span>
                                        }
                                }
                        }
                }
        }()

        <span class="cov0" title="0">return ch, nil</span>
}

// HealthCheck performs a health check on a WebSocket service endpoint
func (w *WebSocketDiscovery) HealthCheck(ctx context.Context, endpoint *Endpoint) error <span class="cov0" title="0">{
        serviceName := endpoint.Service
        service, exists := w.services[serviceName]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("service %s not found for health check", serviceName)
        }</span>

        <span class="cov0" title="0">if !service.HealthCheck.Enabled </span><span class="cov0" title="0">{
                return nil // Health check disabled
        }</span>

        // Reconstruct the WebSocket URL
        <span class="cov0" title="0">scheme := endpoint.Scheme
        if scheme == "" </span><span class="cov0" title="0">{
                scheme = "ws"
        }</span>

        <span class="cov0" title="0">endpointURL := fmt.Sprintf("%s://%s:%d%s", scheme, endpoint.Address, endpoint.Port, endpoint.Path)

        return w.checkEndpointConnectivity(ctx, endpointURL, service)</span>
}

// checkEndpointConnectivity performs a basic connectivity check
func (w *WebSocketDiscovery) checkEndpointConnectivity(ctx context.Context, endpointURL string, service *config.WebSocketServiceConfig) error <span class="cov8" title="1">{
        // Create a context with timeout for the health check
        healthCtx, cancel := context.WithTimeout(ctx, service.HealthCheck.Timeout)
        defer cancel()

        // Create WebSocket dialer
        dialer := websocket.Dialer{
                HandshakeTimeout: 10 * time.Second,
        }

        // Set up headers
        headers := http.Header{}
        for k, v := range service.Headers </span><span class="cov8" title="1">{
                headers.Set(k, v)
        }</span>

        <span class="cov8" title="1">if service.Origin != "" </span><span class="cov8" title="1">{
                headers.Set("Origin", service.Origin)
        }</span>

        // Attempt to connect
        <span class="cov8" title="1">conn, _, err := dialer.DialContext(healthCtx, endpointURL, headers)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to connect to %s: %w", endpointURL, err)
        }</span>
        <span class="cov0" title="0">defer conn.Close()

        // Send a ping to verify the connection is working
        if err := conn.WriteControl(websocket.PingMessage, []byte{}, time.Now().Add(5*time.Second)); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to ping %s: %w", endpointURL, err)
        }</span>

        // The connection is working
        <span class="cov0" title="0">return nil</span>
}

// createMetadata creates metadata map with WebSocket-specific information
func (w *WebSocketDiscovery) createMetadata(service *config.WebSocketServiceConfig, endpointURL string) map[string]string <span class="cov8" title="1">{
        metadata := make(map[string]string)

        // Copy user-defined metadata
        for k, v := range service.Metadata </span><span class="cov8" title="1">{
                metadata[k] = v
        }</span>

        // Add WebSocket-specific metadata
        <span class="cov8" title="1">metadata["protocol"] = "websocket"
        metadata["endpoint_url"] = endpointURL
        metadata["health_check_enabled"] = strconv.FormatBool(service.HealthCheck.Enabled)
        metadata["tls_enabled"] = strconv.FormatBool(service.TLS.Enabled)

        if service.Origin != "" </span><span class="cov8" title="1">{
                metadata["origin"] = service.Origin
        }</span>

        // Add all endpoints as comma-separated list
        <span class="cov8" title="1">if len(service.Endpoints) &gt; 1 </span><span class="cov8" title="1">{
                metadata["all_endpoints"] = strings.Join(service.Endpoints, ",")
        }</span>

        // Add header information (excluding sensitive data)
        <span class="cov8" title="1">for k, v := range service.Headers </span><span class="cov8" title="1">{
                // Only include non-sensitive headers
                if !strings.Contains(strings.ToLower(k), "authorization") &amp;&amp;
                        !strings.Contains(strings.ToLower(k), "password") &amp;&amp;
                        !strings.Contains(strings.ToLower(k), "secret") &amp;&amp;
                        !strings.Contains(strings.ToLower(k), "token") &amp;&amp;
                        !strings.Contains(strings.ToLower(k), "key") </span><span class="cov8" title="1">{
                        metadata["header_"+strings.ToLower(k)] = v
                }</span>
        }

        <span class="cov8" title="1">return metadata</span>
}

// GetAllEndpoints returns all endpoints from all namespaces
func (w *WebSocketDiscovery) GetAllEndpoints() map[string][]Endpoint <span class="cov8" title="1">{
        endpoints, _ := w.GetServices(context.Background()) //nolint:errcheck // Service discovery - error handled by caller
        result := make(map[string][]Endpoint)
        for _, endpoint := range endpoints </span><span class="cov8" title="1">{
                result[endpoint.Namespace] = append(result[endpoint.Namespace], endpoint)
        }</span>
        <span class="cov8" title="1">return result</span>
}

// Start starts the discovery service
func (w *WebSocketDiscovery) Start(ctx context.Context) error <span class="cov8" title="1">{
        return nil
}</span>

// Stop stops the discovery service
func (w *WebSocketDiscovery) Stop() {<span class="cov8" title="1">
}</span>

// GetEndpoints returns endpoints for a specific namespace
func (w *WebSocketDiscovery) GetEndpoints(namespace string) []Endpoint <span class="cov8" title="1">{
        endpoints, _ := w.GetServices(context.Background()) //nolint:errcheck // Service discovery - error handled by caller
        var result []Endpoint
        for _, endpoint := range endpoints </span><span class="cov8" title="1">{
                if endpoint.Namespace == namespace </span><span class="cov8" title="1">{
                        result = append(result, endpoint)
                }</span>
        }
        <span class="cov8" title="1">return result</span>
}

// ListNamespaces returns all available namespaces
func (w *WebSocketDiscovery) ListNamespaces() []string <span class="cov8" title="1">{
        endpoints, _ := w.GetServices(context.Background()) //nolint:errcheck // Service discovery - error handled by caller
        namespaces := make(map[string]bool)
        for _, endpoint := range endpoints </span><span class="cov8" title="1">{
                namespaces[endpoint.Namespace] = true
        }</span>
        <span class="cov8" title="1">var result []string
        for namespace := range namespaces </span><span class="cov8" title="1">{
                result = append(result, namespace)
        }</span>
        <span class="cov8" title="1">return result</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
