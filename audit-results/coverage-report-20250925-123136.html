
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>secure: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/poiley/mcp-bridge/internal/secure/credential_other.go (100.0%)</option>
				
				<option value="file1">github.com/poiley/mcp-bridge/internal/secure/keychain_darwin.go (81.8%)</option>
				
				<option value="file2">github.com/poiley/mcp-bridge/internal/secure/secretservice_other.go (100.0%)</option>
				
				<option value="file3">github.com/poiley/mcp-bridge/internal/secure/token_store.go (72.0%)</option>
				
				<option value="file4">github.com/poiley/mcp-bridge/pkg/common/benchmark/benchmark.go (95.7%)</option>
				
				<option value="file5">github.com/poiley/mcp-bridge/pkg/common/config/types.go (100.0%)</option>
				
				<option value="file6">github.com/poiley/mcp-bridge/pkg/common/errors/codes.go (100.0%)</option>
				
				<option value="file7">github.com/poiley/mcp-bridge/pkg/common/errors/handler.go (88.2%)</option>
				
				<option value="file8">github.com/poiley/mcp-bridge/pkg/common/errors/interceptor.go (88.8%)</option>
				
				<option value="file9">github.com/poiley/mcp-bridge/pkg/common/errors/retry.go (94.7%)</option>
				
				<option value="file10">github.com/poiley/mcp-bridge/pkg/common/logging/correlation.go (95.2%)</option>
				
				<option value="file11">github.com/poiley/mcp-bridge/pkg/common/metrics/metrics.go (100.0%)</option>
				
				<option value="file12">github.com/poiley/mcp-bridge/pkg/common/optimization/pool.go (95.4%)</option>
				
				<option value="file13">github.com/poiley/mcp-bridge/pkg/common/slo/calculator.go (98.1%)</option>
				
				<option value="file14">github.com/poiley/mcp-bridge/pkg/common/tracing/websocket.go (87.1%)</option>
				
				<option value="file15">github.com/poiley/mcp-bridge/test/integration/docker_stack.go (38.2%)</option>
				
				<option value="file16">github.com/poiley/mcp-bridge/test/patterns/test_patterns.go (0.0%)</option>
				
				<option value="file17">github.com/poiley/mcp-bridge/test/testutil/e2e/helpers.go (0.0%)</option>
				
				<option value="file18">github.com/poiley/mcp-bridge/test/testutil/e2e/mcp_client.go (0.0%)</option>
				
				<option value="file19">github.com/poiley/mcp-bridge/test/testutil/e2e/router_controller.go (0.0%)</option>
				
				<option value="file20">github.com/poiley/mcp-bridge/test/testutil/helpers.go (0.0%)</option>
				
				<option value="file21">github.com/poiley/mcp-bridge/tools/redis-migrator/main.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">//go:build !windows
// +build !windows

// Package secure provides secure storage functionality for authentication tokens.
package secure

import "errors"

// newCredentialStore is not available on non-Windows platforms.
//
//nolint:ireturn // Platform-specific stub returns interface for consistency
func newCredentialStore(_ string) (TokenStore, error) <span class="cov10" title="21">{
        return nil, errors.New("credential store not available on this platform") 
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">//go:build darwin
// +build darwin

package secure

import (
        "context"
        "errors"
        "fmt"
        "os/exec"
        "regexp"
        "strings"
)

// keychainStore implements TokenStore using macOS Keychain.
type keychainStore struct {
        service string
}


//nolint:ireturn // Returns interface for consistency with other platform stores
func newKeychainStore(appName string) TokenStore <span class="cov3" title="40">{
        return &amp;keychainStore{
                service: fmt.Sprintf("com.%s.mcp-router", appName),
        }
}</span>

func (k *keychainStore) Store(key, token string) error <span class="cov3" title="34">{
        // Validate inputs to prevent command injection
        if !isValidKeychainParam(key) </span><span class="cov1" title="2">{
                return errors.New("invalid key parameter") 
        }</span>

        <span class="cov2" title="32">if !isValidKeychainParam(token) </span><span class="cov1" title="2">{
                return errors.New("invalid token parameter") 
        }</span>

        // First, try to delete existing entry (ignore error if key doesn't exist)
        
        <span class="cov2" title="30">_ = k.Delete(key)

        // Add new entry to keychain
        // #nosec G204 - inputs are validated above
        cmd := exec.CommandContext(context.Background(), "security", "add-generic-password",
                "-a", key,
                "-s", k.service,
                "-w", token,
                "-U") // Update if exists

        output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to store token in keychain: %w, output: %s", err, output)
        }</span>

        <span class="cov2" title="30">return nil</span>
}

func (k *keychainStore) Retrieve(key string) (string, error) <span class="cov3" title="43">{
        // Validate input to prevent command injection
        if !isValidKeychainParam(key) </span><span class="cov1" title="1">{
                return "", errors.New("invalid key parameter") 
        }</span>

        // #nosec G204 - input is validated above
        <span class="cov3" title="42">cmd := exec.CommandContext(context.Background(), "security", "find-generic-password",
                "-a", key,
                "-s", k.service,
                "-w") // Just output password

        output, err := cmd.Output()
        if err != nil </span><span class="cov2" title="14">{
                if strings.Contains(err.Error(), "could not be found") </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("token not found: %s", key) 
                }</span>

                <span class="cov2" title="14">return "", fmt.Errorf("failed to retrieve token from keychain: %w", err)</span>
        }

        // Remove trailing newline
        <span class="cov2" title="28">token := strings.TrimSpace(string(output))

        return token, nil</span>
}

func (k *keychainStore) Delete(key string) error <span class="cov3" title="61">{
        // Validate input to prevent command injection
        if !isValidKeychainParam(key) </span><span class="cov1" title="1">{
                return errors.New("invalid key parameter") 
        }</span>

        // #nosec G204 - input is validated above
        <span class="cov3" title="60">cmd := exec.CommandContext(context.Background(), "security", "delete-generic-password",
                "-a", key,
                "-s", k.service)

        output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov2" title="30">{
                // It's okay if the item doesn't exist
                if strings.Contains(string(output), "could not be found") </span><span class="cov2" title="30">{
                        return nil
                }</span>

                <span class="cov0" title="0">return fmt.Errorf("failed to delete token from keychain: %w, output: %s", err, output)</span>
        }

        <span class="cov2" title="30">return nil</span>
}

func (k *keychainStore) List() ([]string, error) <span class="cov2" title="14">{
        // List all entries for this service
        cmd := exec.CommandContext(context.Background(), "security", "dump-keychain")

        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list keychain entries: %w", err)
        }</span>

        // Parse the output to find entries for our service
        <span class="cov2" title="14">var keys []string

        lines := strings.Split(string(output), "\n")

        inOurService := false

        for _, line := range lines </span><span class="cov10" title="7592676">{
                if strings.Contains(line, fmt.Sprintf(`"svce"&lt;blob&gt;=%q`, k.service)) </span><span class="cov2" title="14">{
                        inOurService = true

                        continue</span>
                }

                <span class="cov9" title="7592662">if inOurService &amp;&amp; strings.Contains(line, `"acct"&lt;blob&gt;="`) </span><span class="cov0" title="0">{
                        // Extract account name
                        start := strings.Index(line, `"acct"&lt;blob&gt;="`) + len(`"acct"&lt;blob&gt;="`)
                        end := strings.Index(line[start:], `"`)

                        if end &gt; 0 </span><span class="cov0" title="0">{
                                key := line[start : start+end]
                                keys = append(keys, key)
                                inOurService = false
                        }</span>
                }

                // Reset if we hit another keychain entry
                <span class="cov9" title="7592662">if strings.HasPrefix(strings.TrimSpace(line), "keychain:") </span><span class="cov8" title="379596">{
                        inOurService = false
                }</span>
        }

        <span class="cov2" title="14">return keys, nil</span>
}

// isValidKeychainParam validates that a parameter is safe for use with the security command.
// It allows alphanumeric characters, hyphens, underscores, dots, and basic punctuation.
func isValidKeychainParam(param string) bool <span class="cov4" title="201">{
        if param == "" </span><span class="cov1" title="3">{
                return false
        }</span>
        // Allow alphanumeric, hyphens, underscores, dots, and some safe punctuation
        <span class="cov4" title="198">validPattern := regexp.MustCompile(`^[a-zA-Z0-9._@:-]+$`)

        return validPattern.MatchString(param)</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">//go:build !linux
// +build !linux

package secure

import "errors"

// newSecretServiceStore is not available on non-Linux platforms.
//
//nolint:ireturn // Platform-specific stub returns interface for consistency
func newSecretServiceStore(_ string) (TokenStore, error) <span class="cov10" title="2">{
        return nil, errors.New("secret service store not available on this platform") 
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">//nolint:ireturn // This file contains factory functions that must return interfaces
package secure

import (
        "crypto/aes"
        "crypto/cipher"
        "crypto/rand"
        "crypto/sha256"
        "encoding/base64"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "runtime"
        "sync"

        "golang.org/x/crypto/pbkdf2"
)

const (
        // File permissions for config directory.
        configDirPerm = 0o700
        // File permissions for token file.
        tokenFilePerm = 0o600
        // PBKDF2 iterations for key derivation.
        pbkdf2Iterations = 10000
        // Key length for AES encryption.
        keyLength = 32
        // Operating system identifiers.
        osLinux   = "linux"
        osDarwin  = "darwin"
        osWindows = "windows"
)

// TokenStore provides secure storage for authentication tokens.
type TokenStore interface {
        // Store saves a token securely
        Store(key, token string) error
        // Retrieve gets a token from secure storage
        Retrieve(key string) (string, error)
        // Delete removes a token from storage
        Delete(key string) error
        // List returns all stored token keys
        List() ([]string, error)
}

// NewTokenStore creates the appropriate token store for the current platform.
// Returns TokenStore interface because different platforms require different
// implementations (Keychain on macOS, Credential Store on Windows, etc.)
// This is a factory pattern where the interface return is necessary.
//
//nolint:ireturn // Factory must return interface for platform-specific implementations
func NewTokenStore(appName string) (TokenStore, error) <span class="cov6" title="34">{
        // Try platform-specific stores first
        switch runtime.GOOS </span>{
        case osDarwin:<span class="cov6" title="34">
                store := newKeychainStore(appName)

                return store, nil</span>
        case osWindows:<span class="cov0" title="0">
                store, err := newCredentialStore(appName)
                if err == nil </span><span class="cov0" title="0">{
                        return store, nil
                }</span>
        case osLinux:<span class="cov0" title="0">
                store, err := newSecretServiceStore(appName)
                if err == nil </span><span class="cov0" title="0">{
                        return store, nil
                }</span>
        }

        // Fall back to encrypted file storage
        <span class="cov0" title="0">return newEncryptedFileStore(appName)</span>
}

// encryptedFileStore provides file-based encrypted token storage as a fallback.
type encryptedFileStore struct {
        appName  string
        filePath string
        password []byte
        mu       sync.Mutex
}

//nolint:ireturn // Factory function must return interface for platform-specific implementations
func newEncryptedFileStore(appName string) (TokenStore, error) <span class="cov7" title="44">{
        homeDir, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get home directory: %w", err)
        }</span>

        <span class="cov7" title="44">configDir := filepath.Join(homeDir, ".config", appName)
        if err := os.MkdirAll(configDir, configDirPerm); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create config directory: %w", err)
        }</span>

        // Generate a deterministic password based on app name and machine ID
        <span class="cov7" title="44">password := generatePassword(appName)

        return &amp;encryptedFileStore{
                appName:  appName,
                filePath: filepath.Join(configDir, "tokens.enc"),
                password: password,
                mu:       sync.Mutex{}, // Zero value mutex for concurrent access protection
        }, nil</span>
}

func generatePassword(appName string) []byte <span class="cov8" title="101">{
        // Use machine-specific data to generate a deterministic password
        hostname, err := os.Hostname()
        if err != nil </span><span class="cov0" title="0">{
                hostname = "unknown"
        }</span>

        <span class="cov8" title="101">username := os.Getenv("USER")
        if username == "" </span><span class="cov0" title="0">{
                username = os.Getenv("USERNAME")
        }</span>

        <span class="cov8" title="101">salt := fmt.Sprintf("%s-%s-%s", appName, hostname, username)

        return pbkdf2.Key([]byte(salt), []byte(appName), pbkdf2Iterations, keyLength, sha256.New)</span>
}

type tokenData struct {
        Tokens map[string]string `json:"tokens"`
}

func (s *encryptedFileStore) encrypt(plaintext []byte) ([]byte, error) <span class="cov9" title="129">{
        block, err := aes.NewCipher(s.password)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err 
        }</span>

        <span class="cov9" title="129">gcm, err := cipher.NewGCM(block)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err 
        }</span>

        <span class="cov9" title="129">nonce := make([]byte, gcm.NonceSize())
        if _, err := io.ReadFull(rand.Reader, nonce); err != nil </span><span class="cov0" title="0">{
                return nil, err 
        }</span>

        <span class="cov9" title="129">return gcm.Seal(nonce, nonce, plaintext, nil), nil</span>
}

func (s *encryptedFileStore) decrypt(ciphertext []byte) ([]byte, error) <span class="cov10" title="204">{
        block, err := aes.NewCipher(s.password)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err 
        }</span>

        <span class="cov10" title="204">gcm, err := cipher.NewGCM(block)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err 
        }</span>

        <span class="cov10" title="204">nonceSize := gcm.NonceSize()
        if len(ciphertext) &lt; nonceSize </span><span class="cov3" title="4">{
                return nil, errors.New("ciphertext too short") 
        }</span>

        <span class="cov9" title="200">nonce, ciphertext := ciphertext[:nonceSize], ciphertext[nonceSize:]

        return gcm.Open(nil, nonce, ciphertext, nil)</span> 
}

func (s *encryptedFileStore) load() (*tokenData, error) <span class="cov9" title="178">{
        s.mu.Lock()
        defer s.mu.Unlock()

        data, err := os.ReadFile(s.filePath)
        if err != nil </span><span class="cov4" title="9">{
                if os.IsNotExist(err) </span><span class="cov4" title="9">{
                        return &amp;tokenData{Tokens: make(map[string]string)}, nil
                }</span>

                <span class="cov0" title="0">return nil, err</span> 
        }

        <span class="cov9" title="169">decrypted, err := s.decrypt(data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decrypt tokens: %w", err)
        }</span>

        <span class="cov9" title="169">var tokenData tokenData
        if err := json.Unmarshal(decrypted, &amp;tokenData); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal tokens: %w", err)
        }</span>

        <span class="cov9" title="169">if tokenData.Tokens == nil </span><span class="cov0" title="0">{
                tokenData.Tokens = make(map[string]string)
        }</span>

        <span class="cov9" title="169">return &amp;tokenData, nil</span>
}

func (s *encryptedFileStore) save(td *tokenData) error <span class="cov8" title="101">{
        data, err := json.Marshal(td)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal tokens: %w", err)
        }</span>

        <span class="cov8" title="101">encrypted, err := s.encrypt(data)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to encrypt tokens: %w", err)
        }</span>

        // Write to temporary file first
        <span class="cov8" title="101">tmpFile := s.filePath + ".tmp"
        if err := os.WriteFile(tmpFile, encrypted, tokenFilePerm); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write encrypted tokens: %w", err)
        }</span>

        // Atomic rename
        <span class="cov8" title="101">return os.Rename(tmpFile, s.filePath)</span> 
}

func (s *encryptedFileStore) Store(key, token string) error <span class="cov7" title="55">{
        tokenData, err := s.load()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="55">tokenData.Tokens[key] = base64.StdEncoding.EncodeToString([]byte(token))

        return s.save(tokenData)</span>
}

func (s *encryptedFileStore) Retrieve(key string) (string, error) <span class="cov7" title="60">{
        tokenData, err := s.load()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov7" title="60">encoded, ok := tokenData.Tokens[key]
        if !ok </span><span class="cov5" title="18">{
                return "", fmt.Errorf("token not found: %s", key) 
        }</span>

        <span class="cov7" title="42">decoded, err := base64.StdEncoding.DecodeString(encoded)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to decode token: %w", err)
        }</span>

        <span class="cov7" title="42">return string(decoded), nil</span>
}

func (s *encryptedFileStore) Delete(key string) error <span class="cov7" title="40">{
        tokenData, err := s.load()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="40">delete(tokenData.Tokens, key)

        return s.save(tokenData)</span>
}

func (s *encryptedFileStore) List() ([]string, error) <span class="cov5" title="14">{
        tokenData, err := s.load()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov5" title="14">keys := make([]string, 0, len(tokenData.Tokens))
        for k := range tokenData.Tokens </span><span class="cov6" title="20">{
                keys = append(keys, k)
        }</span>

        <span class="cov5" title="14">return keys, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Package benchmark provides common benchmarking utilities
package benchmark

import (
        "context"
        "fmt"
        "strings"
        "sync"
        "sync/atomic"
        "time"

        "go.uber.org/zap"
)

const (
        // resultChannelMultiplier determines channel buffer size relative to concurrency.
        resultChannelMultiplier = 100
        // warmupWorkerDivisor for calculating warmup workers from concurrency.
        warmupWorkerDivisor = 10
        // maxWarmupWorkers limits the number of warmup workers.
        maxWarmupWorkers = 10
        // warmupSleepMilliseconds between warmup operations.
        warmupSleepMilliseconds = 100
        // percentageMultiplier for percentage calculations.
        percentageMultiplier = 100
        // bytesToMBDivisor for converting bytes to megabytes.
        bytesToMBDivisor = 1024
)

// Config defines benchmark configuration.
type Config struct {
        Name         string
        Duration     time.Duration
        Concurrency  int
        RPS          int // Requests per second (0 = unlimited)
        WarmupTime   time.Duration
        CooldownTime time.Duration
}

// Result contains benchmark results.
type Result struct {
        Name          string
        Duration      time.Duration
        TotalRequests int64
        SuccessCount  int64
        ErrorCount    int64

        // Latency metrics (in nanoseconds)
        MinLatency int64
        MaxLatency int64
        AvgLatency int64
        P50Latency int64
        P95Latency int64
        P99Latency int64

        // Throughput metrics
        RequestsPerSec float64
        BytesPerSec    float64

        // Resource metrics
        AvgCPU      float64
        MaxMemoryMB int64

        // Error details
        ErrorTypes map[string]int64
}

// RequestResult represents a single request result.
type RequestResult struct {
        Success   bool
        Latency   time.Duration
        BytesRead int64
        Error     error
        Timestamp time.Time
}

// WorkerFunc is the function that performs the actual work being benchmarked.
type WorkerFunc func(ctx context.Context) *RequestResult

// Runner executes benchmarks.
type Runner struct {
        config Config
        worker WorkerFunc
        logger *zap.Logger

        // Metrics collection
        results   chan *RequestResult
        errors    map[string]*int64
        latencies []int64

        // Control
        ctx       context.Context 
        cancel    context.CancelFunc
        waitGroup sync.WaitGroup
}

// NewRunner creates a new benchmark runner.
func NewRunner(config Config, worker WorkerFunc, logger *zap.Logger) *Runner <span class="cov5" title="10">{
        ctx, cancel := context.WithCancel(context.Background())

        return &amp;Runner{
                config:    config,
                worker:    worker,
                logger:    logger,
                results:   make(chan *RequestResult, config.Concurrency*resultChannelMultiplier),
                errors:    make(map[string]*int64),
                latencies: make([]int64, 0, defaultLatencySliceCapacity),
                ctx:       ctx,
                cancel:    cancel,
                waitGroup: sync.WaitGroup{}, // Zero value WaitGroup for goroutine synchronization
        }
}</span>

// Run executes the benchmark.
func (r *Runner) Run() (*Result, error) <span class="cov4" title="9">{
        r.logger.Info("Starting benchmark",
                zap.String("name", r.config.Name),
                zap.Duration("duration", r.config.Duration),
                zap.Int("concurrency", r.config.Concurrency),
                zap.Int("target_rps", r.config.RPS))

        // Warmup phase
        if r.config.WarmupTime &gt; 0 </span><span class="cov1" title="1">{
                r.logger.Info("Starting warmup phase", zap.Duration("warmup_time", r.config.WarmupTime))
                r.runWarmup()
        }</span>

        // Reset metrics after warmup
        <span class="cov4" title="9">r.results = make(chan *RequestResult, r.config.Concurrency*resultChannelMultiplier)

        // Start result collector
        resultsDone := make(chan struct{})

        go func() </span><span class="cov4" title="9">{
                r.collectResults()
                close(resultsDone)
        }</span>()

        // Run benchmark
        <span class="cov4" title="9">startTime := time.Now()

        benchCtx, benchCancel := context.WithTimeout(r.ctx, r.config.Duration)
        defer benchCancel()

        // Start workers
        for range r.config.Concurrency </span><span class="cov5" title="11">{
                r.waitGroup.Add(1)

                if r.config.RPS &gt; 0 </span><span class="cov2" title="2">{
                        // Rate-limited worker
                        go r.runRateLimitedWorker(benchCtx, r.config.RPS/r.config.Concurrency)
                }</span> else<span class="cov4" title="9"> {
                        // Unlimited worker
                        go r.runWorker(benchCtx)
                }</span>
        }

        // Wait for workers to complete
        <span class="cov4" title="9">r.waitGroup.Wait()
        close(r.results)

        // Wait for results collection to complete
        &lt;-resultsDone

        duration := time.Since(startTime)

        // Cooldown phase
        if r.config.CooldownTime &gt; 0 </span><span class="cov1" title="1">{
                r.logger.Info("Starting cooldown phase", zap.Duration("cooldown_time", r.config.CooldownTime))
                time.Sleep(r.config.CooldownTime)
        }</span>

        // Calculate and return results
        <span class="cov4" title="9">return r.calculateResults(duration), nil</span>
}

// Stop gracefully stops the benchmark.
func (r *Runner) Stop() <span class="cov1" title="1">{
        r.cancel()
        r.waitGroup.Wait()
}</span>

func (r *Runner) runWarmup() <span class="cov1" title="1">{
        warmupCtx, cancel := context.WithTimeout(r.ctx, r.config.WarmupTime)
        defer cancel()

        // Run a few workers for warmup
        warmupWorkers := minInt(r.config.Concurrency/warmupWorkerDivisor+1, maxWarmupWorkers)

        var waitGroup sync.WaitGroup

        for range warmupWorkers </span><span class="cov1" title="1">{
                waitGroup.Add(1)

                go func() </span><span class="cov1" title="1">{
                        defer waitGroup.Done()

                        for </span><span class="cov2" title="2">{
                                select </span>{
                                case &lt;-warmupCtx.Done():<span class="cov1" title="1">
                                        return</span>
                                default:<span class="cov1" title="1">
                                        r.worker(warmupCtx)
                                        time.Sleep(warmupSleepMilliseconds * time.Millisecond)</span>
                                }
                        }
                }()
        }

        <span class="cov1" title="1">waitGroup.Wait()</span>
}

func (r *Runner) runWorker(ctx context.Context) <span class="cov4" title="9">{
        defer r.waitGroup.Done()

        for </span><span class="cov8" title="79">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov3" title="5">
                        return</span>
                default:<span class="cov8" title="74">
                        result := r.worker(ctx)
                        select </span>{
                        case r.results &lt;- result:<span class="cov8" title="70"></span>
                        case &lt;-ctx.Done():<span class="cov3" title="4">
                                return</span>
                        }
                }
        }
}

func (r *Runner) runRateLimitedWorker(ctx context.Context, rps int) <span class="cov2" title="2">{
        defer r.waitGroup.Done()

        if rps &lt;= 0 </span><span class="cov0" title="0">{
                r.runWorker(ctx)

                return
        }</span>

        <span class="cov2" title="2">ticker := time.NewTicker(time.Second / time.Duration(rps))
        defer ticker.Stop()

        for </span><span class="cov8" title="92">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov2" title="2">
                        return</span>
                case &lt;-ticker.C:<span class="cov8" title="90">
                        result := r.worker(ctx)
                        select </span>{
                        case r.results &lt;- result:<span class="cov8" title="90"></span>
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        }
                }
        }
}

func (r *Runner) collectResults() <span class="cov4" title="9">{
        for result := range r.results </span><span class="cov9" title="160">{
                if result.Success </span><span class="cov9" title="118">{
                        atomic.AddInt64(&amp;successCount, 1)
                }</span> else<span class="cov7" title="42"> {
                        atomic.AddInt64(&amp;errorCount, 1)

                        if result.Error != nil </span><span class="cov7" title="42">{
                                r.recordError(result.Error.Error())
                        }</span>
                }

                // Store latency for percentile calculation
                <span class="cov9" title="160">r.latencies = append(r.latencies, result.Latency.Nanoseconds())

                atomic.AddInt64(&amp;totalRequests, 1)
                atomic.AddInt64(&amp;totalBytes, result.BytesRead)

                // Update min/max latency
                latencyNs := result.Latency.Nanoseconds()
                updateMinMax(&amp;minLatency, &amp;maxLatency, latencyNs)</span>
        }
}

func (r *Runner) recordError(errStr string) <span class="cov7" title="42">{
        if _, exists := r.errors[errStr]; !exists </span><span class="cov4" title="7">{
                var count int64

                r.errors[errStr] = &amp;count
        }</span>

        <span class="cov7" title="42">atomic.AddInt64(r.errors[errStr], 1)</span>
}

func (r *Runner) calculateResults(duration time.Duration) *Result <span class="cov4" title="9">{
        result := &amp;Result{
                Name:           r.config.Name,
                Duration:       duration,
                TotalRequests:  atomic.LoadInt64(&amp;totalRequests),
                SuccessCount:   atomic.LoadInt64(&amp;successCount),
                ErrorCount:     atomic.LoadInt64(&amp;errorCount),
                MinLatency:     atomic.LoadInt64(&amp;minLatency),
                MaxLatency:     atomic.LoadInt64(&amp;maxLatency),
                AvgLatency:     0, // Will be calculated below
                P50Latency:     0, // Will be calculated below
                P95Latency:     0, // Will be calculated below
                P99Latency:     0, // Will be calculated below
                RequestsPerSec: 0, // Will be calculated below
                BytesPerSec:    0, // Will be calculated below
                AvgCPU:         0, // Will be calculated below
                MaxMemoryMB:    0, // Will be calculated below
                ErrorTypes:     make(map[string]int64),
        }

        // Calculate throughput
        if duration &gt; 0 </span><span class="cov4" title="9">{
                result.RequestsPerSec = float64(result.TotalRequests) / duration.Seconds()
                result.BytesPerSec = float64(atomic.LoadInt64(&amp;totalBytes)) / duration.Seconds()
        }</span>

        // Calculate latency percentiles
        <span class="cov4" title="9">if len(r.latencies) &gt; 0 </span><span class="cov4" title="7">{
                result.AvgLatency = calculateAverage(r.latencies)
                result.P50Latency = calculatePercentile(r.latencies, p50Percentile)
                result.P95Latency = calculatePercentile(r.latencies, p95Percentile)
                result.P99Latency = calculatePercentile(r.latencies, p99Percentile)
        }</span>

        // Copy error counts
        <span class="cov4" title="9">for errStr, count := range r.errors </span><span class="cov4" title="7">{
                result.ErrorTypes[errStr] = atomic.LoadInt64(count)
        }</span>

        <span class="cov4" title="9">return result</span>
}

// Global metrics (using atomics for thread safety).
var (
        totalRequests int64
        successCount  int64
        errorCount    int64
        totalBytes    int64
        minLatency    int64 = 1&lt;&lt;63 - 1
        maxLatency    int64
)

const (
        // defaultLatencySliceCapacity is the default capacity for storing latency measurements.
        defaultLatencySliceCapacity = 1000000
        // p50Percentile is the 50th percentile.
        p50Percentile = 50
        // p95Percentile is the 95th percentile.
        p95Percentile = 95
        // p99Percentile is the 99th percentile.
        p99Percentile = 99
        // percentToFraction converts percentile to fraction.
        percentToFraction = 100.0
)

// Helper functions.
func minInt(a, b int) int <span class="cov2" title="3">{
        if a &lt; b </span><span class="cov2" title="2">{
                return a
        }</span>

        <span class="cov1" title="1">return b</span>
}

func updateMinMax(minVal, maxVal *int64, value int64) <span class="cov9" title="160">{
        for </span><span class="cov9" title="160">{
                oldMin := atomic.LoadInt64(minVal)
                if value &gt;= oldMin </span><span class="cov9" title="158">{
                        break</span>
                }

                <span class="cov2" title="2">if atomic.CompareAndSwapInt64(minVal, oldMin, value) </span><span class="cov2" title="2">{
                        break</span>
                }
        }

        <span class="cov9" title="160">for </span><span class="cov9" title="160">{
                oldMax := atomic.LoadInt64(maxVal)
                if value &lt;= oldMax </span><span class="cov9" title="159">{
                        break</span>
                }

                <span class="cov1" title="1">if atomic.CompareAndSwapInt64(maxVal, oldMax, value) </span><span class="cov1" title="1">{
                        break</span>
                }
        }
}

func calculateAverage(values []int64) int64 <span class="cov4" title="8">{
        if len(values) == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov4" title="8">var sum int64
        for _, v := range values </span><span class="cov10" title="165">{
                sum += v
        }</span>

        <span class="cov4" title="8">return sum / int64(len(values))</span>
}

func calculatePercentile(values []int64, percentile float64) int64 <span class="cov6" title="23">{
        if len(values) == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        // Note: This is a simple implementation. For production use,
        // consider using a more efficient algorithm like t-digest
        <span class="cov6" title="23">index := int(float64(len(values)) * percentile / percentToFraction)
        if index &gt;= len(values) </span><span class="cov0" title="0">{
                index = len(values) - 1
        }</span>

        <span class="cov6" title="23">return values[index]</span>
}

// Format returns a formatted string representation of the results.
func (r *Result) Format() string <span class="cov2" title="2">{
        var builder strings.Builder

        builder.WriteString(fmt.Sprintf("Benchmark: %s\n", r.Name))
        builder.WriteString(fmt.Sprintf("Duration: %v\n", r.Duration))
        builder.WriteString(fmt.Sprintf("Total Requests: %d\n", r.TotalRequests))
        builder.WriteString(fmt.Sprintf("Success: %d (%.2f%%)\n",
                r.SuccessCount, float64(r.SuccessCount)/float64(r.TotalRequests)*percentageMultiplier))
        builder.WriteString(fmt.Sprintf("Errors: %d (%.2f%%)\n",
                r.ErrorCount, float64(r.ErrorCount)/float64(r.TotalRequests)*percentageMultiplier))
        builder.WriteString("\n")

        builder.WriteString("Latency:\n")
        builder.WriteString(fmt.Sprintf("  Min: %v\n", time.Duration(r.MinLatency)))
        builder.WriteString(fmt.Sprintf("  Avg: %v\n", time.Duration(r.AvgLatency)))
        builder.WriteString(fmt.Sprintf("  P50: %v\n", time.Duration(r.P50Latency)))
        builder.WriteString(fmt.Sprintf("  P95: %v\n", time.Duration(r.P95Latency)))
        builder.WriteString(fmt.Sprintf("  P99: %v\n", time.Duration(r.P99Latency)))
        builder.WriteString(fmt.Sprintf("  Max: %v\n", time.Duration(r.MaxLatency)))
        builder.WriteString("\n")

        builder.WriteString("Throughput:\n")
        builder.WriteString(fmt.Sprintf("  Requests/sec: %.2f\n", r.RequestsPerSec))
        builder.WriteString(fmt.Sprintf("  Bytes/sec: %.2f MB\n", r.BytesPerSec/bytesToMBDivisor/bytesToMBDivisor))

        if len(r.ErrorTypes) &gt; 0 </span><span class="cov2" title="2">{
                builder.WriteString("\nError Types:\n")

                for errType, count := range r.ErrorTypes </span><span class="cov2" title="3">{
                        builder.WriteString(fmt.Sprintf("  %s: %d\n", errType, count))
                }</span>
        }

        <span class="cov2" title="2">return builder.String()</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Package config provides configuration types and utilities for the MCP bridge.
package config

import "time"

// TLSConfig represents standardized TLS configuration across all components.
type TLSConfig struct {
        Enabled      bool     `mapstructure:"enabled"`
        Verify       bool     `mapstructure:"verify"`        // For client-side verification
        CertFile     string   `mapstructure:"cert_file"`     // Server cert
        KeyFile      string   `mapstructure:"key_file"`      // Server key
        CAFile       string   `mapstructure:"ca_file"`       // CA cert for verification
        ClientCert   string   `mapstructure:"client_cert"`   // Client cert for mTLS
        ClientKey    string   `mapstructure:"client_key"`    // Client key for mTLS
        ClientAuth   string   `mapstructure:"client_auth"`   // Options: "none", "request", "require"
        MinVersion   string   `mapstructure:"min_version"`   // Options: "1.2", "1.3"
        CipherSuites []string `mapstructure:"cipher_suites"` // Optional: specific cipher suites
        CACertPath   string   `mapstructure:"ca_cert_path"`  // CA certificate path
}

// AuthConfig represents standardized authentication configuration.
type AuthConfig struct {
        Type            string   `mapstructure:"type"` // "bearer", "oauth2", "mtls"
        Token           string   `mapstructure:"-"`    // Not from config file
        TokenEnv        string   `mapstructure:"token_env"`
        TokenFile       string   `mapstructure:"token_file"`
        TokenSecureKey  string   `mapstructure:"token_secure_key"`
        ClientID        string   `mapstructure:"client_id"`
        ClientSecret    string   `mapstructure:"-"` // Not from config file
        ClientSecretEnv string   `mapstructure:"client_secret_env"`
        ClientSecretKey string   `mapstructure:"client_secret_secure_key"`
        TokenEndpoint   string   `mapstructure:"token_endpoint"`
        Scopes          []string `mapstructure:"scopes"`
        Scope           string   `mapstructure:"scope"`
        GrantType       string   `mapstructure:"grant_type"`
        Username        string   `mapstructure:"username"`
        Password        string   `mapstructure:"-"` // Not from config file
        PasswordEnv     string   `mapstructure:"password_env"`
        PasswordKey     string   `mapstructure:"password_secure_key"`
        ClientCert      string   `mapstructure:"client_cert"`
        ClientKey       string   `mapstructure:"client_key"`
        PerMessageAuth  bool     `mapstructure:"per_message_auth"`
        PerMessageCache int      `mapstructure:"per_message_cache"` // Cache duration in seconds
}

// ConnectionConfig represents standardized connection configuration.
type ConnectionConfig struct {
        TimeoutMs           int             `mapstructure:"timeout_ms"`
        KeepaliveIntervalMs int             `mapstructure:"keepalive_interval_ms"`
        MaxConnections      int             `mapstructure:"max_connections"`
        MaxConnectionsPerIP int             `mapstructure:"max_connections_per_ip"`
        BufferSize          int             `mapstructure:"buffer_size"`
        Reconnect           ReconnectConfig `mapstructure:"reconnect"`
}

// ReconnectConfig represents standardized reconnect configuration.
type ReconnectConfig struct {
        InitialDelayMs int     `mapstructure:"initial_delay_ms"`
        MaxDelayMs     int     `mapstructure:"max_delay_ms"`
        Multiplier     float64 `mapstructure:"multiplier"`
        MaxAttempts    int     `mapstructure:"max_attempts"`
        Jitter         float64 `mapstructure:"jitter"`
}

// RateLimitConfig represents standardized rate limiting configuration.
type RateLimitConfig struct {
        Enabled        bool    `mapstructure:"enabled"`
        Provider       string  `mapstructure:"provider"` // "memory", "redis"
        RequestsPerSec float64 `mapstructure:"requests_per_sec"`
        Burst          int     `mapstructure:"burst"`
        WindowSize     int     `mapstructure:"window_size"` // Window size in seconds
}

// CircuitBreakerConfig represents standardized circuit breaker configuration.
type CircuitBreakerConfig struct {
        FailureThreshold int     `mapstructure:"failure_threshold"`
        SuccessThreshold int     `mapstructure:"success_threshold"`
        TimeoutSeconds   int     `mapstructure:"timeout_seconds"`
        MaxRequests      int     `mapstructure:"max_requests"`
        IntervalSeconds  int     `mapstructure:"interval_seconds"`
        SuccessRatio     float64 `mapstructure:"success_ratio"`
}

// MetricsConfig represents standardized metrics configuration.
type MetricsConfig struct {
        Enabled  bool              `mapstructure:"enabled"`
        Endpoint string            `mapstructure:"endpoint"` // Host:port for metrics endpoint
        Path     string            `mapstructure:"path"`     // URL path for metrics (default: /metrics)
        Labels   map[string]string `mapstructure:"labels"`   // Additional labels
}

// LoggingConfig represents standardized logging configuration.
type LoggingConfig struct {
        Level         string         `mapstructure:"level"`  // debug, info, warn, error
        Format        string         `mapstructure:"format"` // json, text
        Output        string         `mapstructure:"output"` // stdout, stderr, file path
        IncludeCaller bool           `mapstructure:"include_caller"`
        Sampling      SamplingConfig `mapstructure:"sampling"`
}

// SamplingConfig represents standardized log sampling configuration.
type SamplingConfig struct {
        Enabled    bool `mapstructure:"enabled"`
        Initial    int  `mapstructure:"initial"`
        Thereafter int  `mapstructure:"thereafter"`
}

// GetTimeout returns the timeout duration for the connection.
func (c *ConnectionConfig) GetTimeout() time.Duration <span class="cov10" title="5">{
        return time.Duration(c.TimeoutMs) * time.Millisecond
}</span>

// GetKeepaliveInterval returns the keepalive interval for the connection.
func (c *ConnectionConfig) GetKeepaliveInterval() time.Duration <span class="cov10" title="5">{
        return time.Duration(c.KeepaliveIntervalMs) * time.Millisecond
}</span>

// GetTimeout returns the timeout duration for the circuit breaker.
func (c *CircuitBreakerConfig) GetTimeout() time.Duration <span class="cov10" title="5">{
        return time.Duration(c.TimeoutSeconds) * time.Second
}</span>

// GetInterval returns the reset interval for the circuit breaker.
func (c *CircuitBreakerConfig) GetInterval() time.Duration <span class="cov10" title="5">{
        return time.Duration(c.IntervalSeconds) * time.Second
}</span>

// TracingConfig represents standardized distributed tracing configuration.
type TracingConfig struct {
        Enabled        bool    `mapstructure:"enabled"`
        ServiceName    string  `mapstructure:"service_name"`
        ServiceVersion string  `mapstructure:"service_version"`
        Environment    string  `mapstructure:"environment"`
        SamplerType    string  `mapstructure:"sampler_type"`  // "always_on", "always_off", "traceidratio"
        SamplerParam   float64 `mapstructure:"sampler_param"` // For traceidratio sampler
        ExporterType   string  `mapstructure:"exporter_type"` // "otlp", "stdout"
        OTLPEndpoint   string  `mapstructure:"otlp_endpoint"`
        OTLPInsecure   bool    `mapstructure:"otlp_insecure"`
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Package errors provides standardized error handling for the MCP Bridge system.
package errors

import (
        "errors"
        "fmt"
        "net/http"
)

// Retry timeout constants (in seconds).
const (
        // ShortRetryTimeout for quick recovery scenarios.
        ShortRetryTimeout = 5
        // StandardRetryTimeout for normal error recovery.
        StandardRetryTimeout = 10
        // MediumRetryTimeout for rate limiting scenarios.
        MediumRetryTimeout = 30
        // LongRetryTimeout for heavy rate limiting.
        LongRetryTimeout = 60
        // ExtendedRetryTimeout for quota limits.
        ExtendedRetryTimeout = 300
        // MaxRetryTimeout for daily quota limits.
        MaxRetryTimeout = 3600
)

// ErrorCode represents a unique error code for the MCP Bridge system.
type ErrorCode string

// Categories: AUTH, CONN, PROTO, VAL, INT, RATE, SEC.
//

const (
        // Common errors (CMN_XXX_XXX) - 1000-1999.
        CMN_INT_UNKNOWN      ErrorCode = "CMN_INT_001" // Unknown internal error
        CMN_INT_PANIC        ErrorCode = "CMN_INT_002" // Panic recovery
        CMN_INT_TIMEOUT      ErrorCode = "CMN_INT_003" // Operation timeout
        CMN_INT_CONTEXT_CANC ErrorCode = "CMN_INT_004" // Context canceled
        CMN_INT_NOT_IMPL     ErrorCode = "CMN_INT_005" // Feature not implemented

        // Validation errors.

        CMN_VAL_INVALID_REQ ErrorCode = "CMN_VAL_001" // Invalid request format

        CMN_VAL_MISSING_FLD ErrorCode = "CMN_VAL_002" // Required field missing

        CMN_VAL_INVALID_TYPE ErrorCode = "CMN_VAL_003" // Invalid field type

        CMN_VAL_OUT_OF_RANGE ErrorCode = "CMN_VAL_004" // Value out of acceptable range

        CMN_VAL_PATTERN_FAIL ErrorCode = "CMN_VAL_005" // Pattern validation failed

        // Protocol errors.

        CMN_PROTO_INVALID_VER ErrorCode = "CMN_PROTO_001" // Invalid protocol version

        CMN_PROTO_PARSE_ERR ErrorCode = "CMN_PROTO_002" // Protocol parsing error

        CMN_PROTO_MARSHAL_ERR ErrorCode = "CMN_PROTO_003" // Protocol marshaling error

        CMN_PROTO_METHOD_UNK ErrorCode = "CMN_PROTO_004" // Unknown method

        CMN_PROTO_BATCH_ERR ErrorCode = "CMN_PROTO_005" // Batch request error

        // Authentication errors.
        GTW_AUTH_MISSING      ErrorCode = "GTW_AUTH_001" // Missing authentication
        GTW_AUTH_INVALID      ErrorCode = "GTW_AUTH_002" // Invalid credentials
        GTW_AUTH_EXPIRED      ErrorCode = "GTW_AUTH_003" // Expired token
        GTW_AUTH_INSUFFICIENT ErrorCode = "GTW_AUTH_004" // Insufficient permissions
        GTW_AUTH_REVOKED      ErrorCode = "GTW_AUTH_005" // Revoked credentials
        GTW_AUTH_METHOD_UNK   ErrorCode = "GTW_AUTH_006" // Unknown auth method
        GTW_AUTH_CERT_FAIL    ErrorCode = "GTW_AUTH_007" // Certificate validation failed
        GTW_AUTH_OAUTH_FAIL   ErrorCode = "GTW_AUTH_008" // OAuth2 flow failed

        // Connection errors.
        GTW_CONN_REFUSED      ErrorCode = "GTW_CONN_001" // Connection refused
        GTW_CONN_TIMEOUT      ErrorCode = "GTW_CONN_002" // Connection timeout
        GTW_CONN_CLOSED       ErrorCode = "GTW_CONN_003" // Connection closed
        GTW_CONN_LIMIT        ErrorCode = "GTW_CONN_004" // Connection limit reached
        GTW_CONN_TLS_FAIL     ErrorCode = "GTW_CONN_005" // TLS handshake failed
        GTW_CONN_UPGRADE_FAIL ErrorCode = "GTW_CONN_006" // WebSocket upgrade failed

        // Rate limiting errors.
        GTW_RATE_LIMIT_REQ   ErrorCode = "GTW_RATE_001" // Request rate limit exceeded
        GTW_RATE_LIMIT_CONN  ErrorCode = "GTW_RATE_002" // Connection rate limit exceeded
        GTW_RATE_LIMIT_BURST ErrorCode = "GTW_RATE_003" // Burst limit exceeded
        GTW_RATE_LIMIT_QUOTA ErrorCode = "GTW_RATE_004" // Quota exceeded

        // Security errors.
        GTW_SEC_BLOCKED_IP ErrorCode = "GTW_SEC_001" // IP address blocked
        GTW_SEC_BLOCKED_UA ErrorCode = "GTW_SEC_002" // User agent blocked
        GTW_SEC_MALICIOUS  ErrorCode = "GTW_SEC_003" // Malicious request detected
        GTW_SEC_CSRF_FAIL  ErrorCode = "GTW_SEC_004" // CSRF validation failed

        // Connection errors.
        RTR_CONN_NO_BACKEND   ErrorCode = "RTR_CONN_001" // No backend available
        RTR_CONN_BACKEND_ERR  ErrorCode = "RTR_CONN_002" // Backend connection error
        RTR_CONN_POOL_FULL    ErrorCode = "RTR_CONN_003" // Connection pool exhausted
        RTR_CONN_UNHEALTHY    ErrorCode = "RTR_CONN_004" // Backend unhealthy
        RTR_CONN_CIRCUIT_OPEN ErrorCode = "RTR_CONN_005" // Circuit breaker open

        // Routing errors.
        RTR_ROUTE_NO_MATCH ErrorCode = "RTR_ROUTE_001" // No matching route
        RTR_ROUTE_CONFLICT ErrorCode = "RTR_ROUTE_002" // Route conflict
        RTR_ROUTE_DISABLED ErrorCode = "RTR_ROUTE_003" // Route disabled
        RTR_ROUTE_REDIRECT ErrorCode = "RTR_ROUTE_004" // Route requires redirect

        // Protocol errors.
        RTR_PROTO_MISMATCH   ErrorCode = "RTR_PROTO_001" // Protocol version mismatch
        RTR_PROTO_TRANSFORM  ErrorCode = "RTR_PROTO_002" // Protocol transformation error
        RTR_PROTO_SIZE_LIMIT ErrorCode = "RTR_PROTO_003" // Message size limit exceeded
)

// ErrorInfo contains detailed information about an error.
type ErrorInfo struct {
        Code        ErrorCode   `json:"code"`
        Message     string      `json:"message"`
        Details     interface{} `json:"details,omitempty"`
        HTTPStatus  int         `json:"http_status"`
        Recoverable bool        `json:"recoverable"`
        RetryAfter  int         `json:"retry_after,omitempty"` // Seconds to wait before retry
}

// errorDefinitions maps error codes to their definitions.
var errorDefinitions = map[ErrorCode]ErrorInfo{
        // Common errors
        CMN_INT_UNKNOWN: {
                Code:        CMN_INT_UNKNOWN,
                Message:     "An unknown internal error occurred",
                Details:     nil, // No additional details
                HTTPStatus:  http.StatusInternalServerError,
                Recoverable: false,
                RetryAfter:  0, // No retry
        },
        CMN_INT_PANIC: {
                Code:        CMN_INT_PANIC,
                Message:     "A panic occurred and was recovered",
                HTTPStatus:  http.StatusInternalServerError,
                Recoverable: false,
                Details:     nil, // No additional details
                RetryAfter:  0,   // No retry
        },
        CMN_INT_TIMEOUT: {
                Code:        CMN_INT_TIMEOUT,
                Message:     "Operation timed out",
                Details:     nil, // No additional details
                HTTPStatus:  http.StatusGatewayTimeout,
                Recoverable: true,
                RetryAfter:  MediumRetryTimeout,
        },
        CMN_INT_CONTEXT_CANC: {
                Code:        CMN_INT_CONTEXT_CANC,
                Message:     "Request was canceled",
                Details:     nil, // No additional details
                HTTPStatus:  http.StatusRequestTimeout,
                Recoverable: true,
                RetryAfter:  0, // No retry for canceled requests
        },
        CMN_INT_NOT_IMPL: {
                Code:        CMN_INT_NOT_IMPL,
                Message:     "Feature not implemented",
                HTTPStatus:  http.StatusInternalServerError,
                Recoverable: false,
                Details:     nil, // No additional details
                RetryAfter:  0,   // No retry
        },

        // Validation errors
        CMN_VAL_INVALID_REQ: {
                Code:        CMN_VAL_INVALID_REQ,
                Message:     "Invalid request format",
                HTTPStatus:  http.StatusBadRequest,
                Recoverable: false,
                Details:     nil, // No additional details
                RetryAfter:  0,   // No retry
        },
        CMN_VAL_MISSING_FLD: {
                Code:        CMN_VAL_MISSING_FLD,
                Message:     "Required field missing",
                HTTPStatus:  http.StatusInternalServerError,
                Recoverable: false,
                Details:     nil, // No additional details
                RetryAfter:  0,   // No retry
        },
        CMN_VAL_INVALID_TYPE: {
                Code:        CMN_VAL_INVALID_TYPE,
                Message:     "Invalid field type",
                HTTPStatus:  http.StatusInternalServerError,
                Recoverable: false,
                Details:     nil, // No additional details
                RetryAfter:  0,   // No retry
        },
        CMN_VAL_OUT_OF_RANGE: {
                Code:        CMN_VAL_OUT_OF_RANGE,
                Message:     "Value out of acceptable range",
                HTTPStatus:  http.StatusInternalServerError,
                Recoverable: false,
                Details:     nil, // No additional details
                RetryAfter:  0,   // No retry
        },
        CMN_VAL_PATTERN_FAIL: {
                Code:        CMN_VAL_PATTERN_FAIL,
                Message:     "Pattern validation failed",
                HTTPStatus:  http.StatusInternalServerError,
                Recoverable: false,
                Details:     nil, // No additional details
                RetryAfter:  0,   // No retry
        },

        // Protocol errors
        CMN_PROTO_INVALID_VER: {
                Code:        CMN_PROTO_INVALID_VER,
                Message:     "Invalid protocol version",
                HTTPStatus:  http.StatusInternalServerError,
                Recoverable: false,
                Details:     nil, // No additional details
                RetryAfter:  0,   // No retry
        },
        CMN_PROTO_PARSE_ERR: {
                Code:        CMN_PROTO_PARSE_ERR,
                Message:     "Protocol parsing error",
                HTTPStatus:  http.StatusInternalServerError,
                Recoverable: false,
                Details:     nil, // No additional details
                RetryAfter:  0,   // No retry
        },
        CMN_PROTO_MARSHAL_ERR: {
                Code:        CMN_PROTO_MARSHAL_ERR,
                Message:     "Protocol marshaling error",
                HTTPStatus:  http.StatusInternalServerError,
                Recoverable: false,
                Details:     nil, // No additional details
                RetryAfter:  0,   // No retry
        },
        CMN_PROTO_METHOD_UNK: {
                Code:        CMN_PROTO_METHOD_UNK,
                Message:     "Unknown method",
                HTTPStatus:  http.StatusInternalServerError,
                Recoverable: false,
                Details:     nil, // No additional details
                RetryAfter:  0,   // No retry
        },
        CMN_PROTO_BATCH_ERR: {
                Code:        CMN_PROTO_BATCH_ERR,
                Message:     "Batch request error",
                HTTPStatus:  http.StatusInternalServerError,
                Recoverable: false,
                Details:     nil, // No additional details
                RetryAfter:  0,   // No retry
        },

        // Gateway authentication errors
        GTW_AUTH_MISSING: {
                Code:        GTW_AUTH_MISSING,
                Message:     "Missing authentication credentials",
                HTTPStatus:  http.StatusUnauthorized,
                Recoverable: false,
                Details:     nil, // No additional details
                RetryAfter:  0,   // No retry
        },
        GTW_AUTH_INVALID: {
                Code:        GTW_AUTH_INVALID,
                Message:     "Invalid authentication credentials",
                HTTPStatus:  http.StatusInternalServerError,
                Recoverable: false,
                Details:     nil, // No additional details
                RetryAfter:  0,   // No retry
        },
        GTW_AUTH_EXPIRED: {
                Code:        GTW_AUTH_EXPIRED,
                Message:     "Authentication token has expired",
                HTTPStatus:  http.StatusInternalServerError,
                Recoverable: false,
                Details:     nil, // No additional details
                RetryAfter:  0,   // No retry
        },
        GTW_AUTH_INSUFFICIENT: {
                Code:        GTW_AUTH_INSUFFICIENT,
                Message:     "Insufficient permissions for this operation",
                HTTPStatus:  http.StatusInternalServerError,
                Recoverable: false,
                Details:     nil, // No additional details
                RetryAfter:  0,   // No retry
        },
        GTW_AUTH_REVOKED: {
                Code:        GTW_AUTH_REVOKED,
                Message:     "Authentication credentials have been revoked",
                HTTPStatus:  http.StatusInternalServerError,
                Recoverable: false,
                Details:     nil, // No additional details
                RetryAfter:  0,   // No retry
        },
        GTW_AUTH_METHOD_UNK: {
                Code:        GTW_AUTH_METHOD_UNK,
                Message:     "Unknown authentication method",
                HTTPStatus:  http.StatusInternalServerError,
                Recoverable: false,
                Details:     nil, // No additional details
                RetryAfter:  0,   // No retry
        },
        GTW_AUTH_CERT_FAIL: {
                Code:        GTW_AUTH_CERT_FAIL,
                Message:     "Certificate validation failed",
                HTTPStatus:  http.StatusInternalServerError,
                Recoverable: false,
                Details:     nil, // No additional details
                RetryAfter:  0,   // No retry
        },
        GTW_AUTH_OAUTH_FAIL: {
                Code:        GTW_AUTH_OAUTH_FAIL,
                Message:     "OAuth2 authentication flow failed",
                HTTPStatus:  http.StatusInternalServerError,
                Recoverable: false,
                Details:     nil, // No additional details
                RetryAfter:  0,   // No retry
        },

        // Gateway connection errors
        GTW_CONN_REFUSED: {
                Code:        GTW_CONN_REFUSED,
                Message:     "Connection refused",
                Details:     nil, // No additional details
                HTTPStatus:  http.StatusServiceUnavailable,
                Recoverable: true,
                RetryAfter:  MediumRetryTimeout,
        },
        GTW_CONN_TIMEOUT: {
                Code:        GTW_CONN_TIMEOUT,
                Message:     "Connection timeout",
                Details:     nil, // No additional details
                HTTPStatus:  http.StatusGatewayTimeout,
                Recoverable: true,
                RetryAfter:  MediumRetryTimeout,
        },
        GTW_CONN_CLOSED: {
                Code:        GTW_CONN_CLOSED,
                Message:     "Connection closed unexpectedly",
                Details:     nil, // No additional details
                HTTPStatus:  http.StatusServiceUnavailable,
                Recoverable: true,
                RetryAfter:  ShortRetryTimeout,
        },
        GTW_CONN_LIMIT: {
                Code:        GTW_CONN_LIMIT,
                Message:     "Connection limit reached",
                Details:     nil, // No additional details
                HTTPStatus:  http.StatusServiceUnavailable,
                Recoverable: true,
                RetryAfter:  LongRetryTimeout,
        },
        GTW_CONN_TLS_FAIL: {
                Code:        GTW_CONN_TLS_FAIL,
                Message:     "TLS handshake failed",
                HTTPStatus:  http.StatusInternalServerError,
                Recoverable: false,
                Details:     nil, // No additional details
                RetryAfter:  0,   // No retry
        },
        GTW_CONN_UPGRADE_FAIL: {
                Code:        GTW_CONN_UPGRADE_FAIL,
                Message:     "WebSocket upgrade failed",
                HTTPStatus:  http.StatusInternalServerError,
                Recoverable: false,
                Details:     nil, // No additional details
                RetryAfter:  0,   // No retry
        },

        // Gateway rate limiting errors
        GTW_RATE_LIMIT_REQ: {
                Code:        GTW_RATE_LIMIT_REQ,
                Message:     "Request rate limit exceeded",
                Details:     nil, // No additional details
                HTTPStatus:  http.StatusTooManyRequests,
                Recoverable: true,
                RetryAfter:  LongRetryTimeout,
        },
        GTW_RATE_LIMIT_CONN: {
                Code:        GTW_RATE_LIMIT_CONN,
                Message:     "Connection rate limit exceeded",
                Details:     nil, // No additional details
                HTTPStatus:  http.StatusTooManyRequests,
                Recoverable: true,
                RetryAfter:  ExtendedRetryTimeout,
        },
        GTW_RATE_LIMIT_BURST: {
                Code:        GTW_RATE_LIMIT_BURST,
                Message:     "Burst limit exceeded",
                Details:     nil, // No additional details
                HTTPStatus:  http.StatusTooManyRequests,
                Recoverable: true,
                RetryAfter:  StandardRetryTimeout,
        },
        GTW_RATE_LIMIT_QUOTA: {
                Code:        GTW_RATE_LIMIT_QUOTA,
                Message:     "API quota exceeded",
                Details:     nil, // No additional details
                HTTPStatus:  http.StatusTooManyRequests,
                Recoverable: true,
                RetryAfter:  MaxRetryTimeout,
        },

        // Gateway security errors
        GTW_SEC_BLOCKED_IP: {
                Code:        GTW_SEC_BLOCKED_IP,
                Message:     "IP address has been blocked",
                HTTPStatus:  http.StatusInternalServerError,
                Recoverable: false,
                Details:     nil, // No additional details
                RetryAfter:  0,   // No retry
        },
        GTW_SEC_BLOCKED_UA: {
                Code:        GTW_SEC_BLOCKED_UA,
                Message:     "User agent has been blocked",
                HTTPStatus:  http.StatusInternalServerError,
                Recoverable: false,
                Details:     nil, // No additional details
                RetryAfter:  0,   // No retry
        },
        GTW_SEC_MALICIOUS: {
                Code:        GTW_SEC_MALICIOUS,
                Message:     "Malicious request pattern detected",
                HTTPStatus:  http.StatusInternalServerError,
                Recoverable: false,
                Details:     nil, // No additional details
                RetryAfter:  0,   // No retry
        },
        GTW_SEC_CSRF_FAIL: {
                Code:        GTW_SEC_CSRF_FAIL,
                Message:     "CSRF validation failed",
                HTTPStatus:  http.StatusInternalServerError,
                Recoverable: false,
                Details:     nil, // No additional details
                RetryAfter:  0,   // No retry
        },

        // Router connection errors
        RTR_CONN_NO_BACKEND: {
                Code:        RTR_CONN_NO_BACKEND,
                Message:     "No backend server available",
                Details:     nil, // No additional details
                HTTPStatus:  http.StatusServiceUnavailable,
                Recoverable: true,
                RetryAfter:  MediumRetryTimeout,
        },
        RTR_CONN_BACKEND_ERR: {
                Code:        RTR_CONN_BACKEND_ERR,
                Message:     "Backend server connection error",
                Details:     nil, // No additional details
                HTTPStatus:  http.StatusBadGateway,
                Recoverable: true,
                RetryAfter:  StandardRetryTimeout,
        },
        RTR_CONN_POOL_FULL: {
                Code:        RTR_CONN_POOL_FULL,
                Message:     "Connection pool exhausted",
                Details:     nil, // No additional details
                HTTPStatus:  http.StatusServiceUnavailable,
                Recoverable: true,
                RetryAfter:  MediumRetryTimeout,
        },
        RTR_CONN_UNHEALTHY: {
                Code:        RTR_CONN_UNHEALTHY,
                Message:     "Backend server is unhealthy",
                Details:     nil, // No additional details
                HTTPStatus:  http.StatusServiceUnavailable,
                Recoverable: true,
                RetryAfter:  LongRetryTimeout,
        },
        RTR_CONN_CIRCUIT_OPEN: {
                Code:        RTR_CONN_CIRCUIT_OPEN,
                Message:     "Circuit breaker is open",
                Details:     nil, // No additional details
                HTTPStatus:  http.StatusServiceUnavailable,
                Recoverable: true,
                RetryAfter:  MediumRetryTimeout,
        },

        // Router routing errors
        RTR_ROUTE_NO_MATCH: {
                Code:        RTR_ROUTE_NO_MATCH,
                Message:     "No matching route found",
                HTTPStatus:  http.StatusInternalServerError,
                Recoverable: false,
                Details:     nil, // No additional details
                RetryAfter:  0,   // No retry
        },
        RTR_ROUTE_CONFLICT: {
                Code:        RTR_ROUTE_CONFLICT,
                Message:     "Route configuration conflict",
                HTTPStatus:  http.StatusInternalServerError,
                Recoverable: false,
                Details:     nil, // No additional details
                RetryAfter:  0,   // No retry
        },
        RTR_ROUTE_DISABLED: {
                Code:        RTR_ROUTE_DISABLED,
                Message:     "Route has been disabled",
                HTTPStatus:  http.StatusInternalServerError,
                Recoverable: false,
                Details:     nil, // No additional details
                RetryAfter:  0,   // No retry
        },
        RTR_ROUTE_REDIRECT: {
                Code:        RTR_ROUTE_REDIRECT,
                Message:     "Route requires redirect",
                HTTPStatus:  http.StatusInternalServerError,
                Recoverable: false,
                Details:     nil, // No additional details
                RetryAfter:  0,   // No retry
        },

        // Router protocol errors
        RTR_PROTO_MISMATCH: {
                Code:        RTR_PROTO_MISMATCH,
                Message:     "Protocol version mismatch",
                HTTPStatus:  http.StatusInternalServerError,
                Recoverable: false,
                Details:     nil, // No additional details
                RetryAfter:  0,   // No retry
        },
        RTR_PROTO_TRANSFORM: {
                Code:        RTR_PROTO_TRANSFORM,
                Message:     "Protocol transformation error",
                HTTPStatus:  http.StatusInternalServerError,
                Recoverable: false,
                Details:     nil, // No additional details
                RetryAfter:  0,   // No retry
        },
        RTR_PROTO_SIZE_LIMIT: {
                Code:        RTR_PROTO_SIZE_LIMIT,
                Message:     "Message size limit exceeded",
                HTTPStatus:  http.StatusInternalServerError,
                Recoverable: false,
                Details:     nil, // No additional details
                RetryAfter:  0,   // No retry
        },
}

// GetErrorInfo returns the error information for a given error code.
func GetErrorInfo(code ErrorCode) (ErrorInfo, bool) <span class="cov9" title="44">{
        info, exists := errorDefinitions[code]

        return info, exists
}</span>

// Error creates a new error with the given code and optional details.
func Error(code ErrorCode, details ...interface{}) error <span class="cov10" title="50">{
        info, exists := errorDefinitions[code]
        if !exists </span><span class="cov1" title="1">{
                info = errorDefinitions[CMN_INT_UNKNOWN]
        }</span>

        <span class="cov10" title="50">if len(details) &gt; 0 </span><span class="cov7" title="20">{
                info.Details = details[0]
        }</span>

        <span class="cov10" title="50">return &amp;MCPError{
                ErrorInfo: info,
        }</span>
}

// MCPError represents an MCP system error.
type MCPError struct {
        ErrorInfo
}

// Error implements the error interface.
func (e *MCPError) Error() string <span class="cov8" title="30">{
        if e.Details != nil </span><span class="cov8" title="26">{
                return fmt.Sprintf("[%s] %s: %v", e.Code, e.Message, e.Details)
        }</span>

        <span class="cov4" title="4">return fmt.Sprintf("[%s] %s", e.Code, e.Message)</span>
}

// HasCode checks if the error matches the given code.
func (e *MCPError) HasCode(code ErrorCode) bool <span class="cov5" title="6">{
        return e.Code == code
}</span>

// WithDetails returns a new error with additional details.
func (e *MCPError) WithDetails(details interface{}) *MCPError <span class="cov1" title="1">{
        newErr := *e
        newErr.Details = details

        return &amp;newErr
}</span>

// IsErrorCode checks if an error is an MCPError with the given code.
func IsErrorCode(err error, code ErrorCode) bool <span class="cov5" title="6">{
        var mcpErr *MCPError
        if errors.As(err, &amp;mcpErr) </span><span class="cov4" title="5">{
                return mcpErr.HasCode(code)
        }</span>

        <span class="cov1" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package errors

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "net/http"
        "strconv"
        "time"

        "go.uber.org/zap"
)

// contextKey is used as a key for storing values in context.
type contextKey string

const requestIDKey contextKey = "request_id"

// ErrorResponse represents the standardized error response format.
type ErrorResponse struct {
        Error     ErrorDetail `json:"error"`
        RequestID string      `json:"request_id,omitempty"`
        Timestamp string      `json:"timestamp"`
}

// ErrorDetail contains the error details.
type ErrorDetail struct {
        Code        string                 `json:"code"`
        Message     string                 `json:"message"`
        Details     string                 `json:"details,omitempty"`
        Retryable   bool                   `json:"retryable"`
        Remediation string                 `json:"remediation,omitempty"`
        Context     map[string]interface{} `json:"context,omitempty"`
}

// ErrorHandler provides centralized error handling.
type ErrorHandler struct {
        logger *zap.Logger
}

// NewErrorHandler creates a new error handler.
func NewErrorHandler(logger *zap.Logger) *ErrorHandler <span class="cov4" title="4">{
        return &amp;ErrorHandler{
                logger: logger,
        }
}</span>

// HandleError handles an error and writes an appropriate response.
func (h *ErrorHandler) HandleError(w http.ResponseWriter, r *http.Request, err error) <span class="cov4" title="5">{
        // Extract request ID and ensure we have an MCPError
        requestID := h.extractRequestID(r)
        mcpErr := h.ensureMCPError(err)

        // Log the error
        h.logError(r.Context(), mcpErr, requestID)

        // Create error response
        response := ErrorResponse{
                Error: ErrorDetail{
                        Code:        string(mcpErr.Code),
                        Message:     mcpErr.Message,
                        Details:     h.formatDetails(mcpErr.Details),
                        Retryable:   mcpErr.Recoverable,
                        Remediation: "",  // No remediation info
                        Context:     nil, // No additional context
                },
                RequestID: requestID,
                Timestamp: time.Now().UTC().Format(time.RFC3339),
        }

        // Set headers and write response
        h.setResponseHeaders(w, mcpErr, requestID)
        w.WriteHeader(mcpErr.HTTPStatus)

        // Write response body
        if err := json.NewEncoder(w).Encode(response); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to encode error response",
                        zap.Error(err),
                        zap.String("original_error", mcpErr.Error()),
                )
        }</span>
}

// extractRequestID extracts the request ID from the HTTP request context.
func (h *ErrorHandler) extractRequestID(r *http.Request) string <span class="cov4" title="5">{
        if id := r.Context().Value(requestIDKey); id != nil </span><span class="cov4" title="4">{
                if reqID, ok := id.(string); ok </span><span class="cov4" title="4">{
                        return reqID
                }</span>
        }

        <span class="cov1" title="1">return ""</span>
}

// ensureMCPError converts any error to an MCPError, wrapping if necessary.
func (h *ErrorHandler) ensureMCPError(err error) *MCPError <span class="cov4" title="5">{
        var mcpErr *MCPError
        if errors.As(err, &amp;mcpErr) </span><span class="cov4" title="4">{
                return mcpErr
        }</span>

        // Wrap unknown errors
        <span class="cov1" title="1">var wrappedErr *MCPError
        if errors.As(Error(CMN_INT_UNKNOWN, err.Error()), &amp;wrappedErr) </span><span class="cov1" title="1">{
                return wrappedErr
        }</span>

        // Fallback - should never happen
        <span class="cov0" title="0">return &amp;MCPError{
                ErrorInfo: ErrorInfo{
                        Code:        CMN_INT_UNKNOWN,
                        Message:     "Unknown error",
                        Details:     nil, // No additional details
                        HTTPStatus:  http.StatusInternalServerError,
                        Recoverable: false,
                        RetryAfter:  0, // No retry
                },
        }</span>
}

// formatDetails converts error details to a string representation.
func (h *ErrorHandler) formatDetails(details interface{}) string <span class="cov4" title="5">{
        if details == nil </span><span class="cov2" title="2">{
                return ""
        }</span>

        <span class="cov3" title="3">if str, ok := details.(string); ok </span><span class="cov3" title="3">{
                return str
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf("%v", details)</span>
}

// setResponseHeaders sets the appropriate HTTP headers for the error response.
func (h *ErrorHandler) setResponseHeaders(w http.ResponseWriter, mcpErr *MCPError, requestID string) <span class="cov4" title="5">{
        w.Header().Set("Content-Type", "application/json")
        w.Header().Set("X-Error-Code", string(mcpErr.Code))

        if requestID != "" </span><span class="cov4" title="4">{
                w.Header().Set("X-Request-ID", requestID)
        }</span>

        <span class="cov4" title="5">if mcpErr.Recoverable &amp;&amp; mcpErr.RetryAfter &gt; 0 </span><span class="cov1" title="1">{
                w.Header().Set("Retry-After", strconv.Itoa(mcpErr.RetryAfter))
        }</span>
}

// HandleJSONRPCError handles an error for JSON-RPC responses.
func (h *ErrorHandler) HandleJSONRPCError(err error) map[string]interface{} <span class="cov4" title="5">{
        var mcpErr *MCPError
        if !errors.As(err, &amp;mcpErr) </span><span class="cov0" title="0">{
                var wrappedErr *MCPError
                if errors.As(Error(CMN_INT_UNKNOWN, err.Error()), &amp;wrappedErr) </span><span class="cov0" title="0">{
                        mcpErr = wrappedErr
                }</span> else<span class="cov0" title="0"> {
                        // Fallback - should never happen
                        mcpErr = &amp;MCPError{
                                ErrorInfo: ErrorInfo{
                                        Code:        CMN_INT_UNKNOWN,
                                        Message:     "Unknown error",
                                        Details:     nil, // No additional details
                                        HTTPStatus:  http.StatusInternalServerError,
                                        Recoverable: false,
                                        RetryAfter:  0, // No retry
                                },
                        }
                }</span>
        }

        // Map to JSON-RPC error codes
        <span class="cov4" title="5">jsonRPCCode := h.mapToJSONRPCCode(mcpErr.Code)

        errorData := map[string]interface{}{
                "code":      string(mcpErr.Code),
                "retryable": mcpErr.Recoverable,
                "timestamp": time.Now().UTC().Format(time.RFC3339),
        }

        if mcpErr.Details != nil </span><span class="cov0" title="0">{
                errorData["details"] = mcpErr.Details
        }</span>

        <span class="cov4" title="5">return map[string]interface{}{
                "code":    jsonRPCCode,
                "message": mcpErr.Message,
                "data":    errorData,
        }</span>
}

// logError logs the error with appropriate level and context.
func (h *ErrorHandler) logError(_ context.Context, mcpErr *MCPError, requestID string) <span class="cov4" title="5">{
        fields := []zap.Field{
                zap.String("error_code", string(mcpErr.Code)),
                zap.String("error_message", mcpErr.Message),
                zap.Int("http_status", mcpErr.HTTPStatus),
                zap.Bool("retryable", mcpErr.Recoverable),
        }

        if requestID != "" </span><span class="cov4" title="4">{
                fields = append(fields, zap.String("request_id", requestID))
        }</span>

        <span class="cov4" title="5">if mcpErr.Details != nil </span><span class="cov3" title="3">{
                fields = append(fields, zap.Any("details", mcpErr.Details))
        }</span>

        // Log based on severity
        <span class="cov4" title="5">switch </span>{
        case mcpErr.HTTPStatus &gt;= http.StatusInternalServerError:<span class="cov3" title="3">
                h.logger.Error("Server error", fields...)</span>
        case mcpErr.HTTPStatus &gt;= http.StatusBadRequest:<span class="cov2" title="2">
                h.logger.Warn("Client error", fields...)</span>
        default:<span class="cov0" title="0">
                h.logger.Info("Error handled", fields...)</span>
        }
}

// mapToJSONRPCCode maps our error codes to JSON-RPC error codes.
//

func (h *ErrorHandler) mapToJSONRPCCode(code ErrorCode) int <span class="cov4" title="5">{
        switch code </span>{ 
        case CMN_PROTO_PARSE_ERR:<span class="cov1" title="1">
                return -32700</span> // Parse error
        case CMN_PROTO_METHOD_UNK:<span class="cov1" title="1">
                return -32601</span> // Method not found
        case CMN_VAL_INVALID_REQ, CMN_VAL_INVALID_TYPE, CMN_VAL_MISSING_FLD:<span class="cov1" title="1">
                return -32602</span> // Invalid params
        case CMN_INT_UNKNOWN, CMN_INT_PANIC:<span class="cov1" title="1">
                return -32603</span> // Internal error
        // All other errors map to application-defined error codes
        case CMN_INT_TIMEOUT, CMN_INT_CONTEXT_CANC, CMN_INT_NOT_IMPL,
                CMN_VAL_OUT_OF_RANGE, CMN_VAL_PATTERN_FAIL,
                CMN_PROTO_INVALID_VER, CMN_PROTO_MARSHAL_ERR, CMN_PROTO_BATCH_ERR,
                GTW_AUTH_MISSING, GTW_AUTH_INVALID, GTW_AUTH_EXPIRED, GTW_AUTH_INSUFFICIENT, GTW_AUTH_REVOKED,
                GTW_AUTH_METHOD_UNK, GTW_AUTH_CERT_FAIL, GTW_AUTH_OAUTH_FAIL,
                GTW_CONN_REFUSED, GTW_CONN_TIMEOUT, GTW_CONN_CLOSED, GTW_CONN_LIMIT, GTW_CONN_TLS_FAIL, GTW_CONN_UPGRADE_FAIL,
                GTW_RATE_LIMIT_REQ, GTW_RATE_LIMIT_CONN, GTW_RATE_LIMIT_BURST, GTW_RATE_LIMIT_QUOTA,
                GTW_SEC_BLOCKED_IP, GTW_SEC_BLOCKED_UA, GTW_SEC_MALICIOUS, GTW_SEC_CSRF_FAIL,
                RTR_CONN_NO_BACKEND, RTR_CONN_BACKEND_ERR, RTR_CONN_POOL_FULL, RTR_CONN_UNHEALTHY, RTR_CONN_CIRCUIT_OPEN,
                RTR_ROUTE_NO_MATCH, RTR_ROUTE_CONFLICT, RTR_ROUTE_DISABLED, RTR_ROUTE_REDIRECT,
                RTR_PROTO_MISMATCH, RTR_PROTO_TRANSFORM, RTR_PROTO_SIZE_LIMIT:<span class="cov1" title="1">
                // Application-defined errors
                return -32000</span>
        }
        // This should never be reached since all error codes are handled above
        // But required for compilation since the exhaustive linter can't prove completeness to the compiler
        <span class="cov0" title="0">return -32603</span> // Internal error as fallback
}

// ErrorHandlerMiddleware creates HTTP middleware for error handling.
func ErrorHandlerMiddleware(handler *ErrorHandler) func(http.Handler) http.Handler <span class="cov1" title="1">{
        return func(next http.Handler) http.Handler </span><span class="cov2" title="2">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov2" title="2">{
                        // Create response writer wrapper to capture errors
                        rw := &amp;responseWriterWrapper{
                                ResponseWriter: w,
                                handler:        handler,
                                request:        r,
                                wroteHeader:    false, // Initialize header tracking
                        }

                        // Handle panics
                        defer func() </span><span class="cov2" title="2">{
                                if err := recover(); err != nil </span><span class="cov1" title="1">{
                                        handler.logger.Error("Panic recovered",
                                                zap.Any("panic", err),
                                                zap.String("path", r.URL.Path),
                                        )

                                        mcpErr := Error(CMN_INT_PANIC, "An unexpected error occurred")
                                        handler.HandleError(w, r, mcpErr)
                                }</span>
                        }()

                        <span class="cov2" title="2">next.ServeHTTP(rw, r)</span>
                })
        }
}

// responseWriterWrapper wraps http.ResponseWriter to intercept errors.
type responseWriterWrapper struct {
        http.ResponseWriter
        handler     *ErrorHandler
        request     *http.Request
        wroteHeader bool
}

func (rw *responseWriterWrapper) WriteHeader(statusCode int) <span class="cov4" title="4">{
        if !rw.wroteHeader </span><span class="cov3" title="3">{
                rw.wroteHeader = true
                rw.ResponseWriter.WriteHeader(statusCode)
        }</span>
}

func (rw *responseWriterWrapper) Write(b []byte) (int, error) <span class="cov2" title="2">{
        if !rw.wroteHeader </span><span class="cov1" title="1">{
                rw.WriteHeader(http.StatusOK)
        }</span>

        <span class="cov2" title="2">return rw.ResponseWriter.Write(b)</span>
}

// IsRetryable checks if an error is retryable.
func IsRetryable(err error) bool <span class="cov10" title="46">{
        var mcpErr *MCPError
        if errors.As(err, &amp;mcpErr) </span><span class="cov9" title="45">{
                return mcpErr.Recoverable
        }</span>

        <span class="cov1" title="1">return false</span>
}

// GetHTTPStatus returns the HTTP status code for an error.
func GetHTTPStatus(err error) int <span class="cov3" title="3">{
        var mcpErr *MCPError
        if errors.As(err, &amp;mcpErr) </span><span class="cov2" title="2">{
                return mcpErr.HTTPStatus
        }</span>

        <span class="cov1" title="1">return http.StatusInternalServerError</span>
}

// GetErrorCode extracts the error code from an error.
func GetErrorCode(err error) ErrorCode <span class="cov2" title="2">{
        var mcpErr *MCPError
        if errors.As(err, &amp;mcpErr) </span><span class="cov1" title="1">{
                return mcpErr.Code
        }</span>

        <span class="cov1" title="1">return CMN_INT_UNKNOWN</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package errors

import (
        "context"
        "errors"
        "net/http"

        "go.uber.org/zap"
        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/metadata"
        "google.golang.org/grpc/status"
)

// GRPCErrorInterceptor provides gRPC error handling.
type GRPCErrorInterceptor struct {
        logger *zap.Logger
}

// NewGRPCErrorInterceptor creates a new gRPC error interceptor.
func NewGRPCErrorInterceptor(logger *zap.Logger) *GRPCErrorInterceptor <span class="cov8" title="16">{
        return &amp;GRPCErrorInterceptor{
                logger: logger,
        }
}</span>

// UnaryServerInterceptor creates a unary server interceptor for error handling.
func (i *GRPCErrorInterceptor) UnaryServerInterceptor() grpc.UnaryServerInterceptor <span class="cov5" title="6">{
        return func(
                ctx context.Context,
                req interface{},
                info *grpc.UnaryServerInfo,
                handler grpc.UnaryHandler,
        ) (interface{}, error) </span><span class="cov5" title="6">{
                // Handle panics
                defer func() </span><span class="cov5" title="6">{
                        if err := recover(); err != nil </span><span class="cov1" title="1">{
                                i.logger.Error("Panic in gRPC handler",
                                        zap.Any("panic", err),
                                        zap.String("method", info.FullMethod),
                                )
                        }</span>
                }()

                // Call handler
                <span class="cov5" title="6">resp, err := handler(ctx, req)
                if err != nil </span><span class="cov4" title="4">{
                        return nil, i.handleError(ctx, err, info.FullMethod)
                }</span>

                <span class="cov1" title="1">return resp, nil</span>
        }
}

// StreamServerInterceptor creates a stream server interceptor for error handling.
func (i *GRPCErrorInterceptor) StreamServerInterceptor() grpc.StreamServerInterceptor <span class="cov4" title="3">{
        return func(srv interface{}, ss grpc.ServerStream, info *grpc.StreamServerInfo, handler grpc.StreamHandler) error </span><span class="cov4" title="3">{
                // Handle panics
                defer func() </span><span class="cov4" title="3">{
                        if err := recover(); err != nil </span><span class="cov1" title="1">{
                                i.logger.Error("Panic in gRPC stream handler",
                                        zap.Any("panic", err),
                                        zap.String("method", info.FullMethod),
                                )
                        }</span>
                }()

                // Call handler
                <span class="cov4" title="3">err := handler(srv, ss)
                if err != nil </span><span class="cov1" title="1">{
                        return i.handleError(ss.Context(), err, info.FullMethod)
                }</span>

                <span class="cov1" title="1">return nil</span>
        }
}

// handleError processes and enriches gRPC errors.
func (i *GRPCErrorInterceptor) handleError(ctx context.Context, err error, method string) error <span class="cov5" title="6">{
        // Check if it's already a gRPC status error
        if _, ok := status.FromError(err); ok </span><span class="cov1" title="1">{
                i.logGRPCError(ctx, err, method)

                return err
        }</span>

        // Check if it's our error type
        <span class="cov5" title="5">var mcpErr *MCPError
        if errors.As(err, &amp;mcpErr) </span><span class="cov4" title="3">{
                grpcErr := i.convertToGRPCError(ctx, mcpErr)
                i.logGRPCError(ctx, grpcErr, method)

                return grpcErr
        }</span>

        // Unknown error - wrap it
        <span class="cov2" title="2">var wrappedMcpErr *MCPError
        if errors.As(Error(CMN_INT_UNKNOWN, err.Error()), &amp;wrappedMcpErr) </span><span class="cov2" title="2">{
                grpcErr := i.convertToGRPCError(ctx, wrappedMcpErr)
                i.logGRPCError(ctx, grpcErr, method)

                return grpcErr
        }</span>

        // Fallback - should never happen
        <span class="cov0" title="0">fallbackErr := &amp;MCPError{
                ErrorInfo: ErrorInfo{
                        Code:        CMN_INT_UNKNOWN,
                        Message:     "Unknown error",
                        Details:     nil, // No additional details
                        HTTPStatus:  http.StatusInternalServerError,
                        Recoverable: false,
                        RetryAfter:  0, // No retry
                },
        }
        grpcErr := i.convertToGRPCError(ctx, fallbackErr)
        i.logGRPCError(ctx, grpcErr, method)

        return grpcErr</span>
}

// convertToGRPCError converts our error type to gRPC status.
func (i *GRPCErrorInterceptor) convertToGRPCError(ctx context.Context, mcpErr *MCPError) error <span class="cov5" title="6">{
        code := i.mapToGRPCCode(mcpErr.Code)

        // Create status with details
        st := status.New(code, mcpErr.Message)

        // Add metadata
        md := metadata.Pairs(
                "error-code", string(mcpErr.Code),
                "retryable", formatBool(mcpErr.Recoverable),
        )

        // Attach metadata to context
        if err := grpc.SetTrailer(ctx, md); err != nil </span><span class="cov5" title="6">{
                i.logger.Warn("Failed to set gRPC trailer", zap.Error(err))
        }</span>

        <span class="cov5" title="6">return st.Err()</span>
}

// mapAuthErrorToGRPC maps authentication and authorization errors to gRPC codes.
func (i *GRPCErrorInterceptor) mapAuthErrorToGRPC(code ErrorCode) (codes.Code, bool) <span class="cov10" title="26">{
        switch code </span>{ 
        case GTW_AUTH_MISSING, GTW_AUTH_INVALID, GTW_AUTH_EXPIRED, GTW_AUTH_REVOKED,
                GTW_AUTH_METHOD_UNK, GTW_AUTH_CERT_FAIL, GTW_AUTH_OAUTH_FAIL:<span class="cov5" title="6">
                return codes.Unauthenticated, true</span>
        case GTW_AUTH_INSUFFICIENT, GTW_SEC_BLOCKED_IP, GTW_SEC_BLOCKED_UA, GTW_SEC_MALICIOUS, GTW_SEC_CSRF_FAIL:<span class="cov2" title="2">
                return codes.PermissionDenied, true</span>
        // Non-auth errors - return false to indicate not handled
        case CMN_INT_UNKNOWN, CMN_INT_PANIC, CMN_INT_TIMEOUT, CMN_INT_CONTEXT_CANC, CMN_INT_NOT_IMPL,
                CMN_VAL_INVALID_REQ, CMN_VAL_MISSING_FLD, CMN_VAL_INVALID_TYPE, CMN_VAL_OUT_OF_RANGE, CMN_VAL_PATTERN_FAIL,
                CMN_PROTO_INVALID_VER, CMN_PROTO_PARSE_ERR, CMN_PROTO_MARSHAL_ERR, CMN_PROTO_METHOD_UNK, CMN_PROTO_BATCH_ERR,
                GTW_CONN_REFUSED, GTW_CONN_TIMEOUT, GTW_CONN_CLOSED, GTW_CONN_LIMIT, GTW_CONN_TLS_FAIL, GTW_CONN_UPGRADE_FAIL,
                GTW_RATE_LIMIT_REQ, GTW_RATE_LIMIT_CONN, GTW_RATE_LIMIT_BURST, GTW_RATE_LIMIT_QUOTA,
                RTR_CONN_NO_BACKEND, RTR_CONN_BACKEND_ERR, RTR_CONN_POOL_FULL, RTR_CONN_UNHEALTHY, RTR_CONN_CIRCUIT_OPEN,
                RTR_ROUTE_NO_MATCH, RTR_ROUTE_CONFLICT, RTR_ROUTE_DISABLED, RTR_ROUTE_REDIRECT,
                RTR_PROTO_MISMATCH, RTR_PROTO_TRANSFORM, RTR_PROTO_SIZE_LIMIT:<span class="cov8" title="17">
                return codes.OK, false</span>
        }
        // Should never reach here - all error codes handled above
        <span class="cov1" title="1">return codes.OK, false</span>
}

// mapConnectionErrorToGRPC maps connection-related errors to gRPC codes.
func (i *GRPCErrorInterceptor) mapConnectionErrorToGRPC(code ErrorCode) (codes.Code, bool) <span class="cov9" title="23">{
        switch code </span>{ 
        case CMN_INT_TIMEOUT, GTW_CONN_TIMEOUT:<span class="cov2" title="2">
                return codes.DeadlineExceeded, true</span>
        case GTW_CONN_REFUSED, GTW_CONN_CLOSED, GTW_CONN_LIMIT,
                RTR_CONN_NO_BACKEND, RTR_CONN_BACKEND_ERR, RTR_CONN_UNHEALTHY, RTR_CONN_POOL_FULL:<span class="cov2" title="2">
                return codes.Unavailable, true</span>
        case GTW_CONN_TLS_FAIL, GTW_CONN_UPGRADE_FAIL:<span class="cov1" title="1">
                return codes.FailedPrecondition, true</span>
        case RTR_CONN_CIRCUIT_OPEN:<span class="cov1" title="1">
                return codes.Unavailable, true</span>
        // Non-connection errors - return false to indicate not handled  
        case CMN_INT_UNKNOWN, CMN_INT_PANIC, CMN_INT_CONTEXT_CANC, CMN_INT_NOT_IMPL,
                CMN_VAL_INVALID_REQ, CMN_VAL_MISSING_FLD, CMN_VAL_INVALID_TYPE, CMN_VAL_OUT_OF_RANGE, CMN_VAL_PATTERN_FAIL,
                CMN_PROTO_INVALID_VER, CMN_PROTO_PARSE_ERR, CMN_PROTO_MARSHAL_ERR, CMN_PROTO_METHOD_UNK, CMN_PROTO_BATCH_ERR,
                GTW_AUTH_MISSING, GTW_AUTH_INVALID, GTW_AUTH_EXPIRED, GTW_AUTH_INSUFFICIENT, GTW_AUTH_REVOKED,
                GTW_AUTH_METHOD_UNK, GTW_AUTH_CERT_FAIL, GTW_AUTH_OAUTH_FAIL,
                GTW_RATE_LIMIT_REQ, GTW_RATE_LIMIT_CONN, GTW_RATE_LIMIT_BURST, GTW_RATE_LIMIT_QUOTA,
                GTW_SEC_BLOCKED_IP, GTW_SEC_BLOCKED_UA, GTW_SEC_MALICIOUS, GTW_SEC_CSRF_FAIL,
                RTR_ROUTE_NO_MATCH, RTR_ROUTE_CONFLICT, RTR_ROUTE_DISABLED, RTR_ROUTE_REDIRECT,
                RTR_PROTO_MISMATCH, RTR_PROTO_TRANSFORM, RTR_PROTO_SIZE_LIMIT:<span class="cov8" title="16">
                return codes.OK, false</span>
        }
        // Should never reach here - all error codes handled above
        <span class="cov1" title="1">return codes.OK, false</span>
}

// mapToGRPCCode maps our error codes to gRPC codes.
//

func (i *GRPCErrorInterceptor) mapToGRPCCode(code ErrorCode) codes.Code <span class="cov9" title="20">{
        // Try authentication/authorization errors first
        if grpcCode, handled := i.mapAuthErrorToGRPC(code); handled </span><span class="cov4" title="3">{
                return grpcCode
        }</span>

        // Try connection errors
        <span class="cov8" title="17">if grpcCode, handled := i.mapConnectionErrorToGRPC(code); handled </span><span class="cov1" title="1">{
                return grpcCode
        }</span>

        // Try validation and protocol errors
        <span class="cov8" title="16">if grpcCode, handled := i.mapValidationErrorToGRPC(code); handled </span><span class="cov2" title="2">{
                return grpcCode
        }</span>

        // Try routing errors
        <span class="cov8" title="14">if grpcCode, handled := i.mapRoutingErrorToGRPC(code); handled </span><span class="cov6" title="7">{
                return grpcCode
        }</span>

        // Handle remaining specific errors
        <span class="cov6" title="7">if grpcCode, handled := i.mapInternalErrorToGRPC(code); handled </span><span class="cov5" title="6">{
                return grpcCode
        }</span>

        <span class="cov1" title="1">return codes.Unknown</span>
}

func (i *GRPCErrorInterceptor) mapValidationErrorToGRPC(code ErrorCode) (codes.Code, bool) <span class="cov8" title="16">{
        switch code </span>{
        case CMN_VAL_INVALID_REQ, CMN_VAL_INVALID_TYPE, CMN_VAL_MISSING_FLD, CMN_VAL_OUT_OF_RANGE, CMN_VAL_PATTERN_FAIL:<span class="cov2" title="2">
                return codes.InvalidArgument, true</span>
        case CMN_PROTO_INVALID_VER, CMN_PROTO_PARSE_ERR, CMN_PROTO_MARSHAL_ERR, CMN_PROTO_BATCH_ERR:<span class="cov0" title="0">
                return codes.InvalidArgument, true</span>
        case RTR_PROTO_MISMATCH, RTR_PROTO_TRANSFORM, RTR_PROTO_SIZE_LIMIT:<span class="cov0" title="0">
                return codes.InvalidArgument, true</span>
        // Non-validation errors - return false to indicate not handled
        case CMN_INT_UNKNOWN, CMN_INT_PANIC, CMN_INT_TIMEOUT, CMN_INT_CONTEXT_CANC, CMN_INT_NOT_IMPL,
                CMN_PROTO_METHOD_UNK,
                GTW_AUTH_MISSING, GTW_AUTH_INVALID, GTW_AUTH_EXPIRED, GTW_AUTH_INSUFFICIENT, GTW_AUTH_REVOKED,
                GTW_AUTH_METHOD_UNK, GTW_AUTH_CERT_FAIL, GTW_AUTH_OAUTH_FAIL,
                GTW_CONN_REFUSED, GTW_CONN_TIMEOUT, GTW_CONN_CLOSED, GTW_CONN_LIMIT, GTW_CONN_TLS_FAIL, GTW_CONN_UPGRADE_FAIL,
                GTW_RATE_LIMIT_REQ, GTW_RATE_LIMIT_CONN, GTW_RATE_LIMIT_BURST, GTW_RATE_LIMIT_QUOTA,
                GTW_SEC_BLOCKED_IP, GTW_SEC_BLOCKED_UA, GTW_SEC_MALICIOUS, GTW_SEC_CSRF_FAIL,
                RTR_CONN_NO_BACKEND, RTR_CONN_BACKEND_ERR, RTR_CONN_POOL_FULL, RTR_CONN_UNHEALTHY, RTR_CONN_CIRCUIT_OPEN,
                RTR_ROUTE_NO_MATCH, RTR_ROUTE_CONFLICT, RTR_ROUTE_DISABLED, RTR_ROUTE_REDIRECT:<span class="cov8" title="13">
                return codes.OK, false</span>
        }
        // Should never reach here - all error codes handled above
        <span class="cov1" title="1">return codes.OK, false</span>
}

func (i *GRPCErrorInterceptor) mapRoutingErrorToGRPC(code ErrorCode) (codes.Code, bool) <span class="cov8" title="14">{
        switch code </span>{
        case RTR_ROUTE_NO_MATCH, CMN_PROTO_METHOD_UNK:<span class="cov2" title="2">
                return codes.NotFound, true</span>
        case RTR_ROUTE_CONFLICT:<span class="cov1" title="1">
                return codes.AlreadyExists, true</span>
        case RTR_ROUTE_DISABLED, RTR_CONN_CIRCUIT_OPEN:<span class="cov1" title="1">
                return codes.Unavailable, true</span>
        case RTR_ROUTE_REDIRECT:<span class="cov0" title="0">
                return codes.FailedPrecondition, true</span>
        case GTW_RATE_LIMIT_REQ, GTW_RATE_LIMIT_CONN, GTW_RATE_LIMIT_BURST, GTW_RATE_LIMIT_QUOTA:<span class="cov4" title="3">
                return codes.ResourceExhausted, true</span>
        // Non-routing errors - return false to indicate not handled
        case CMN_INT_UNKNOWN, CMN_INT_PANIC, CMN_INT_TIMEOUT, CMN_INT_CONTEXT_CANC, CMN_INT_NOT_IMPL,
                CMN_VAL_INVALID_REQ, CMN_VAL_MISSING_FLD, CMN_VAL_INVALID_TYPE, CMN_VAL_OUT_OF_RANGE, CMN_VAL_PATTERN_FAIL,
                CMN_PROTO_INVALID_VER, CMN_PROTO_PARSE_ERR, CMN_PROTO_MARSHAL_ERR, CMN_PROTO_BATCH_ERR,
                GTW_AUTH_MISSING, GTW_AUTH_INVALID, GTW_AUTH_EXPIRED, GTW_AUTH_INSUFFICIENT, GTW_AUTH_REVOKED,
                GTW_AUTH_METHOD_UNK, GTW_AUTH_CERT_FAIL, GTW_AUTH_OAUTH_FAIL,
                GTW_CONN_REFUSED, GTW_CONN_TIMEOUT, GTW_CONN_CLOSED, GTW_CONN_LIMIT, GTW_CONN_TLS_FAIL, GTW_CONN_UPGRADE_FAIL,
                GTW_SEC_BLOCKED_IP, GTW_SEC_BLOCKED_UA, GTW_SEC_MALICIOUS, GTW_SEC_CSRF_FAIL,
                RTR_CONN_NO_BACKEND, RTR_CONN_BACKEND_ERR, RTR_CONN_POOL_FULL, RTR_CONN_UNHEALTHY,
                RTR_PROTO_MISMATCH, RTR_PROTO_TRANSFORM, RTR_PROTO_SIZE_LIMIT:<span class="cov5" title="6">
                return codes.OK, false</span>
        }
        // Should never reach here - all error codes handled above
        <span class="cov1" title="1">return codes.OK, false</span>
}

func (i *GRPCErrorInterceptor) mapInternalErrorToGRPC(code ErrorCode) (codes.Code, bool) <span class="cov6" title="7">{
        switch code </span>{
        case CMN_INT_CONTEXT_CANC:<span class="cov1" title="1">
                return codes.Canceled, true</span>
        case CMN_INT_NOT_IMPL:<span class="cov1" title="1">
                return codes.Unimplemented, true</span>
        case CMN_INT_UNKNOWN, CMN_INT_PANIC:<span class="cov4" title="4">
                return codes.Internal, true</span>
        case CMN_INT_TIMEOUT:<span class="cov0" title="0">
                return codes.DeadlineExceeded, true</span>
        // Non-internal errors - return false to indicate not handled
        case CMN_VAL_INVALID_REQ, CMN_VAL_MISSING_FLD, CMN_VAL_INVALID_TYPE, CMN_VAL_OUT_OF_RANGE, CMN_VAL_PATTERN_FAIL,
                CMN_PROTO_INVALID_VER, CMN_PROTO_PARSE_ERR, CMN_PROTO_MARSHAL_ERR, CMN_PROTO_METHOD_UNK, CMN_PROTO_BATCH_ERR,
                GTW_AUTH_MISSING, GTW_AUTH_INVALID, GTW_AUTH_EXPIRED, GTW_AUTH_INSUFFICIENT, GTW_AUTH_REVOKED,
                GTW_AUTH_METHOD_UNK, GTW_AUTH_CERT_FAIL, GTW_AUTH_OAUTH_FAIL,
                GTW_CONN_REFUSED, GTW_CONN_TIMEOUT, GTW_CONN_CLOSED, GTW_CONN_LIMIT, GTW_CONN_TLS_FAIL, GTW_CONN_UPGRADE_FAIL,
                GTW_RATE_LIMIT_REQ, GTW_RATE_LIMIT_CONN, GTW_RATE_LIMIT_BURST, GTW_RATE_LIMIT_QUOTA,
                GTW_SEC_BLOCKED_IP, GTW_SEC_BLOCKED_UA, GTW_SEC_MALICIOUS, GTW_SEC_CSRF_FAIL,
                RTR_CONN_NO_BACKEND, RTR_CONN_BACKEND_ERR, RTR_CONN_POOL_FULL, RTR_CONN_UNHEALTHY, RTR_CONN_CIRCUIT_OPEN,
                RTR_ROUTE_NO_MATCH, RTR_ROUTE_CONFLICT, RTR_ROUTE_DISABLED, RTR_ROUTE_REDIRECT,
                RTR_PROTO_MISMATCH, RTR_PROTO_TRANSFORM, RTR_PROTO_SIZE_LIMIT:<span class="cov0" title="0">
                return codes.OK, false</span>
        }
        // Should never reach here - all error codes handled above
        <span class="cov1" title="1">return codes.OK, false</span>
}

// logGRPCError logs gRPC errors with context.
func (i *GRPCErrorInterceptor) logGRPCError(ctx context.Context, err error, method string) <span class="cov7" title="10">{
        st, _ := status.FromError(err)

        fields := []zap.Field{
                zap.String("method", method),
                zap.String("grpc_code", st.Code().String()),
                zap.String("message", st.Message()),
        }

        // Add request ID if available
        if md, ok := metadata.FromIncomingContext(ctx); ok </span><span class="cov2" title="2">{
                if requestIDs := md.Get("request-id"); len(requestIDs) &gt; 0 </span><span class="cov2" title="2">{
                        fields = append(fields, zap.String("request_id", requestIDs[0]))
                }</span>
        }

        // Log based on severity
        <span class="cov7" title="10">switch st.Code() </span>{
        case codes.Internal, codes.Unknown, codes.DataLoss:<span class="cov4" title="3">
                i.logger.Error("gRPC error", fields...)</span>
        case codes.Unavailable, codes.DeadlineExceeded, codes.ResourceExhausted:<span class="cov1" title="1">
                i.logger.Warn("gRPC error", fields...)</span>
        case codes.OK:<span class="cov0" title="0">
                // OK status - no need to log as error
                i.logger.Debug("gRPC success", fields...)</span>
        case codes.Canceled, codes.InvalidArgument, codes.NotFound, codes.AlreadyExists,
                codes.PermissionDenied, codes.FailedPrecondition, codes.Aborted, codes.OutOfRange,
                codes.Unimplemented, codes.Unauthenticated:<span class="cov5" title="6">
                i.logger.Info("gRPC error", fields...)</span>
        default:<span class="cov0" title="0">
                i.logger.Info("gRPC error", fields...)</span>
        }
}

// ErrorDetails contains additional error information.
type ErrorDetails struct {
        Code      string `json:"code"`
        Details   string `json:"details,omitempty"`
        Retryable bool   `json:"retryable"`
        Timestamp string `json:"timestamp"`
}

// formatBool converts bool to string.
func formatBool(b bool) string <span class="cov6" title="8">{
        if b </span><span class="cov2" title="2">{
                return "true"
        }</span>

        <span class="cov5" title="6">return "false"</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package errors

import (
        "context"
        "crypto/rand"
        "encoding/binary"
        "math"
        "time"

        "go.uber.org/zap"
)

const (
        // fallbackModulo is used for fallback random number generation.
        fallbackModulo = 1000.0
        // defaultMaxAttempts is the default number of retry attempts.
        defaultMaxAttempts = 3
        // defaultMaxIntervalSeconds is the default maximum retry interval.
        defaultMaxIntervalSeconds = 30
        // defaultMultiplier is the default exponential backoff multiplier.
        defaultMultiplier = 2.0
        // defaultRandomizeFactor is the default jitter factor.
        defaultRandomizeFactor = 0.1
)

// secureRandom generates a cryptographically secure random float64 between 0 and 1.
func secureRandom() float64 <span class="cov10" title="221">{
        var b [8]byte

        _, err := rand.Read(b[:])
        if err != nil </span><span class="cov0" title="0">{
                // Fallback to current time if crypto/rand fails
                return float64(time.Now().UnixNano()%int64(fallbackModulo)) / fallbackModulo
        }</span>

        // Convert bytes to uint64, then to float64 between 0 and 1
        <span class="cov10" title="221">return float64(binary.LittleEndian.Uint64(b[:])) / float64(^uint64(0))</span>
}

// RetryConfig defines retry behavior configuration.
type RetryConfig struct {
        MaxAttempts     int
        InitialInterval time.Duration
        MaxInterval     time.Duration
        Multiplier      float64
        RandomizeFactor float64
}

// DefaultRetryConfig returns default retry configuration.
func DefaultRetryConfig() RetryConfig <span class="cov1" title="1">{
        return RetryConfig{
                MaxAttempts:     defaultMaxAttempts,
                InitialInterval: 1 * time.Second,
                MaxInterval:     defaultMaxIntervalSeconds * time.Second,
                Multiplier:      defaultMultiplier,
                RandomizeFactor: defaultRandomizeFactor,
        }
}</span>

// RetryPolicy defines the retry policy interface.
type RetryPolicy interface {
        ShouldRetry(err error, attempt int) bool
        NextInterval(attempt int) time.Duration
}

// ExponentialBackoffPolicy implements exponential backoff with jitter.
type ExponentialBackoffPolicy struct {
        config RetryConfig
        logger *zap.Logger
}

// NewExponentialBackoffPolicy creates a new exponential backoff policy.
func NewExponentialBackoffPolicy(config RetryConfig, logger *zap.Logger) *ExponentialBackoffPolicy <span class="cov3" title="4">{
        return &amp;ExponentialBackoffPolicy{
                config: config,
                logger: logger,
        }
}</span>

// ShouldRetry determines if an error should be retried.
func (p *ExponentialBackoffPolicy) ShouldRetry(err error, attempt int) bool <span class="cov5" title="12">{
        if attempt &gt;= p.config.MaxAttempts </span><span class="cov2" title="2">{
                return false
        }</span>

        // Check if error is retryable
        <span class="cov4" title="10">if !IsRetryable(err) </span><span class="cov2" title="2">{
                p.logger.Debug("Error is not retryable",
                        zap.Error(err),
                        zap.Int("attempt", attempt),
                )

                return false
        }</span>

        <span class="cov4" title="8">return true</span>
}

// NextInterval calculates the next retry interval.
func (p *ExponentialBackoffPolicy) NextInterval(attempt int) time.Duration <span class="cov6" title="34">{
        // Calculate base interval with exponential backoff
        interval := float64(p.config.InitialInterval) * math.Pow(p.config.Multiplier, float64(attempt-1))

        // Cap at max interval
        if interval &gt; float64(p.config.MaxInterval) </span><span class="cov2" title="2">{
                interval = float64(p.config.MaxInterval)
        }</span>

        // Add jitter
        <span class="cov6" title="34">if p.config.RandomizeFactor &gt; 0 </span><span class="cov6" title="21">{
                delta := interval * p.config.RandomizeFactor
                minInterval := interval - delta
                maxInterval := interval + delta

                // Generate random interval between min and max
                interval = minInterval + (secureRandom() * (maxInterval - minInterval))
        }</span>

        <span class="cov6" title="34">return time.Duration(interval)</span>
}

// RetryOperation represents a retryable operation.
type RetryOperation func(ctx context.Context) error

// RetryManager manages retry operations.
type RetryManager struct {
        policy RetryPolicy
        logger *zap.Logger
}

// NewRetryManager creates a new retry manager.
func NewRetryManager(policy RetryPolicy, logger *zap.Logger) *RetryManager <span class="cov2" title="2">{
        return &amp;RetryManager{
                policy: policy,
                logger: logger,
        }
}</span>

// Execute executes an operation with retry logic.
func (m *RetryManager) Execute(ctx context.Context, operation RetryOperation) error <span class="cov4" title="7">{
        var lastErr error

        for attempt := 1; ; attempt++ </span><span class="cov5" title="12">{
                // Check context
                if err := ctx.Err(); err != nil </span><span class="cov0" title="0">{
                        return Error(CMN_INT_CONTEXT_CANC, "Operation canceled: "+err.Error())
                }</span>

                // Execute operation
                <span class="cov5" title="12">startTime := time.Now()
                err := operation(ctx)
                duration := time.Since(startTime)

                // Log attempt
                m.logger.Debug("Retry attempt completed",
                        zap.Int("attempt", attempt),
                        zap.Duration("duration", duration),
                        zap.Error(err),
                )

                // Success
                if err == nil </span><span class="cov2" title="2">{
                        if attempt &gt; 1 </span><span class="cov1" title="1">{
                                m.logger.Info("Operation succeeded after retry",
                                        zap.Int("attempts", attempt),
                                        zap.Duration("total_duration", time.Since(startTime)),
                                )
                        }</span>

                        <span class="cov2" title="2">return nil</span>
                }

                <span class="cov4" title="10">lastErr = err

                // Check if we should retry
                if !m.policy.ShouldRetry(err, attempt) </span><span class="cov2" title="3">{
                        m.logger.Warn("Operation failed, no more retries",
                                zap.Int("attempts", attempt),
                                zap.Error(err),
                        )

                        return err
                }</span>

                // Calculate retry interval
                <span class="cov4" title="7">interval := m.policy.NextInterval(attempt)

                m.logger.Info("Retrying operation",
                        zap.Int("attempt", attempt),
                        zap.Duration("retry_after", interval),
                        zap.Error(err),
                )

                // Wait before retry
                select </span>{
                case &lt;-time.After(interval):<span class="cov3" title="5"></span>
                        // Continue to next attempt
                case &lt;-ctx.Done():<span class="cov2" title="2">
                        return Error(CMN_INT_CONTEXT_CANC, "Operation canceled during retry: "+lastErr.Error())</span>
                }
        }
}

// CircuitBreakerPolicy implements circuit breaker pattern.
type CircuitBreakerPolicy struct {
        config          RetryConfig
        failureCount    int
        successCount    int
        lastFailureTime time.Time
        state           CircuitState
        logger          *zap.Logger
}

// CircuitState represents circuit breaker states.
type CircuitState int

const (
        // CircuitClosed indicates the circuit breaker is closed and allowing requests.
        CircuitClosed CircuitState = iota
        // CircuitOpen indicates the circuit breaker is open and blocking requests.
        CircuitOpen
        // CircuitHalfOpen indicates the circuit breaker is testing if the service has recovered.
        CircuitHalfOpen
)

// NewCircuitBreakerPolicy creates a new circuit breaker policy.
func NewCircuitBreakerPolicy(config RetryConfig, logger *zap.Logger) *CircuitBreakerPolicy <span class="cov5" title="13">{
        return &amp;CircuitBreakerPolicy{
                config:          config,
                failureCount:    0,           // Initialize failure count
                successCount:    0,           // Initialize success count
                lastFailureTime: time.Time{}, // Initialize to zero time
                state:           CircuitClosed,
                logger:          logger,
        }
}</span>

// ShouldRetry implements circuit breaker logic.
func (p *CircuitBreakerPolicy) ShouldRetry(err error, attempt int) bool <span class="cov7" title="42">{
        switch p.state </span>{
        case CircuitOpen:<span class="cov4" title="10">
                // Check if we should transition to half-open
                if time.Since(p.lastFailureTime) &gt; p.config.MaxInterval </span><span class="cov3" title="6">{
                        p.state = CircuitHalfOpen
                        p.logger.Info("Circuit breaker transitioning to half-open")

                        return true
                }</span>

                <span class="cov3" title="4">return false</span>

        case CircuitHalfOpen:<span class="cov0" title="0">
                // Allow one retry in half-open state
                return attempt == 1</span>

        case CircuitClosed:<span class="cov6" title="32">
                // Check if error is retryable
                if !IsRetryable(err) </span><span class="cov1" title="1">{
                        return false
                }</span>

                // Check failure threshold
                <span class="cov6" title="31">p.failureCount++
                if p.failureCount &gt;= p.config.MaxAttempts </span><span class="cov4" title="9">{
                        p.state = CircuitOpen
                        p.lastFailureTime = time.Now()
                        p.logger.Warn("Circuit breaker opened due to failures",
                                zap.Int("failure_count", p.failureCount),
                        )

                        return false
                }</span>

                <span class="cov6" title="22">return true</span>
        }

        <span class="cov0" title="0">return false</span>
}

// NextInterval returns retry interval for circuit breaker.
func (p *CircuitBreakerPolicy) NextInterval(attempt int) time.Duration <span class="cov3" title="5">{
        if p.state == CircuitHalfOpen </span><span class="cov1" title="1">{
                // Use shorter interval for half-open state
                return p.config.InitialInterval
        }</span>

        // Use exponential backoff for closed state
        <span class="cov3" title="4">return time.Duration(float64(p.config.InitialInterval) * math.Pow(p.config.Multiplier, float64(attempt-1)))</span>
}

// RecordSuccess records a successful operation.
func (p *CircuitBreakerPolicy) RecordSuccess() <span class="cov4" title="8">{
        p.successCount++

        switch p.state </span>{
        case CircuitHalfOpen:<span class="cov2" title="2">
                // Transition to closed after success in half-open
                p.state = CircuitClosed
                p.failureCount = 0
                p.logger.Info("Circuit breaker closed after successful retry")</span>

        case CircuitClosed:<span class="cov3" title="5">
                // Reset failure count after consecutive successes
                if p.successCount &gt; p.config.MaxAttempts </span><span class="cov1" title="1">{
                        p.failureCount = 0
                }</span>

        case CircuitOpen:<span class="cov1" title="1"></span>
                // No action needed for open state on success
        } 
}

// RecordFailure records a failed operation.
func (p *CircuitBreakerPolicy) RecordFailure() <span class="cov2" title="2">{
        p.successCount = 0

        if p.state == CircuitHalfOpen </span><span class="cov2" title="2">{
                // Return to open state
                p.state = CircuitOpen
                p.lastFailureTime = time.Now()
                p.logger.Warn("Circuit breaker reopened after failure in half-open state")
        }</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Package logging provides correlation ID utilities for request tracing across MCP components.
package logging

import (
        "context"
        "crypto/rand"
        "encoding/hex"
        "fmt"

        "go.uber.org/zap"
)

// contextKey is a private type for context keys to avoid collisions.
type contextKey string

const (
        // CorrelationIDKey is the context key for correlation IDs.
        correlationIDKey contextKey = "correlation_id"
        // TraceIDKey is the context key for trace IDs.
        traceIDKey contextKey = "trace_id"
        // correlationIDBytes is the size of correlation ID in bytes.
        correlationIDBytes = 8
        // traceIDBytes is the size of trace ID in bytes.
        traceIDBytes = 16
        // loggerFieldCapacity is the initial capacity for logger field slices.
        loggerFieldCapacity = 2
)

// GenerateCorrelationID generates a new correlation ID.
func GenerateCorrelationID() string <span class="cov10" title="6115">{
        bytes := make([]byte, correlationIDBytes)
        if _, err := rand.Read(bytes); err != nil </span><span class="cov0" title="0">{
                // This should never happen with crypto/rand, but handle gracefully
                return fmt.Sprintf("corr_fallback_%d", len(bytes))
        }</span>

        <span class="cov10" title="6115">return hex.EncodeToString(bytes)</span>
}

// GenerateTraceID generates a new trace ID.
func GenerateTraceID() string <span class="cov10" title="6115">{
        bytes := make([]byte, traceIDBytes)
        if _, err := rand.Read(bytes); err != nil </span><span class="cov0" title="0">{
                // This should never happen with crypto/rand, but handle gracefully
                return fmt.Sprintf("trace_fallback_%d", len(bytes))
        }</span>

        <span class="cov10" title="6115">return hex.EncodeToString(bytes)</span>
}

// WithCorrelationID adds a correlation ID to the context.
func WithCorrelationID(ctx context.Context, correlationID string) context.Context <span class="cov8" title="1014">{
        return context.WithValue(ctx, correlationIDKey, correlationID)
}</span>

// WithTraceID adds a trace ID to the context.
func WithTraceID(ctx context.Context, traceID string) context.Context <span class="cov8" title="1013">{
        return context.WithValue(ctx, traceIDKey, traceID)
}</span>

// GetCorrelationID retrieves the correlation ID from context.
func GetCorrelationID(ctx context.Context) string <span class="cov8" title="2042">{
        if id, ok := ctx.Value(correlationIDKey).(string); ok </span><span class="cov8" title="1020">{
                return id
        }</span>

        <span class="cov8" title="1022">return ""</span>
}

// GetTraceID retrieves the trace ID from context.
func GetTraceID(ctx context.Context) string <span class="cov8" title="2042">{
        if id, ok := ctx.Value(traceIDKey).(string); ok </span><span class="cov8" title="1019">{
                return id
        }</span>

        <span class="cov8" title="1023">return ""</span>
}

// WithCorrelation creates a new context with correlation and trace IDs if they don't exist.
func WithCorrelation(ctx context.Context) context.Context <span class="cov8" title="1004">{
        if GetCorrelationID(ctx) == "" </span><span class="cov8" title="1002">{
                ctx = WithCorrelationID(ctx, GenerateCorrelationID())
        }</span>

        <span class="cov8" title="1004">if GetTraceID(ctx) == "" </span><span class="cov8" title="1002">{
                ctx = WithTraceID(ctx, GenerateTraceID())
        }</span>

        <span class="cov8" title="1004">return ctx</span>
}

// LoggerWithCorrelation returns a logger with correlation fields from context.
func LoggerWithCorrelation(ctx context.Context, logger *zap.Logger) *zap.Logger <span class="cov4" title="24">{
        fields := make([]zap.Field, 0, loggerFieldCapacity)

        if correlationID := GetCorrelationID(ctx); correlationID != "" </span><span class="cov3" title="7">{
                fields = append(fields, zap.String(FieldCorrelationID, correlationID))
        }</span>

        <span class="cov4" title="24">if traceID := GetTraceID(ctx); traceID != "" </span><span class="cov2" title="6">{
                fields = append(fields, zap.String(FieldTraceID, traceID))
        }</span>

        <span class="cov4" title="24">if len(fields) &gt; 0 </span><span class="cov3" title="9">{
                return logger.With(fields...)
        }</span>

        <span class="cov3" title="15">return logger</span>
}

// LoggerWithRequest returns a logger with request-specific fields.
func LoggerWithRequest(ctx context.Context, logger *zap.Logger, requestID interface{}) *zap.Logger <span class="cov3" title="8">{
        logger = LoggerWithCorrelation(ctx, logger)

        if requestID != nil </span><span class="cov2" title="6">{
                logger = logger.With(zap.Any(FieldRequestID, requestID))
        }</span>

        <span class="cov3" title="8">return logger</span>
}

// LoggerWithConnection returns a logger with connection-specific fields.
func LoggerWithConnection(ctx context.Context, logger *zap.Logger, connectionID, remoteAddr string) *zap.Logger <span class="cov3" title="8">{
        logger = LoggerWithCorrelation(ctx, logger)

        fields := make([]zap.Field, 0, loggerFieldCapacity)
        if connectionID != "" </span><span class="cov2" title="4">{
                fields = append(fields, zap.String(FieldConnectionID, connectionID))
        }</span>

        <span class="cov3" title="8">if remoteAddr != "" </span><span class="cov2" title="4">{
                fields = append(fields, zap.String(FieldRemoteAddr, remoteAddr))
        }</span>

        <span class="cov3" title="8">if len(fields) &gt; 0 </span><span class="cov2" title="6">{
                logger = logger.With(fields...)
        }</span>

        <span class="cov3" title="8">return logger</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">// Package metrics defines standardized metrics names, labels, and helper functions for MCP components.
package metrics

// StandardMetrics defines common metrics names and labels for MCP components.
const (
        // Namespace for all MCP metrics.
        Namespace = "mcp"

        // Subsystems.
        SubsystemRouter  = "router"
        SubsystemGateway = "gateway"

        // Common metric names.
        MetricRequestsTotal          = "requests_total"
        MetricResponsesTotal         = "responses_total"
        MetricErrorsTotal            = "errors_total"
        MetricRequestDurationSeconds = "request_duration_seconds"
        MetricResponseSizeBytes      = "response_size_bytes"
        MetricActiveConnections      = "active_connections"
        MetricConnectionsTotal       = "connections_total"
        MetricConnectionRetries      = "connection_retries_total"
        MetricAuthFailures           = "auth_failures_total"
        MetricRateLimitExceeded      = "rate_limit_exceeded_total"
        MetricConnectionErrors       = "connection_errors_total"
        MetricWebsocketMessages      = "websocket_messages_total"

        // Common labels.
        LabelMethod    = "method"
        LabelStatus    = "status"
        LabelErrorType = "error_type"
        LabelState     = "state"
        LabelDirection = "direction"
        LabelType      = "type"
        LabelNamespace = "namespace"
        LabelBackend   = "backend"
        LabelProtocol  = "protocol"
        LabelAuthType  = "auth_type"

        // Status values.
        StatusSuccess = "success"
        StatusError   = "error"
        StatusTimeout = "timeout"

        // State values.
        StateActive = "active"
        StateIdle   = "idle"
        StateError  = "error"

        // Direction values.
        DirectionIn  = "in"
        DirectionOut = "out"

        // Type values.
        TypeRequest  = "request"
        TypeResponse = "response"
)

// MetricName generates a fully qualified metric name.
func MetricName(subsystem, metric string) string <span class="cov10" title="19">{
        return Namespace + "_" + subsystem + "_" + metric
}</span>

// RouterMetric generates a router-specific metric name.
func RouterMetric(metric string) string <span class="cov6" title="6">{
        return MetricName(SubsystemRouter, metric)
}</span>

// GatewayMetric generates a gateway-specific metric name.
func GatewayMetric(metric string) string <span class="cov6" title="6">{
        return MetricName(SubsystemGateway, metric)
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">// Package optimization provides performance optimization utilities
package optimization

import (
        "bytes"
        "sync"
)

// BufferPool provides a pool of reusable byte buffers.
type BufferPool struct {
        pool sync.Pool
}

// NewBufferPool creates a new buffer pool.
func NewBufferPool() *BufferPool <span class="cov1" title="4">{
        return &amp;BufferPool{
                pool: sync.Pool{
                        New: func() interface{} </span><span class="cov3" title="45">{
                                return new(bytes.Buffer)
                        }</span>,
                },
        }
}

// Get retrieves a buffer from the pool.
func (p *BufferPool) Get() *bytes.Buffer <span class="cov6" title="5104">{
        buf, ok := p.pool.Get().(*bytes.Buffer)
        if !ok </span><span class="cov0" title="0">{
                // This should never happen if the pool is used correctly
                return &amp;bytes.Buffer{}
        }</span>

        <span class="cov6" title="5104">buf.Reset()

        return buf</span>
}

// Put returns a buffer to the pool.
func (p *BufferPool) Put(buf *bytes.Buffer) <span class="cov6" title="5105">{
        if buf.Cap() &gt; 1024*1024 </span><span class="cov1" title="2">{ // Don't pool buffers larger than 1MB
                return
        }</span>

        <span class="cov6" title="5102">buf.Reset()
        p.pool.Put(buf)</span>
}

// ByteSlicePool provides a pool of reusable byte slices.
type ByteSlicePool struct {
        pools map[int]*sync.Pool
        mu    sync.RWMutex
}

// NewByteSlicePool creates a new byte slice pool.
func NewByteSlicePool() *ByteSlicePool <span class="cov1" title="4">{
        return &amp;ByteSlicePool{
                pools: make(map[int]*sync.Pool),
                mu:    sync.RWMutex{}, // Initialize mutex explicitly
        }
}</span>

// Get retrieves a byte slice of the specified size.
func (p *ByteSlicePool) Get(size int) []byte <span class="cov5" title="2117">{
        // Round up to nearest power of 2
        poolSize := 1
        for poolSize &lt; size </span><span class="cov7" title="19271">{
                poolSize *= 2
        }</span>

        <span class="cov5" title="2117">p.mu.RLock()
        pool, exists := p.pools[poolSize]
        p.mu.RUnlock()

        if !exists </span><span class="cov3" title="59">{
                p.mu.Lock()

                pool, exists = p.pools[poolSize]
                if !exists </span><span class="cov2" title="20">{
                        pool = &amp;sync.Pool{
                                New: func() interface{} </span><span class="cov3" title="96">{
                                        buf := make([]byte, poolSize)

                                        return &amp;buf
                                }</span>,
                        }
                        <span class="cov2" title="20">p.pools[poolSize] = pool</span>
                }

                <span class="cov3" title="59">p.mu.Unlock()</span>
        }

        <span class="cov5" title="2117">bufPtr, ok := pool.Get().(*[]byte)
        if !ok || bufPtr == nil </span><span class="cov0" title="0">{
                // This should never happen if the pool is used correctly
                return make([]byte, size)
        }</span>

        <span class="cov5" title="2117">return (*bufPtr)[:size]</span>
}

// Put returns a byte slice to the pool.
func (p *ByteSlicePool) Put(buf []byte) <span class="cov5" title="2114">{
        size := cap(buf)
        if size == 0 || size &gt; 1024*1024 </span><span class="cov1" title="2">{ // Don't pool empty or very large slices
                return
        }</span>

        // Find the appropriate pool
        <span class="cov5" title="2112">poolSize := 1
        for poolSize &lt; size </span><span class="cov7" title="19226">{
                poolSize *= 2
        }</span>

        <span class="cov5" title="2112">p.mu.RLock()
        pool, exists := p.pools[poolSize]
        p.mu.RUnlock()

        if exists </span><span class="cov5" title="2112">{
                // Clear the slice before returning to pool
                for i := range buf </span><span class="cov10" title="1756187">{
                        buf[i] = 0
                }</span>

                // Resize to pool size if needed
                <span class="cov5" title="2112">if cap(buf) &gt; poolSize </span><span class="cov0" title="0">{
                        buf = buf[:poolSize]
                }</span>

                <span class="cov5" title="2112">pool.Put(&amp;buf)</span>
        }
}

// ObjectPool provides a generic object pool.
type ObjectPool[T any] struct {
        pool sync.Pool
        new  func() T
}

// NewObjectPool creates a new object pool.
func NewObjectPool[T any](newFunc func() T) *ObjectPool[T] <span class="cov1" title="4">{
        return &amp;ObjectPool[T]{
                pool: sync.Pool{
                        New: func() interface{} </span><span class="cov2" title="6">{
                                return newFunc()
                        }</span>,
                },
                new: newFunc,
        }
}

// Get retrieves an object from the pool.
//
//nolint:ireturn // Generic type parameter T is not an interface, it's a type constraint
func (p *ObjectPool[T]) Get() T <span class="cov2" title="18">{
        obj, ok := p.pool.Get().(T)
        if !ok </span><span class="cov0" title="0">{
                // This should never happen if the pool is used correctly
                return p.new()
        }</span>

        <span class="cov2" title="17">return obj</span>
}

// Put returns an object to the pool.
func (p *ObjectPool[T]) Put(obj T) <span class="cov2" title="15">{
        p.pool.Put(obj)
}</span>

// ConnectionPool manages a pool of reusable connections.
type ConnectionPool[T any] struct {
        pool      chan T
        factory   func() (T, error)
        reset     func(T) error
        closeFunc func(T) error
        maxSize   int
        mu        sync.Mutex
        closed    bool
}

// NewConnectionPool creates a new connection pool.
func NewConnectionPool[T any](
        maxSize int,
        factory func() (T, error),
        reset func(T) error,
        closeFunc func(T) error,
) *ConnectionPool[T] <span class="cov2" title="13">{
        return &amp;ConnectionPool[T]{
                pool:      make(chan T, maxSize),
                factory:   factory,
                reset:     reset,
                closeFunc: closeFunc,
                maxSize:   maxSize,
                mu:        sync.Mutex{}, // Initialize mutex explicitly
                closed:    false,        // Initialize closed state explicitly
        }
}</span>

// Get retrieves a connection from the pool.
//
//nolint:ireturn // Generic type parameter T is not an interface, it's a type constraint
func (p *ConnectionPool[T]) Get() (T, error) <span class="cov5" title="626">{
        p.mu.Lock()

        if p.closed </span><span class="cov1" title="2">{
                p.mu.Unlock()

                var zero T

                return zero, ErrPoolClosed
        }</span>

        <span class="cov5" title="624">p.mu.Unlock()

        select </span>{
        case conn := &lt;-p.pool:<span class="cov4" title="578">
                // Reset the connection before returning
                if err := p.reset(conn); err != nil </span><span class="cov1" title="2">{
                        // Connection is bad, create a new one
                        return p.factory()
                }</span>

                <span class="cov4" title="576">return conn, nil</span>
        default:<span class="cov3" title="46">
                // Pool is empty, create a new connection
                return p.factory()</span>
        }
}

// Put returns a connection to the pool.
func (p *ConnectionPool[T]) Put(conn T) error <span class="cov5" title="624">{
        p.mu.Lock()

        if p.closed </span><span class="cov1" title="2">{
                p.mu.Unlock()

                return p.closeFunc(conn)
        }</span>

        <span class="cov5" title="622">p.mu.Unlock()

        select </span>{
        case p.pool &lt;- conn:<span class="cov5" title="598">
                return nil</span>
        default:<span class="cov2" title="24">
                // Pool is full, close the connection
                return p.closeFunc(conn)</span>
        }
}

// Close closes all connections in the pool.
func (p *ConnectionPool[T]) Close() error <span class="cov2" title="7">{
        p.mu.Lock()

        if p.closed </span><span class="cov1" title="1">{
                p.mu.Unlock()

                return nil
        }</span>

        <span class="cov2" title="6">p.closed = true

        p.mu.Unlock()

        close(p.pool)

        var lastErr error

        for conn := range p.pool </span><span class="cov2" title="13">{
                if err := p.closeFunc(conn); err != nil </span><span class="cov1" title="2">{
                        lastErr = err
                }</span>
        }

        <span class="cov2" title="6">return lastErr</span>
}

// Size returns the current number of connections in the pool.
func (p *ConnectionPool[T]) Size() int <span class="cov1" title="3">{
        return len(p.pool)
}</span>

// ErrPoolClosed is returned when operating on a closed pool.
var ErrPoolClosed = &amp;poolError{"pool is closed"}

type poolError struct {
        msg string
}

func (e *poolError) Error() string <span class="cov1" title="1">{
        return e.msg
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">// Package slo provides utilities for calculating SLI/SLO metrics
package slo

import (
        "context"
        "fmt"
        "time"

        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promauto"
)

const (
        // Time constants for burn rate calculations.
        hoursIn6     = 6
        hoursIn24    = 24
        hoursIn7Days = 7 * 24
        daysInMonth  = 30

        // SLI thresholds.
        defaultSLI = 0.999
        lowSLI     = 0.8
)

// Config defines configuration for an SLO.
type Config struct {
        Name        string
        Target      float64
        Window      time.Duration
        BurnRates   []BurnRateConfig
        AlertConfig AlertConfig
}

// BurnRateConfig defines burn rate alert thresholds.
type BurnRateConfig struct {
        Window    time.Duration
        Threshold float64
        Severity  string
}

// AlertConfig defines alerting configuration.
type AlertConfig struct {
        PageBurnRate   float64 // e.g., 14.4 for 2% in 1 hour
        TicketBurnRate float64 // e.g., 3 for 10% in 24 hours
}

// Calculator calculates SLI/SLO metrics.
type Calculator struct {
        config  Config
        metrics *sloMetrics
}

type sloMetrics struct {
        sliValue          prometheus.Gauge
        errorBudget       prometheus.Gauge
        burnRate1h        prometheus.Gauge
        burnRate6h        prometheus.Gauge
        burnRate24h       prometheus.Gauge
        burnRate7d        prometheus.Gauge
        violations        prometheus.Counter
        budgetExhausted   prometheus.Gauge
        measurementTotal  prometheus.Counter
        measurementErrors prometheus.Counter
}

var (
        // Global metric vectors to avoid duplicate registration.
        sliValueVec = promauto.NewGaugeVec(prometheus.GaugeOpts{
                Name:        "slo_sli_value",
                Help:        "Current SLI value",
                Namespace:   "",  // Empty namespace
                Subsystem:   "",  // Empty subsystem
                ConstLabels: nil, // No constant labels
        }, []string{"slo_name"})

        errorBudgetVec = promauto.NewGaugeVec(prometheus.GaugeOpts{
                Name:        "slo_error_budget_ratio",
                Help:        "Remaining error budget ratio",
                Namespace:   "",  // Empty namespace
                Subsystem:   "",  // Empty subsystem
                ConstLabels: nil, // No constant labels
        }, []string{"slo_name"})

        burnRate1hVec = promauto.NewGaugeVec(prometheus.GaugeOpts{
                Name:        "slo_burn_rate_1h",
                Help:        "Error budget burn rate over 1 hour",
                Namespace:   "",  // Empty namespace
                Subsystem:   "",  // Empty subsystem
                ConstLabels: nil, // No constant labels
        }, []string{"slo_name"})

        burnRate6hVec = promauto.NewGaugeVec(prometheus.GaugeOpts{
                Name:        "slo_burn_rate_6h",
                Help:        "Error budget burn rate over 6 hours",
                Namespace:   "",  // Empty namespace
                Subsystem:   "",  // Empty subsystem
                ConstLabels: nil, // No constant labels
        }, []string{"slo_name"})

        burnRate24hVec = promauto.NewGaugeVec(prometheus.GaugeOpts{
                Name:        "slo_burn_rate_24h",
                Help:        "Error budget burn rate over 24 hours",
                Namespace:   "",  // Empty namespace
                Subsystem:   "",  // Empty subsystem
                ConstLabels: nil, // No constant labels
        }, []string{"slo_name"})

        burnRate7dVec = promauto.NewGaugeVec(prometheus.GaugeOpts{
                Name:        "slo_burn_rate_7d",
                Help:        "Error budget burn rate over 7 days",
                Namespace:   "",  // Empty namespace
                Subsystem:   "",  // Empty subsystem
                ConstLabels: nil, // No constant labels
        }, []string{"slo_name"})

        violationsVec = promauto.NewCounterVec(prometheus.CounterOpts{
                Name:        "slo_violations_total",
                Help:        "Total number of SLO violations",
                Namespace:   "",  // Empty namespace
                Subsystem:   "",  // Empty subsystem
                ConstLabels: nil, // No constant labels
        }, []string{"slo_name"})

        budgetExhaustedVec = promauto.NewGaugeVec(prometheus.GaugeOpts{
                Name:        "slo_budget_exhausted",
                Help:        "Whether error budget is exhausted (1) or not (0)",
                Namespace:   "",  // Empty namespace
                Subsystem:   "",  // Empty subsystem
                ConstLabels: nil, // No constant labels
        }, []string{"slo_name"})

        measurementTotalVec = promauto.NewCounterVec(prometheus.CounterOpts{
                Name:        "slo_measurements_total",
                Help:        "Total number of SLI measurements",
                Namespace:   "",  // Empty namespace
                Subsystem:   "",  // Empty subsystem
                ConstLabels: nil, // No constant labels
        }, []string{"slo_name"})

        measurementErrorsVec = promauto.NewCounterVec(prometheus.CounterOpts{
                Name:        "slo_measurement_errors_total",
                Help:        "Total number of failed SLI measurements",
                Namespace:   "",  // Empty namespace
                Subsystem:   "",  // Empty subsystem
                ConstLabels: nil, // No constant labels
        }, []string{"slo_name"})
)

// NewCalculator creates a new SLO calculator.
func NewCalculator(config Config) *Calculator <span class="cov4" title="19">{
        metrics := &amp;sloMetrics{
                sliValue:          sliValueVec.WithLabelValues(config.Name),
                errorBudget:       errorBudgetVec.WithLabelValues(config.Name),
                burnRate1h:        burnRate1hVec.WithLabelValues(config.Name),
                burnRate6h:        burnRate6hVec.WithLabelValues(config.Name),
                burnRate24h:       burnRate24hVec.WithLabelValues(config.Name),
                burnRate7d:        burnRate7dVec.WithLabelValues(config.Name),
                violations:        violationsVec.WithLabelValues(config.Name),
                budgetExhausted:   budgetExhaustedVec.WithLabelValues(config.Name),
                measurementTotal:  measurementTotalVec.WithLabelValues(config.Name),
                measurementErrors: measurementErrorsVec.WithLabelValues(config.Name),
        }

        return &amp;Calculator{
                config:  config,
                metrics: metrics,
        }
}</span>

// RecordSuccess records a successful SLI measurement.
func (c *Calculator) RecordSuccess(ctx context.Context) <span class="cov9" title="3173">{
        c.recordMeasurement(ctx, true)
}</span>

// RecordFailure records a failed SLI measurement.
func (c *Calculator) RecordFailure(ctx context.Context) <span class="cov4" title="27">{
        c.recordMeasurement(ctx, false)
}</span>

// RecordValue records an SLI value directly (e.g., latency).
func (c *Calculator) RecordValue(_ context.Context, value float64) <span class="cov2" title="3">{
        c.metrics.measurementTotal.Inc()

        // For latency SLOs, success is when value is below target
        success := value &lt;= c.config.Target
        c.updateMetrics(success)

        // Record the actual value
        c.metrics.sliValue.Set(value)
}</span>

func (c *Calculator) recordMeasurement(_ context.Context, success bool) <span class="cov9" title="3200">{
        c.metrics.measurementTotal.Inc()

        if !success </span><span class="cov4" title="27">{
                c.metrics.measurementErrors.Inc()
        }</span>

        <span class="cov9" title="3200">c.updateMetrics(success)</span>
}

func (c *Calculator) updateMetrics(success bool) <span class="cov10" title="3203">{
        // Update SLI value (1.0 for success, 0.0 for failure)
        sliValue := 0.0
        if success </span><span class="cov9" title="3175">{
                sliValue = 1.0
        }</span>

        <span class="cov10" title="3203">c.metrics.sliValue.Set(sliValue)

        // Check for violation
        if sliValue &lt; c.config.Target </span><span class="cov4" title="28">{
                c.metrics.violations.Inc()
        }</span>
        // Note: Burn rate calculations would typically be done by Prometheus
        // recording rules based on the rate of violations over time windows
} 

// CalculateErrorBudget calculates the remaining error budget.
func (c *Calculator) CalculateErrorBudget(currentSLI float64) float64 <span class="cov3" title="12">{
        if c.config.Target == 1.0 </span><span class="cov1" title="2">{
                // Special case: 100% target means any failure exhausts budget
                if currentSLI &lt; 1.0 </span><span class="cov1" title="1">{
                        return 0.0
                }</span>

                <span class="cov1" title="1">return 1.0</span>
        }

        // If we're at or above the target, we have full budget
        <span class="cov3" title="10">if currentSLI &gt;= c.config.Target </span><span class="cov3" title="7">{
                return 1.0
        }</span>

        // Error budget = 1 - (actual_error_rate / allowed_error_rate)
        <span class="cov2" title="3">allowedErrorRate := 1.0 - c.config.Target
        actualErrorRate := 1.0 - currentSLI

        if actualErrorRate &gt;= allowedErrorRate </span><span class="cov2" title="3">{
                return 0.0 // Budget exhausted
        }</span>

        <span class="cov0" title="0">return 1.0 - (actualErrorRate / allowedErrorRate)</span>
}

// CalculateBurnRate calculates the burn rate for a given window.
func (c *Calculator) CalculateBurnRate(errorRate float64, window time.Duration) float64 <span class="cov3" title="8">{
        // Burn rate = (error_rate_in_window / allowed_error_rate) * (month / window)
        allowedErrorRate := 1.0 - c.config.Target
        if allowedErrorRate == 0 </span><span class="cov1" title="1">{
                return 0 // 100% SLO target
        }</span>

        <span class="cov3" title="7">monthHours := float64(daysInMonth * hoursIn24)
        windowHours := window.Hours()

        return (errorRate / allowedErrorRate) * (monthHours / windowHours)</span>
}

// UpdateErrorBudget updates the error budget metric.
func (c *Calculator) UpdateErrorBudget(currentSLI float64) <span class="cov2" title="5">{
        budget := c.CalculateErrorBudget(currentSLI)
        c.metrics.errorBudget.Set(budget)

        // Update exhausted flag
        if budget &lt;= 0 </span><span class="cov1" title="2">{
                c.metrics.budgetExhausted.Set(1)
        }</span> else<span class="cov2" title="3"> {
                c.metrics.budgetExhausted.Set(0)
        }</span>
}

// UpdateBurnRates updates burn rate metrics based on error rates over different windows.
func (c *Calculator) UpdateBurnRates(errorRate1h, errorRate6h, errorRate24h, errorRate7d float64) <span class="cov1" title="1">{
        c.metrics.burnRate1h.Set(c.CalculateBurnRate(errorRate1h, time.Hour))
        c.metrics.burnRate6h.Set(c.CalculateBurnRate(errorRate6h, hoursIn6*time.Hour))
        c.metrics.burnRate24h.Set(c.CalculateBurnRate(errorRate24h, hoursIn24*time.Hour))
        c.metrics.burnRate7d.Set(c.CalculateBurnRate(errorRate7d, hoursIn7Days*time.Hour))
}</span>

// GetMetrics returns the current metrics for external monitoring.
func (c *Calculator) GetMetrics() Metrics <span class="cov3" title="13">{
        return Metrics{
                Name:            c.config.Name,
                Target:          c.config.Target,
                CurrentSLI:      c.getCurrentSLI(),
                ErrorBudget:     c.getCurrentErrorBudget(),
                BurnRate1h:      c.getBurnRate1h(),
                BurnRate6h:      c.getBurnRate6h(),
                BurnRate24h:     c.getBurnRate24h(),
                BurnRate7d:      c.getBurnRate7d(),
                BudgetExhausted: c.isBudgetExhausted(),
        }
}</span>

// Metrics represents current SLO metrics.
type Metrics struct {
        Name            string
        Target          float64
        CurrentSLI      float64
        ErrorBudget     float64
        BurnRate1h      float64
        BurnRate6h      float64
        BurnRate24h     float64
        BurnRate7d      float64
        BudgetExhausted bool
}

// Helper methods to get current metric values.
func (c *Calculator) getCurrentSLI() float64 <span class="cov3" title="13">{
        // This would typically query Prometheus, but for now return a placeholder
        return defaultSLI
}</span>

func (c *Calculator) getCurrentErrorBudget() float64 <span class="cov3" title="13">{
        // This would typically query Prometheus, but for now return a placeholder
        return lowSLI
}</span>

func (c *Calculator) getBurnRate1h() float64 <span class="cov3" title="13">{
        // This would typically query Prometheus, but for now return a placeholder
        return 1.0
}</span>

func (c *Calculator) getBurnRate6h() float64 <span class="cov3" title="13">{
        // This would typically query Prometheus, but for now return a placeholder
        return 1.0
}</span>

func (c *Calculator) getBurnRate24h() float64 <span class="cov3" title="13">{
        // This would typically query Prometheus, but for now return a placeholder
        return 1.0
}</span>

func (c *Calculator) getBurnRate7d() float64 <span class="cov3" title="13">{
        // This would typically query Prometheus, but for now return a placeholder
        return 1.0
}</span>

func (c *Calculator) isBudgetExhausted() bool <span class="cov3" title="13">{
        // This would typically query Prometheus, but for now return a placeholder
        return false
}</span>

// FormatBurnRateAlert formats a burn rate alert message.
func FormatBurnRateAlert(sloName string, burnRate1h, burnRate6h float64) string <span class="cov1" title="1">{
        return fmt.Sprintf(
                "SLO '%s' error budget burn rate is too high\n"+
                        "1h burn rate: %.2fx normal\n"+
                        "6h burn rate: %.2fx normal\n"+
                        "At this rate, the monthly error budget will be exhausted soon.",
                sloName, burnRate1h, burnRate6h,
        )
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">// Package tracing provides common tracing utilities for MCP Bridge components.
package tracing

import (
        "context"
        "fmt"
        "net/http"

        "github.com/gorilla/websocket"
        "go.opentelemetry.io/otel/attribute"
        "go.opentelemetry.io/otel/trace"
)

// WebSocketSpanAttributes creates standard OpenTelemetry attributes for WebSocket connections.
func WebSocketSpanAttributes(request *http.Request, remoteAddr string) []attribute.KeyValue <span class="cov8" title="3">{
        attrs := []attribute.KeyValue{
                attribute.String("net.transport", "websocket"),
                attribute.String("net.peer.ip", remoteAddr),
                attribute.String("http.scheme", "ws"),
                attribute.String("http.method", request.Method),
                attribute.String("http.target", request.URL.Path),
                attribute.String("http.host", request.Host),
                attribute.String("http.user_agent", request.UserAgent()),
        }

        // Add protocol headers if present
        if proto := request.Header.Get("Sec-WebSocket-Protocol"); proto != "" </span><span class="cov1" title="1">{
                attrs = append(attrs, attribute.String("websocket.protocol", proto))
        }</span>

        <span class="cov8" title="3">if version := request.Header.Get("Sec-WebSocket-Version"); version != "" </span><span class="cov1" title="1">{
                attrs = append(attrs, attribute.String("websocket.version", version))
        }</span>

        <span class="cov8" title="3">return attrs</span>
}

// MCPMessageAttributes creates OpenTelemetry attributes for MCP protocol messages.
func MCPMessageAttributes(msgType, method string, id interface{}) []attribute.KeyValue <span class="cov10" title="4">{
        attrs := []attribute.KeyValue{
                attribute.String("mcp.message.type", msgType),
        }

        if method != "" </span><span class="cov5" title="2">{
                attrs = append(attrs, attribute.String("mcp.method", method))
        }</span>

        <span class="cov10" title="4">if id != nil </span><span class="cov5" title="2">{
                attrs = append(attrs, attribute.String("mcp.message.id", fmt.Sprintf("%v", id)))
        }</span>

        <span class="cov10" title="4">return attrs</span>
}

// WebSocketMessageEvent records a WebSocket message event in the current span.
func WebSocketMessageEvent(ctx context.Context, direction string, messageType, size int) <span class="cov8" title="3">{
        span := trace.SpanFromContext(ctx)
        if span == nil || !span.IsRecording() </span><span class="cov8" title="3">{
                return
        }</span>

        <span class="cov0" title="0">msgTypeStr := "text"
        if messageType == websocket.BinaryMessage </span><span class="cov0" title="0">{
                msgTypeStr = "binary"
        }</span>

        <span class="cov0" title="0">span.AddEvent("websocket.message."+direction,
                trace.WithAttributes(
                        attribute.String("websocket.message.type", msgTypeStr),
                        attribute.Int("websocket.message.size", size),
                ),
        )</span>
}

// ConnectionPoolAttributes creates attributes for connection pool operations.
func ConnectionPoolAttributes(poolType string, size, active, idle int) []attribute.KeyValue <span class="cov8" title="3">{
        return []attribute.KeyValue{
                attribute.String("pool.type", poolType),
                attribute.Int("pool.size", size),
                attribute.Int("pool.connections.active", active),
                attribute.Int("pool.connections.idle", idle),
        }
}</span>

// GatewayRouteAttributes creates attributes for gateway routing decisions.
func GatewayRouteAttributes(serviceName, targetHost string, targetPort int) []attribute.KeyValue <span class="cov5" title="2">{
        return []attribute.KeyValue{
                attribute.String("gateway.service", serviceName),
                attribute.String("gateway.target.host", targetHost),
                attribute.Int("gateway.target.port", targetPort),
        }
}</span>

// AuthenticationAttributes creates attributes for authentication operations.
func AuthenticationAttributes(authType string, success bool, userID string) []attribute.KeyValue <span class="cov8" title="3">{
        attrs := []attribute.KeyValue{
                attribute.String("auth.type", authType),
                attribute.Bool("auth.success", success),
        }

        if userID != "" </span><span class="cov5" title="2">{
                attrs = append(attrs, attribute.String("auth.user.id", userID))
        }</span>

        <span class="cov8" title="3">return attrs</span>
}

// ErrorAttributes creates attributes from an error.
func ErrorAttributes(err error) []attribute.KeyValue <span class="cov8" title="3">{
        if err == nil </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov5" title="2">return []attribute.KeyValue{
                attribute.Bool("error", true),
                attribute.String("error.type", fmt.Sprintf("%T", err)),
                attribute.String("error.message", err.Error()),
        }</span>
}

// RateLimitAttributes creates attributes for rate limiting operations.
func RateLimitAttributes(limited bool, limit, remaining int, resetTime int64) []attribute.KeyValue <span class="cov5" title="2">{
        return []attribute.KeyValue{
                attribute.Bool("ratelimit.limited", limited),
                attribute.Int("ratelimit.limit", limit),
                attribute.Int("ratelimit.remaining", remaining),
                attribute.Int64("ratelimit.reset_time", resetTime),
        }
}</span>

// HealthCheckAttributes creates attributes for health check operations.
func HealthCheckAttributes(checkType string, healthy bool, latencyMs int64) []attribute.KeyValue <span class="cov8" title="3">{
        return []attribute.KeyValue{
                attribute.String("health.check.type", checkType),
                attribute.Bool("health.check.healthy", healthy),
                attribute.Int64("health.check.latency_ms", latencyMs),
        }
}</span>

// CircuitBreakerAttributes creates attributes for circuit breaker state changes.
func CircuitBreakerAttributes(state string, failures, successes int) []attribute.KeyValue <span class="cov8" title="3">{
        return []attribute.KeyValue{
                attribute.String("circuitbreaker.state", state),
                attribute.Int("circuitbreaker.failures", failures),
                attribute.Int("circuitbreaker.successes", successes),
        }
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">// Package integration provides Docker-based integration testing utilities for MCP services.
//
// Integration utilities allow flexible style
//

package integration

import (
        "context"
        "fmt"
        "net"
        "net/http"
        "os/exec"
        "strings"
        "testing"
        "time"

        "go.uber.org/zap"
)

const (
        // Network timeouts.
        httpClientTimeout        = 5 * time.Second
        healthCheckRetryInterval = 2 * time.Second

        // HTTP status codes.
        httpStatusServerError = 500
)

// DockerStack manages the Docker Compose services for integration testing.
type DockerStack struct {
        t           *testing.T
        logger      *zap.Logger
        composeDir  string
        composeFile string
        services    map[string]string
        cleanup     []func()
}

// NewDockerStack creates a new Docker stack manager for integration tests.
func NewDockerStack(t *testing.T) *DockerStack <span class="cov1" title="1">{
        t.Helper()

        logger, err := zap.NewDevelopment()
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to create logger: %v", err)
        }</span>

        <span class="cov1" title="1">return &amp;DockerStack{
                t:           t,
                logger:      logger,
                composeDir:  ".",
                composeFile: "docker-compose.test.yml",
                services:    make(map[string]string),
                cleanup:     make([]func(), 0),
        }</span>
}

// SetComposeFile sets the Docker Compose file to use.
func (ds *DockerStack) SetComposeFile(file string) <span class="cov1" title="1">{
        ds.composeFile = file
}</span>

// SetComposeDir sets the directory containing the Docker Compose file.
func (ds *DockerStack) SetComposeDir(dir string) <span class="cov1" title="1">{
        ds.composeDir = dir
}</span>

// StartServices starts all services defined in the compose file.
func (ds *DockerStack) StartServices() error <span class="cov1" title="1">{
        ds.logger.Info("Starting Docker services",
                zap.String("compose_file", ds.composeFile),
                zap.String("compose_dir", ds.composeDir))

        //nolint:gosec // Test environment
        cmd := exec.CommandContext(context.Background(), "docker-compose", "-f", ds.composeFile, "up", "-d")
        cmd.Dir = ds.composeDir

        output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                ds.logger.Error("Failed to start services",
                        zap.Error(err),
                        zap.String("output", string(output)),
                        zap.String("working_dir", cmd.Dir),
                        zap.String("compose_file", ds.composeFile))

                return fmt.Errorf("failed to start Docker services: %w", err)
        }</span>

        <span class="cov1" title="1">ds.logger.Info("Docker services started")
        ds.addCleanup(func() </span><span class="cov1" title="1">{
                _ = ds.StopServices()
        }</span>)

        <span class="cov1" title="1">return nil</span>
}

// StopServices stops all running services.
func (ds *DockerStack) StopServices() error <span class="cov1" title="1">{
        //nolint:gosec // Test environment
        cmd := exec.CommandContext(context.Background(), "docker-compose", "-f", ds.composeFile, "down", "-v")
        cmd.Dir = ds.composeDir

        output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                ds.logger.Error("Failed to stop services", zap.Error(err), zap.String("output", string(output)))

                return fmt.Errorf("failed to stop Docker services: %w", err)
        }</span>

        <span class="cov1" title="1">ds.logger.Info("Docker services stopped")

        return nil</span>
}

// WaitForService waits for a service to become healthy.
func (ds *DockerStack) WaitForService(serviceName, healthURL string, timeout time.Duration) error <span class="cov1" title="1">{
        client := &amp;http.Client{Timeout: httpClientTimeout}
        deadline := time.Now().Add(timeout)

        for time.Now().Before(deadline) </span><span class="cov10" title="2">{
                req, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, healthURL, nil)

                resp, err := client.Do(req)
                if err == nil </span><span class="cov1" title="1">{
                        _ = resp.Body.Close()

                        if resp.StatusCode &lt; httpStatusServerError </span><span class="cov1" title="1">{
                                ds.logger.Info("Service became healthy", zap.String("service", serviceName))

                                return nil
                        }</span>
                }

                <span class="cov1" title="1">ds.logger.Debug("Waiting for service",
                        zap.String("service", serviceName),
                        zap.String("url", healthURL),
                        zap.Error(err))

                time.Sleep(healthCheckRetryInterval)</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("service %s did not become healthy within %v", serviceName, timeout)</span>
}

// GetServiceURL returns the URL for a service.
func (ds *DockerStack) GetServiceURL(serviceName string) (string, error) <span class="cov0" title="0">{
        if url, exists := ds.services[serviceName]; exists </span><span class="cov0" title="0">{
                return url, nil
        }</span>

        <span class="cov0" title="0">return "", fmt.Errorf("service %s not found", serviceName)</span>
}

// AddService registers a service URL.
func (ds *DockerStack) AddService(name, url string) <span class="cov10" title="2">{
        ds.services[name] = url
}</span>

// RunCommand executes a command in a service container.
func (ds *DockerStack) RunCommand(serviceName string, command ...string) ([]byte, error) <span class="cov0" title="0">{
        args := append([]string{"exec", "-T", serviceName}, command...)
        cmd := exec.CommandContext(context.Background(), "docker-compose", args...) //nolint:gosec // Test environment
        cmd.Dir = ds.composeDir

        output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                ds.logger.Error("Command failed in container",
                        zap.String("service", serviceName),
                        zap.Strings("command", command),
                        zap.Error(err),
                        zap.String("output", string(output)))

                return nil, fmt.Errorf("command failed in container %s: %w", serviceName, err)
        }</span>

        <span class="cov0" title="0">return output, nil</span>
}

// GetContainerLogs retrieves logs from a container.
func (ds *DockerStack) GetContainerLogs(serviceName string) ([]byte, error) <span class="cov0" title="0">{
        //nolint:gosec // Test environment
        cmd := exec.CommandContext(context.Background(), "docker-compose", "-f", ds.composeFile, "logs", serviceName)
        cmd.Dir = ds.composeDir

        return cmd.CombinedOutput()
}</span>

// RestartService restarts a specific service.
func (ds *DockerStack) RestartService(serviceName string) error <span class="cov0" title="0">{
        //nolint:gosec // Test environment
        cmd := exec.CommandContext(context.Background(), "docker-compose", "-f", ds.composeFile, "restart", serviceName)
        cmd.Dir = ds.composeDir

        output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                ds.logger.Error("Failed to restart service",
                        zap.String("service", serviceName),
                        zap.Error(err),
                        zap.String("output", string(output)))

                return fmt.Errorf("failed to restart service %s: %w", serviceName, err)
        }</span>

        <span class="cov0" title="0">ds.logger.Info("Service restarted", zap.String("service", serviceName))

        return nil</span>
}

// ScaleService scales a service to the specified number of replicas.
func (ds *DockerStack) ScaleService(serviceName string, replicas int) error <span class="cov0" title="0">{
        //nolint:gosec // Test environment
        cmd := exec.CommandContext(context.Background(), "docker-compose", "-f", ds.composeFile, "up", "-d", "--scale",
                fmt.Sprintf("%s=%d", serviceName, replicas), serviceName)
        cmd.Dir = ds.composeDir

        output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                ds.logger.Error("Failed to scale service",
                        zap.String("service", serviceName),
                        zap.Int("replicas", replicas),
                        zap.Error(err),
                        zap.String("output", string(output)))

                return fmt.Errorf("failed to scale service %s: %w", serviceName, err)
        }</span>

        <span class="cov0" title="0">ds.logger.Info("Service scaled",
                zap.String("service", serviceName),
                zap.Int("replicas", replicas))

        return nil</span>
}

// IsServiceHealthy checks if a service is currently healthy.
func (ds *DockerStack) IsServiceHealthy(serviceName, healthURL string) bool <span class="cov1" title="1">{
        client := &amp;http.Client{Timeout: httpClientTimeout}

        req, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, healthURL, nil)

        resp, err := client.Do(req)
        if err != nil </span><span class="cov1" title="1">{
                return false
        }</span>

        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = resp.Body.Close() }</span>()

        <span class="cov0" title="0">return resp.StatusCode &lt; httpStatusServerError</span>
}

// WaitForPort waits for a port to become available.
func (ds *DockerStack) WaitForPort(host string, port int, timeout time.Duration) error <span class="cov0" title="0">{
        deadline := time.Now().Add(timeout)
        address := fmt.Sprintf("%s:%d", host, port)

        for time.Now().Before(deadline) </span><span class="cov0" title="0">{
                dialer := &amp;net.Dialer{}

                conn, err := dialer.DialContext(context.Background(), "tcp", address)
                if err == nil </span><span class="cov0" title="0">{
                        _ = conn.Close()

                        ds.logger.Info("Port became available",
                                zap.String("address", address))

                        return nil
                }</span>

                <span class="cov0" title="0">time.Sleep(1 * time.Second)</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("port %s did not become available within %v", address, timeout)</span>
}

// addCleanup adds a cleanup function.
func (ds *DockerStack) addCleanup(cleanup func()) <span class="cov1" title="1">{
        ds.cleanup = append(ds.cleanup, cleanup)
}</span>

// Cleanup performs cleanup of all resources.
func (ds *DockerStack) Cleanup() <span class="cov1" title="1">{
        for i := len(ds.cleanup) - 1; i &gt;= 0; i-- </span><span class="cov1" title="1">{
                ds.cleanup[i]()
        }</span>
}

// NetworkInfo holds information about Docker networks.
type NetworkInfo struct {
        Name   string
        Driver string
        Subnet string
}

// CreateNetwork creates a Docker network for testing.
func (ds *DockerStack) CreateNetwork(info NetworkInfo) error <span class="cov0" title="0">{
        args := []string{"network", "create", "--driver", info.Driver}
        if info.Subnet != "" </span><span class="cov0" title="0">{
                args = append(args, "--subnet", info.Subnet)
        }</span>

        <span class="cov0" title="0">args = append(args, info.Name)

        cmd := exec.CommandContext(context.Background(), "docker", args...) //nolint:gosec // Test environment

        output, err := cmd.CombinedOutput()
        if err != nil &amp;&amp; !strings.Contains(string(output), "already exists") </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create network %s: %w", info.Name, err)
        }</span>

        <span class="cov0" title="0">ds.addCleanup(func() </span><span class="cov0" title="0">{
                _ = ds.RemoveNetwork(info.Name)
        }</span>)

        <span class="cov0" title="0">ds.logger.Info("Network created", zap.String("name", info.Name))

        return nil</span>
}

// RemoveNetwork removes a Docker network.
func (ds *DockerStack) RemoveNetwork(name string) error <span class="cov0" title="0">{
        cmd := exec.CommandContext(context.Background(), "docker", "network", "rm", name)

        output, err := cmd.CombinedOutput()
        if err != nil &amp;&amp; !strings.Contains(string(output), "not found") </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to remove network %s: %w", name, err)
        }</span>

        <span class="cov0" title="0">ds.logger.Info("Network removed", zap.String("name", name))

        return nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">// Package patterns_test demonstrates improved testing patterns for MCP components.
//

package patterns_test

import (
        "context"
        "errors"
        "fmt"
        "os"
        "strconv"
        "sync"
        "sync/atomic"
        "testing"
        "time"

        "github.com/stretchr/testify/suite"
)

// Test timing constants.
const (
        defaultTestTimeout        = 30 * time.Second
        defaultRateLimitTolerance = 50 * time.Millisecond
        defaultTestRetryDelay     = 50 * time.Millisecond
        
        // Test configuration constants.
        defaultRetryCount = 3
        defaultConcurrentWorkers = 10
        defaultPercentMultiplier = 100
        defaultTimeoutMillis = 50
        defaultToleranceLower = 0.8
        defaultToleranceUpper = 1.2
        testTickerInterval = 10 * time.Millisecond
        testRateLimitBurst = 5
        workerSimulationDelay = 100 * time.Millisecond
        workerTimeoutDuration = 5 * time.Second
)

// BaseTestSuite provides consistent test patterns and utilities.
type BaseTestSuite struct {
        suite.Suite
        ctx        context.Context 
        cancel     context.CancelFunc
        timeout    time.Duration
        retryCount int
        resources  []func() error
        mu         sync.Mutex
}

// SetupSuite runs once before all tests in the suite.
func (s *BaseTestSuite) SetupSuite() <span class="cov0" title="0">{
        s.timeout = getEnvDuration("TEST_TIMEOUT", defaultTestTimeout)
        s.retryCount = getEnvInt("TEST_RETRY_COUNT", defaultRetryCount)
        s.resources = make([]func() error, 0)

        s.T().Logf("Test suite setup complete - timeout: %v, retries: %d", s.timeout, s.retryCount)
}</span>

// SetupTest runs before each test.
func (s *BaseTestSuite) SetupTest() <span class="cov0" title="0">{
        s.ctx, s.cancel = context.WithTimeout(context.Background(), s.timeout)
        s.resources = make([]func() error, 0) // Reset resources for each test
}</span>

// TearDownTest runs after each test.
func (s *BaseTestSuite) TearDownTest() <span class="cov0" title="0">{
        // Clean up resources in reverse order
        s.mu.Lock()

        for i := len(s.resources) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                if cleanup := s.resources[i]; cleanup != nil </span><span class="cov0" title="0">{
                        if err := cleanup(); err != nil </span><span class="cov0" title="0">{
                                s.T().Logf("Cleanup error: %v", err)
                        }</span>
                }
        }

        <span class="cov0" title="0">s.resources = nil
        s.mu.Unlock()

        if s.cancel != nil </span><span class="cov0" title="0">{
                s.cancel()
        }</span>
}

// AddCleanup adds a cleanup function to be called during teardown.
func (s *BaseTestSuite) AddCleanup(cleanup func() error) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        s.resources = append(s.resources, cleanup)
}</span>

// WaitForCondition waits for a condition to be true with configurable timeout and retry.
func (s *BaseTestSuite) WaitForCondition(description string, condition func() bool) bool <span class="cov0" title="0">{
        return s.WaitForConditionWithTimeout(description, condition, s.timeout)
}</span>

// WaitForConditionWithTimeout waits for condition with specific timeout.
func (s *BaseTestSuite) WaitForConditionWithTimeout(
        description string, condition func() bool, timeout time.Duration,
) bool <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(s.ctx, timeout)
        defer cancel()

        ticker := time.NewTicker(testTickerInterval)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        s.T().Logf("Condition '%s' not met within timeout %v", description, timeout)

                        return false</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        if condition() </span><span class="cov0" title="0">{
                                s.T().Logf("Condition '%s' met", description)

                                return true
                        }</span>
                }
        }
}

// RetryOperation retries an operation with exponential backoff.
func (s *BaseTestSuite) RetryOperation(description string, operation func() error) error <span class="cov0" title="0">{
        var lastErr error

        backoff := defaultPercentMultiplier * time.Millisecond

        for attempt := range s.retryCount </span><span class="cov0" title="0">{
                if err := operation(); err == nil </span><span class="cov0" title="0">{
                        s.T().Logf("Operation '%s' succeeded on attempt %d", description, attempt+1)

                        return nil
                }</span> else<span class="cov0" title="0"> {
                        lastErr = err
                        s.T().Logf("Operation '%s' failed on attempt %d: %v", description, attempt+1, err)

                        if attempt &lt; s.retryCount-1 </span><span class="cov0" title="0">{
                                time.Sleep(backoff)
                                backoff *= 2 // Exponential backoff
                        }</span>
                }
        }

        <span class="cov0" title="0">return fmt.Errorf("operation '%s' failed after %d attempts: %w", description, s.retryCount, lastErr)</span>
}

// TimingDependentTestSuite provides testing patterns for timing-sensitive tests.
type TimingDependentTestSuite struct {
        BaseTestSuite
        timekeeper *MockTimeKeeper
}

// SetupTest initializes timing-dependent test resources.
func (s *TimingDependentTestSuite) SetupTest() <span class="cov0" title="0">{
        s.BaseTestSuite.SetupTest()
        s.timekeeper = NewMockTimeKeeper()
        s.AddCleanup(func() error </span><span class="cov0" title="0">{
                s.timekeeper = nil

                return nil
        }</span>)
}

// TestRetryLogicImproved demonstrates improved retry testing patterns.
func (s *TimingDependentTestSuite) TestRetryLogicImproved() <span class="cov0" title="0">{
        attemptCount := int64(0)
        maxAttempts := int64(defaultRetryCount)

        operation := func() error </span><span class="cov0" title="0">{
                count := atomic.AddInt64(&amp;attemptCount, 1)
                if count &lt; maxAttempts </span><span class="cov0" title="0">{
                        return errors.New("simulated failure")
                }</span>

                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov0" title="0">err := s.RetryOperation("test operation", operation)
        s.Require().NoError(err)
        s.Equal(maxAttempts, atomic.LoadInt64(&amp;attemptCount))</span>
}

// TestRateLimitingPatterns demonstrates improved rate limiting testing.
func (s *TimingDependentTestSuite) TestRateLimitingPatterns() <span class="cov0" title="0">{
        const requestsPerSecond = 10

        const testDuration = 1 * time.Second

        rateLimiter := NewMockRateLimiter(requestsPerSecond)
        successfulRequests := 0

        startTime := time.Now()

        for range 20 </span><span class="cov0" title="0">{ // Try to make 20 requests
                if rateLimiter.Allow() </span><span class="cov0" title="0">{
                        successfulRequests++
                }</span>

                <span class="cov0" title="0">time.Sleep(defaultTestRetryDelay)</span>
        }

        <span class="cov0" title="0">elapsed := time.Since(startTime)

        // Allow some tolerance for timing variations
        minExpected := int(float64(requestsPerSecond) * defaultToleranceLower)
        maxExpected := int(float64(requestsPerSecond) * defaultToleranceUpper)

        s.GreaterOrEqual(successfulRequests, minExpected)
        s.LessOrEqual(successfulRequests, maxExpected)
        s.WithinDuration(startTime.Add(testDuration), startTime.Add(elapsed), defaultRateLimitTolerance)</span>
}

// ResourceCleanupTestSuite provides testing patterns for resource cleanup.
type ResourceCleanupTestSuite struct {
        BaseTestSuite
        tempFiles []string
        mu        sync.Mutex
}

// TestFileResourceCleanup demonstrates proper file resource cleanup.
func (s *ResourceCleanupTestSuite) TestFileResourceCleanup() <span class="cov0" title="0">{
        filename := s.createTempFile("test-content")

        // Register cleanup
        s.AddCleanup(func() error </span><span class="cov0" title="0">{
                if err := os.Remove(filename); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to remove temp file %s: %w", filename, err)
                }</span>

                <span class="cov0" title="0">return nil</span>
        })

        // Use the file
        <span class="cov0" title="0">content, err := os.ReadFile(filename) //nolint:gosec // Test file reading 
        s.Require().NoError(err)
        s.Equal("test-content", string(content))</span>
}

// TestConcurrentResourceCleanup demonstrates concurrent resource cleanup patterns.
func (s *ResourceCleanupTestSuite) TestConcurrentResourceCleanup() <span class="cov0" title="0">{
        const numWorkers = 5

        var wg sync.WaitGroup

        workerStopped := make(chan struct{})

        // Start workers
        for i := range numWorkers </span><span class="cov0" title="0">{
                wg.Add(1)

                go func(workerID int) </span><span class="cov0" title="0">{
                        defer wg.Done()

                        filename := s.createTempFile(fmt.Sprintf("worker-%d-content", workerID))

                        // Register cleanup for this worker's resources
                        s.AddCleanup(func() error </span><span class="cov0" title="0">{
                                return os.Remove(filename)
                        }</span>)

                        // Simulate work
                        <span class="cov0" title="0">time.Sleep(workerSimulationDelay)</span>
                }(i)
        }

        // Register cleanup to wait for all workers
        <span class="cov0" title="0">s.AddCleanup(func() error </span><span class="cov0" title="0">{
                go func() </span><span class="cov0" title="0">{
                        wg.Wait()
                        close(workerStopped)
                }</span>()

                <span class="cov0" title="0">select </span>{
                case &lt;-workerStopped:<span class="cov0" title="0">
                        return nil</span>
                case &lt;-time.After(workerTimeoutDuration):<span class="cov0" title="0">
                        return errors.New("timeout waiting for workers to complete")</span>
                }
        })

        // Wait for workers to complete
        <span class="cov0" title="0">s.True(s.WaitForCondition("all workers completed", func() bool </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-workerStopped:<span class="cov0" title="0">
                        return true</span>
                default:<span class="cov0" title="0">
                        return false</span>
                }
        }))
}

// createTempFile creates a temporary file for testing.
func (s *ResourceCleanupTestSuite) createTempFile(content string) string <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        tmpFile, err := os.CreateTemp("", "test-*.txt")
        if err != nil </span><span class="cov0" title="0">{
                s.T().Errorf("Failed to create temp file: %v", err)

                return ""
        }</span>

        <span class="cov0" title="0">_, err = tmpFile.WriteString(content)
        if err != nil </span><span class="cov0" title="0">{
                s.T().Errorf("Failed to write to temp file: %v", err)

                return ""
        }</span>

        <span class="cov0" title="0">err = tmpFile.Close()
        if err != nil </span><span class="cov0" title="0">{
                s.T().Errorf("Failed to close temp file: %v", err)

                return ""
        }</span>

        <span class="cov0" title="0">s.tempFiles = append(s.tempFiles, tmpFile.Name())

        return tmpFile.Name()</span>
}

// Mock implementations for testing

// MockTimeKeeper provides controlled time for testing.
type MockTimeKeeper struct {
        currentTime time.Time
        mu          sync.RWMutex
}

// NewMockTimeKeeper creates a new mock time keeper.
func NewMockTimeKeeper() *MockTimeKeeper <span class="cov0" title="0">{
        return &amp;MockTimeKeeper{
                currentTime: time.Now(),
        }
}</span>

// Now returns the current mock time.
func (m *MockTimeKeeper) Now() time.Time <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        return m.currentTime
}</span>

// Advance advances the mock time by the specified duration.
func (m *MockTimeKeeper) Advance(d time.Duration) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        m.currentTime = m.currentTime.Add(d)
}</span>

// MockRateLimiter provides rate limiting for testing.
type MockRateLimiter struct {
        limit    int
        window   time.Duration
        requests []time.Time
        mu       sync.Mutex
}

// NewMockRateLimiter creates a new mock rate limiter.
func NewMockRateLimiter(requestsPerSecond int) *MockRateLimiter <span class="cov0" title="0">{
        return &amp;MockRateLimiter{
                limit:    requestsPerSecond,
                window:   time.Second,
                requests: make([]time.Time, 0),
        }
}</span>

// Allow checks if a request is allowed under the current rate limit.
func (r *MockRateLimiter) Allow() bool <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()

        now := time.Now()
        cutoff := now.Add(-r.window)

        // Remove old requests
        validRequests := make([]time.Time, 0)

        for _, req := range r.requests </span><span class="cov0" title="0">{
                if req.After(cutoff) </span><span class="cov0" title="0">{
                        validRequests = append(validRequests, req)
                }</span>
        }

        <span class="cov0" title="0">r.requests = validRequests

        // Check if we can add this request
        if len(r.requests) &lt; r.limit </span><span class="cov0" title="0">{
                r.requests = append(r.requests, now)

                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}

// MockConnection provides a mock connection for testing.
type MockConnection struct {
        connected bool
        mu        sync.RWMutex
}

// NewMockConnection creates a new mock connection.
func NewMockConnection() *MockConnection <span class="cov0" title="0">{
        return &amp;MockConnection{connected: true}
}</span>

// IsConnected returns whether the connection is active.
func (c *MockConnection) IsConnected() bool <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        return c.connected
}</span>

// Disconnect simulates a connection failure.
func (c *MockConnection) Disconnect() <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        c.connected = false
}</span>

// Connect simulates reconnection.
func (c *MockConnection) Connect() <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        c.connected = true
}</span>

// Helper functions

// getEnvDuration returns duration from environment variable or default.
func getEnvDuration(key string, defaultValue time.Duration) time.Duration <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                if duration, err := time.ParseDuration(value); err == nil </span><span class="cov0" title="0">{
                        return duration
                }</span>
        }

        <span class="cov0" title="0">return defaultValue</span>
}

// getEnvInt returns integer from environment variable or default.
func getEnvInt(key string, defaultValue int) int <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                if intValue, err := strconv.Atoi(value); err == nil </span><span class="cov0" title="0">{
                        return intValue
                }</span>
        }

        <span class="cov0" title="0">return defaultValue</span>
}

// Test suite runner functions

// TestPatternsSuite runs the patterns test suite.
func TestPatternsSuite(t *testing.T) <span class="cov0" title="0">{
        suite.Run(t, new(TimingDependentTestSuite))
        suite.Run(t, new(ResourceCleanupTestSuite))
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">// Package e2e provides end-to-end testing utilities and helpers.
//
// E2E utilities allow flexible style
//

package e2e

import (
        "context"
        "crypto/tls"
        "errors"
        "fmt"
        "io"
        "net"
        "net/http"
        "os"
        "os/exec"
        "path/filepath"
        "strings"
        "testing"
        "time"

        "go.uber.org/zap"
)

const (
        // Test timeouts and intervals.
        defaultTestTimeout = 30 * time.Second
        httpClientTimeout  = 5 * time.Second

        // HTTP status codes.
        httpStatusServerError = 500

        // File permissions.
        dirPermissions  = 0o750
        filePermissions = 0o600
)

// TestConfig holds configuration for E2E tests.
type TestConfig struct {
        GatewayURL       string
        AuthToken        string
        TestTimeout      time.Duration
        RouterBinaryPath string
        RouterConfigPath string
        TempDir          string
        CleanupOnFailure bool
}

// DefaultTestConfig creates a default test configuration.
func DefaultTestConfig() *TestConfig <span class="cov0" title="0">{
        return &amp;TestConfig{
                GatewayURL:       "wss://localhost:8443/ws",
                AuthToken:        "", // No default auth token
                TestTimeout:      defaultTestTimeout,
                RouterBinaryPath: "./bin/mcp-router",
                RouterConfigPath: "./test/configs/router.yaml",
                TempDir:          "",
                CleanupOnFailure: true,
        }
}</span>

// TestEnvironment manages E2E test environment.
type TestEnvironment struct {
        Config    *TestConfig
        Logger    *zap.Logger
        TempDir   string
        processes []*os.Process
        cleanup   []func() error
}

// NewTestEnvironment creates a new test environment.
func NewTestEnvironment(t *testing.T, config *TestConfig) *TestEnvironment <span class="cov0" title="0">{
        t.Helper()

        logger, err := zap.NewDevelopment()
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to create logger: %v", err)
        }</span>

        <span class="cov0" title="0">tempDir, err := os.MkdirTemp("", "mcp-e2e-*")
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to create temp directory: %v", err)
        }</span>

        <span class="cov0" title="0">if config.TempDir == "" </span><span class="cov0" title="0">{
                config.TempDir = tempDir
        }</span>

        <span class="cov0" title="0">return &amp;TestEnvironment{
                Config:    config,
                Logger:    logger,
                TempDir:   tempDir,
                processes: make([]*os.Process, 0),
                cleanup:   make([]func() error, 0),
        }</span>
}

// AddCleanup adds a cleanup function to be called on environment shutdown.
func (env *TestEnvironment) AddCleanup(cleanup func() error) <span class="cov0" title="0">{
        env.cleanup = append(env.cleanup, cleanup)
}</span>

// StartRouter starts the MCP router process.
func (env *TestEnvironment) StartRouter() error <span class="cov0" title="0">{
        if env.Config.RouterBinaryPath == "" </span><span class="cov0" title="0">{
                return errors.New("router binary path not specified")
        }</span>

        <span class="cov0" title="0">if env.Config.RouterConfigPath == "" </span><span class="cov0" title="0">{
                return errors.New("router config path not specified")
        }</span>

        //nolint:gosec // Test router startup
        <span class="cov0" title="0">cmd := exec.CommandContext(context.Background(), env.Config.RouterBinaryPath,
                "--config", env.Config.RouterConfigPath)
        cmd.Env = append(os.Environ(), "MCP_AUTH_TOKEN="+env.Config.AuthToken)

        if err := cmd.Start(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start router: %w", err)
        }</span>

        <span class="cov0" title="0">env.processes = append(env.processes, cmd.Process)
        env.AddCleanup(func() error </span><span class="cov0" title="0">{
                if cmd.Process != nil </span><span class="cov0" title="0">{
                        return cmd.Process.Kill()
                }</span>

                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">env.Logger.Info("Router started", zap.Int("pid", cmd.Process.Pid))

        return nil</span>
}

// WaitForService waits for a service to become available.
func (env *TestEnvironment) WaitForService(url string, timeout time.Duration) error <span class="cov0" title="0">{
        client := &amp;http.Client{
                Timeout: httpClientTimeout,
                Transport: &amp;http.Transport{
                        TLSClientConfig: &amp;tls.Config{InsecureSkipVerify: true}, //nolint:gosec // Test environment only
                },
        }

        deadline := time.Now().Add(timeout)
        for time.Now().Before(deadline) </span><span class="cov0" title="0">{
                req, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, url, nil)

                resp, err := client.Do(req)
                if err == nil </span><span class="cov0" title="0">{
                        _ = resp.Body.Close()
                        if resp.StatusCode &lt; httpStatusServerError </span><span class="cov0" title="0">{
                                env.Logger.Info("Service became available", zap.String("url", url))

                                return nil
                        }</span>
                }

                <span class="cov0" title="0">time.Sleep(1 * time.Second)</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("service at %s did not become available within %v", url, timeout)</span>
}

// CreateTestFile creates a test file in the temp directory.
func (env *TestEnvironment) CreateTestFile(filename, content string) (string, error) <span class="cov0" title="0">{
        fullPath := filepath.Join(env.TempDir, filename)

        dir := filepath.Dir(fullPath)
        if err := os.MkdirAll(dir, dirPermissions); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create directories: %w", err)
        }</span>

        <span class="cov0" title="0">if err := os.WriteFile(fullPath, []byte(content), filePermissions); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to write test file: %w", err)
        }</span>

        <span class="cov0" title="0">return fullPath, nil</span>
}

// ReadTestFile reads a test file from the temp directory.
func (env *TestEnvironment) ReadTestFile(filename string) (string, error) <span class="cov0" title="0">{
        fullPath := filepath.Join(env.TempDir, filename)

        content, err := os.ReadFile(fullPath) //nolint:gosec // Test file reading
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to read test file: %w", err)
        }</span>

        <span class="cov0" title="0">return string(content), nil</span>
}

// HTTPClient creates an HTTP client suitable for E2E tests.
func (env *TestEnvironment) HTTPClient() *http.Client <span class="cov0" title="0">{
        return &amp;http.Client{
                Timeout: env.Config.TestTimeout,
                Transport: &amp;http.Transport{
                        TLSClientConfig: &amp;tls.Config{InsecureSkipVerify: true}, //nolint:gosec // Test environment only
                },
        }
}</span>

// MakeRequest makes an HTTP request to the test environment.
func (env *TestEnvironment) MakeRequest(method, path string, body io.Reader) (*http.Response, error) <span class="cov0" title="0">{
        url := env.Config.GatewayURL + path

        req, err := http.NewRequestWithContext(context.Background(), method, url, body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">if env.Config.AuthToken != "" </span><span class="cov0" title="0">{
                req.Header.Set("Authorization", "Bearer "+env.Config.AuthToken)
        }</span>

        <span class="cov0" title="0">client := env.HTTPClient()

        return client.Do(req)</span>
}

// RunCommand executes a command in the test environment.
func (env *TestEnvironment) RunCommand(name string, args ...string) ([]byte, error) <span class="cov0" title="0">{
        cmd := exec.CommandContext(context.Background(), name, args...)
        cmd.Dir = env.TempDir

        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                env.Logger.Error("Command failed",
                        zap.String("command", name),
                        zap.Strings("args", args),
                        zap.Error(err))

                return nil, fmt.Errorf("command failed: %w", err)
        }</span>

        <span class="cov0" title="0">return output, nil</span>
}

// RunCommandWithTimeout executes a command with timeout.
func (env *TestEnvironment) RunCommandWithTimeout(timeout time.Duration, name string, args ...string) ([]byte, error) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), timeout)
        defer cancel()

        cmd := exec.CommandContext(ctx, name, args...)
        cmd.Dir = env.TempDir

        return cmd.Output()
}</span>

// CheckServiceHealth performs a basic health check on a service.
func (env *TestEnvironment) CheckServiceHealth(serviceURL string) error <span class="cov0" title="0">{
        client := env.HTTPClient()

        req, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, serviceURL+"/health", nil)

        resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("health check request failed: %w", err)
        }</span>

        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = resp.Body.Close() }</span>()

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return fmt.Errorf("service unhealthy: status %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// WaitForProcessToStop waits for a process to stop.
func (env *TestEnvironment) WaitForProcessToStop(process *os.Process, timeout time.Duration) error <span class="cov0" title="0">{
        done := make(chan error, 1)

        go func() </span><span class="cov0" title="0">{
                _, err := process.Wait()
                done &lt;- err
        }</span>()

        <span class="cov0" title="0">select </span>{
        case err := &lt;-done:<span class="cov0" title="0">
                return err</span>
        case &lt;-time.After(timeout):<span class="cov0" title="0">
                return fmt.Errorf("process did not stop within %v", timeout)</span>
        }
}

// Cleanup cleans up the test environment.
func (env *TestEnvironment) Cleanup() error <span class="cov0" title="0">{
        var errors []error

        // Run cleanup functions in reverse order
        for i := len(env.cleanup) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                if err := env.cleanup[i](); err != nil </span><span class="cov0" title="0">{
                        errors = append(errors, err)
                }</span>
        }

        // Kill any remaining processes
        <span class="cov0" title="0">for _, process := range env.processes </span><span class="cov0" title="0">{
                if process != nil </span><span class="cov0" title="0">{
                        _ = process.Kill()
                }</span>
        }

        // Remove temp directory
        <span class="cov0" title="0">if env.TempDir != "" </span><span class="cov0" title="0">{
                if err := os.RemoveAll(env.TempDir); err != nil </span><span class="cov0" title="0">{
                        errors = append(errors, err)
                }</span>
        }

        <span class="cov0" title="0">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("cleanup failed with %d errors: %v", len(errors), errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// TestRunner provides test execution utilities.
type TestRunner struct {
        env *TestEnvironment
        t   *testing.T
}

// NewTestRunner creates a new test runner.
func NewTestRunner(t *testing.T, env *TestEnvironment) *TestRunner <span class="cov0" title="0">{
        t.Helper()

        return &amp;TestRunner{
                env: env,
                t:   t,
        }
}</span>

// RunTest executes a test with proper setup and cleanup.
func (tr *TestRunner) RunTest(name string, testFunc func(*TestEnvironment) error) <span class="cov0" title="0">{
        tr.t.Run(name, func(t *testing.T) </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        if err := tr.env.Cleanup(); err != nil </span><span class="cov0" title="0">{
                                t.Logf("Cleanup error: %v", err)
                        }</span>
                }()

                <span class="cov0" title="0">if err := testFunc(tr.env); err != nil </span><span class="cov0" title="0">{
                        t.Fatalf("Test failed: %v", err)
                }</span>
        })
}

// AssertResponse checks HTTP response expectations.
func (tr *TestRunner) AssertResponse(resp *http.Response, expectedStatus int) <span class="cov0" title="0">{
        if resp.StatusCode != expectedStatus </span><span class="cov0" title="0">{
                tr.t.Errorf("Expected status %d, got %d", expectedStatus, resp.StatusCode)
        }</span>
}

// AssertNoError fails the test if error is not nil.
func (tr *TestRunner) AssertNoError(err error) <span class="cov0" title="0">{
        if err != nil </span><span class="cov0" title="0">{
                tr.t.Fatalf("Unexpected error: %v", err)
        }</span>
}

// AssertError fails the test if error is nil.
func (tr *TestRunner) AssertError(err error) <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                tr.t.Fatal("Expected error but got none")
        }</span>
}

// AssertContains fails the test if haystack doesn't contain needle.
func (tr *TestRunner) AssertContains(haystack, needle string) <span class="cov0" title="0">{
        if !strings.Contains(haystack, needle) </span><span class="cov0" title="0">{
                tr.t.Errorf("Expected %q to contain %q", haystack, needle)
        }</span>
}

// LoadTestData loads test data from a file.
func LoadTestData(filename string) ([]byte, error) <span class="cov0" title="0">{
        return os.ReadFile(filename) //nolint:gosec // Test file reading
}</span>

// DirectGatewayRouter provides a simple implementation of RouterInterface
// that connects directly to the gateway without a router process.
type DirectGatewayRouter struct{}

// SendRequestAndWait sends a request directly to the gateway via WebSocket.
func (dgr *DirectGatewayRouter) SendRequestAndWait(req MCPRequest, timeout time.Duration) ([]byte, error) <span class="cov0" title="0">{
        // For now, return a simple error indicating this is not yet implemented
        // K8s tests will need to be updated to work differently or this needs full implementation
        return nil, errors.New("DirectGatewayRouter not yet implemented - K8s tests need RouterController")
}</span>

// TestSuite provides a higher-level interface for E2E testing.
// This is a compatibility wrapper around TestEnvironment for K8s tests.
type TestSuite struct {
        env    *TestEnvironment
        client *MCPClient
        router *RouterController
        t      *testing.T
}

// NewTestSuite creates a new test suite with the given configuration.
func NewTestSuite(t *testing.T, config *TestConfig) *TestSuite <span class="cov0" title="0">{
        t.Helper()

        env := NewTestEnvironment(t, config)

        return &amp;TestSuite{
                env: env,
                t:   t,
        }
}</span>

// Setup initializes the test suite and creates the MCP client.
func (ts *TestSuite) Setup() error <span class="cov0" title="0">{
        // Create RouterController to manage the router process
        ts.router = NewRouterController(ts.t, ts.env.Config.GatewayURL)

        // Build and start the router
        if err := ts.router.BuildRouter(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to build router: %w", err)
        }</span>

        <span class="cov0" title="0">if err := ts.router.Start(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start router: %w", err)
        }</span>

        // Wait for router to become healthy
        <span class="cov0" title="0">if err := ts.router.WaitForHealthy(defaultTestTimeout); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("router failed to become healthy: %w", err)
        }</span>

        // Create MCP client using the router
        <span class="cov0" title="0">ts.client = NewMCPClient(ts.router, ts.env.Logger)

        return nil</span>
}

// Teardown cleans up the test suite resources.
func (ts *TestSuite) Teardown() <span class="cov0" title="0">{
        if ts.router != nil </span><span class="cov0" title="0">{
                ts.router.Stop()
        }</span>

        <span class="cov0" title="0">if err := ts.env.Cleanup(); err != nil </span><span class="cov0" title="0">{
                ts.t.Logf("Error during environment cleanup: %v", err)
        }</span>
}

// GetClient returns the MCP client for making requests.
func (ts *TestSuite) GetClient() *MCPClient <span class="cov0" title="0">{
        return ts.client
}</span>

// SaveTestData saves data to a test file.
func SaveTestData(filename string, data []byte) error <span class="cov0" title="0">{
        dir := filepath.Dir(filename)
        if err := os.MkdirAll(dir, dirPermissions); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create directories: %w", err)
        }</span>

        <span class="cov0" title="0">return os.WriteFile(filename, data, filePermissions)</span>
}

// IsPortOpen checks if a port is open and accepting connections.
func IsPortOpen(host string, port int) bool <span class="cov0" title="0">{
        address := fmt.Sprintf("%s:%d", host, port)

        dialer := &amp;net.Dialer{Timeout: 1 * time.Second}

        conn, err := dialer.DialContext(context.Background(), "tcp", address)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = conn.Close() }</span>()

        <span class="cov0" title="0">return true</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">// Package e2e provides end-to-end test utilities for MCP protocol testing.
package e2e

import (
        "encoding/json"
        "errors"
        "fmt"
        "time"

        "go.uber.org/zap"
)

const (
        // DefaultToolCallTimeout is the default timeout for tool calls.
        DefaultToolCallTimeout = 30 * time.Second
        // DefaultRequestTimeout is the default timeout for request/response operations.
        DefaultRequestTimeout = 10 * time.Second
)

// MCP protocol types and helpers

// MCPRequest represents an MCP JSON-RPC request.
type MCPRequest struct {
        JSONRPC string      `json:"jsonrpc"`
        Method  string      `json:"method"`
        Params  interface{} `json:"params,omitempty"`
        ID      string      `json:"id"`
}

// MCPResponse represents an MCP JSON-RPC response.
type MCPResponse struct {
        JSONRPC string      `json:"jsonrpc"`
        Result  interface{} `json:"result,omitempty"`
        Error   *MCPError   `json:"error,omitempty"`
        ID      string      `json:"id"`
}

// MCPError represents an MCP error.
type MCPError struct {
        Code    int         `json:"code"`
        Message string      `json:"message"`
        Data    interface{} `json:"data,omitempty"`
}

// Tool represents an MCP tool definition.
type Tool struct {
        Name        string      `json:"name"`
        Description string      `json:"description"`
        InputSchema interface{} `json:"inputSchema"`
}

// RouterInterface defines the interface that router controllers must implement.
type RouterInterface interface {
        SendRequestAndWait(req MCPRequest, timeout time.Duration) ([]byte, error)
}

// MCPClient provides client functionality for MCP protocol testing.
type MCPClient struct {
        router       RouterInterface
        logger       *zap.Logger
        requestID    int
        initialized  bool
        capabilities map[string]interface{}
        tools        []Tool
}

// NewMCPClient creates a new MCP client.
func NewMCPClient(router RouterInterface, logger *zap.Logger) *MCPClient <span class="cov0" title="0">{
        if logger == nil </span><span class="cov0" title="0">{
                logger = zap.NewNop()
        }</span>

        <span class="cov0" title="0">return &amp;MCPClient{
                router:       router,
                logger:       logger,
                requestID:    0,
                initialized:  false,
                capabilities: make(map[string]interface{}),
                tools:        make([]Tool, 0),
        }</span>
}

// Initialize sends an MCP initialize request.
func (c *MCPClient) Initialize() (*MCPResponse, error) <span class="cov0" title="0">{
        c.logger.Debug("Starting MCP client initialization")

        req := MCPRequest{
                JSONRPC: "2.0",
                Method:  "initialize",
                Params: map[string]interface{}{
                        "protocolVersion": "1.0",
                        "capabilities": map[string]interface{}{
                                "tools": true,
                        },
                        "clientInfo": map[string]interface{}{
                                "name":    "mcp-e2e-test-client",
                                "version": "1.0.0",
                        },
                },
                ID: c.nextRequestID(),
        }

        c.logger.Debug("Sending initialize request",
                zap.Any("request_id", req.ID),
                zap.Any("request", req))

        respData, err := c.router.SendRequestAndWait(req, DefaultRequestTimeout)
        if err != nil </span><span class="cov0" title="0">{
                c.logger.Debug("Initialize request failed", zap.Error(err))

                return nil, fmt.Errorf("initialize request failed: %w", err)
        }</span>

        <span class="cov0" title="0">c.logger.Debug("Received initialize response", zap.String("response_data", string(respData)))

        var resp MCPResponse
        if err := json.Unmarshal(respData, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse initialize response: %w", err)
        }</span>

        <span class="cov0" title="0">if resp.Error != nil </span><span class="cov0" title="0">{
                return &amp;resp, fmt.Errorf("initialize error: %s", resp.Error.Message)
        }</span>

        // Parse capabilities
        <span class="cov0" title="0">if result, ok := resp.Result.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                if caps, ok := result["capabilities"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        c.capabilities = caps
                }</span>
        }

        <span class="cov0" title="0">c.initialized = true

        return &amp;resp, nil</span>
}

// ListTools requests the list of available tools.
func (c *MCPClient) ListTools() ([]Tool, error) <span class="cov0" title="0">{
        if !c.initialized </span><span class="cov0" title="0">{
                return nil, errors.New("client not initialized")
        }</span>

        <span class="cov0" title="0">resp, err := c.sendToolsListRequest()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">tools := c.parseToolsResponse(resp)
        c.tools = tools

        return tools, nil</span>
}

func (c *MCPClient) sendToolsListRequest() (*MCPResponse, error) <span class="cov0" title="0">{
        req := MCPRequest{
                JSONRPC: "2.0",
                Method:  "tools/list",
                Params:  nil, // No parameters needed for tools/list
                ID:      c.nextRequestID(),
        }

        respData, err := c.router.SendRequestAndWait(req, DefaultRequestTimeout)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("tools/list request failed: %w", err)
        }</span>

        <span class="cov0" title="0">var resp MCPResponse
        if err := json.Unmarshal(respData, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse tools/list response: %w", err)
        }</span>

        <span class="cov0" title="0">if resp.Error != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("tools/list error: %s", resp.Error.Message)
        }</span>

        <span class="cov0" title="0">return &amp;resp, nil</span>
}

func (c *MCPClient) parseToolsResponse(resp *MCPResponse) []Tool <span class="cov0" title="0">{
        result, ok := resp.Result.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return []Tool{}
        }</span>

        <span class="cov0" title="0">toolsArray, ok := result["tools"].([]interface{})
        if !ok </span><span class="cov0" title="0">{
                return []Tool{}
        }</span>

        <span class="cov0" title="0">tools := make([]Tool, 0, len(toolsArray))
        for _, toolData := range toolsArray </span><span class="cov0" title="0">{
                if tool := parseToolData(toolData); tool != nil </span><span class="cov0" title="0">{
                        tools = append(tools, *tool)
                }</span>
        }

        <span class="cov0" title="0">return tools</span>
}

func parseToolData(toolData interface{}) *Tool <span class="cov0" title="0">{
        toolMap, ok := toolData.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">tool := &amp;Tool{
                Name:        "",
                Description: "",
                InputSchema: nil,
        }

        if name, ok := toolMap["name"].(string); ok </span><span class="cov0" title="0">{
                tool.Name = name
        }</span>

        <span class="cov0" title="0">if desc, ok := toolMap["description"].(string); ok </span><span class="cov0" title="0">{
                tool.Description = desc
        }</span>

        <span class="cov0" title="0">tool.InputSchema = toolMap["inputSchema"]

        return tool</span>
}

// CallTool executes a specific tool with arguments.
func (c *MCPClient) CallTool(toolName string, arguments map[string]interface{}) (*MCPResponse, error) <span class="cov0" title="0">{
        if !c.initialized </span><span class="cov0" title="0">{
                return nil, errors.New("client not initialized")
        }</span>

        <span class="cov0" title="0">req := MCPRequest{
                JSONRPC: "2.0",
                Method:  "tools/call",
                Params: map[string]interface{}{
                        "name":      toolName,
                        "arguments": arguments,
                },
                ID: c.nextRequestID(),
        }

        respData, err := c.router.SendRequestAndWait(req, DefaultToolCallTimeout)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("tools/call request failed: %w", err)
        }</span>

        <span class="cov0" title="0">var resp MCPResponse
        if err := json.Unmarshal(respData, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse tools/call response: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;resp, nil</span>
}

// GetCapabilities returns the server capabilities.
func (c *MCPClient) GetCapabilities() map[string]interface{} <span class="cov0" title="0">{
        return c.capabilities
}</span>

// GetTools returns the cached list of tools.
func (c *MCPClient) GetTools() []Tool <span class="cov0" title="0">{
        return c.tools
}</span>

// IsInitialized returns true if the client has been initialized.
func (c *MCPClient) IsInitialized() bool <span class="cov0" title="0">{
        return c.initialized
}</span>

// nextRequestID generates the next request ID.
func (c *MCPClient) nextRequestID() string <span class="cov0" title="0">{
        id := fmt.Sprintf("req-%d", c.requestID)
        c.requestID++

        return id
}</span>

// Helper functions for test assertions

// AssertValidMCPResponse validates that a response is a valid MCP response.
func AssertValidMCPResponse(resp *MCPResponse) error <span class="cov0" title="0">{
        if resp.JSONRPC != "2.0" </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid JSONRPC version: %s", resp.JSONRPC)
        }</span>

        <span class="cov0" title="0">if resp.ID == "" </span><span class="cov0" title="0">{
                return errors.New("missing response ID")
        }</span>

        <span class="cov0" title="0">if resp.Result == nil &amp;&amp; resp.Error == nil </span><span class="cov0" title="0">{
                return errors.New("response must have either result or error")
        }</span>

        <span class="cov0" title="0">if resp.Result != nil &amp;&amp; resp.Error != nil </span><span class="cov0" title="0">{
                return errors.New("response cannot have both result and error")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// AssertToolCallSuccess validates that a tool call was successful.
func AssertToolCallSuccess(resp *MCPResponse) error <span class="cov0" title="0">{
        if err := AssertValidMCPResponse(resp); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := validateToolCallResponse(resp); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">resultArray, err := getResultArray(resp)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return validateContentBlocks(resultArray)</span>
}

func validateToolCallResponse(resp *MCPResponse) error <span class="cov0" title="0">{
        if resp.Error != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("tool call failed: %s", resp.Error.Message)
        }</span>

        <span class="cov0" title="0">if resp.Result == nil </span><span class="cov0" title="0">{
                return errors.New("tool call result is nil")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func getResultArray(resp *MCPResponse) ([]interface{}, error) <span class="cov0" title="0">{
        resultArray, ok := resp.Result.([]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("tool call result must be an array")
        }</span>

        <span class="cov0" title="0">if len(resultArray) == 0 </span><span class="cov0" title="0">{
                return nil, errors.New("tool call result array is empty")
        }</span>

        <span class="cov0" title="0">return resultArray, nil</span>
}

func validateContentBlocks(resultArray []interface{}) error <span class="cov0" title="0">{
        for i, block := range resultArray </span><span class="cov0" title="0">{
                if err := validateSingleContentBlock(i, block); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func validateSingleContentBlock(index int, block interface{}) error <span class="cov0" title="0">{
        blockMap, ok := block.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("content block %d is not an object", index)
        }</span>

        <span class="cov0" title="0">blockType, ok := blockMap["type"].(string)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("content block %d missing type", index)
        }</span>

        <span class="cov0" title="0">return validateBlockTypeFields(index, blockType, blockMap)</span>
}

func validateBlockTypeFields(index int, blockType string, blockMap map[string]interface{}) error <span class="cov0" title="0">{
        switch blockType </span>{
        case "text":<span class="cov0" title="0">
                if _, ok := blockMap["text"].(string); !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("text content block %d missing text field", index)
                }</span>
        case "image":<span class="cov0" title="0">
                if _, ok := blockMap["data"].(string); !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("image content block %d missing data field", index)
                }</span>
        case "resource":<span class="cov0" title="0">
                if _, ok := blockMap["resource"]; !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("resource content block %d missing resource field", index)
                }</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unknown content block type: %s", blockType)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// AssertToolCallError validates that a tool call failed with expected error.
func AssertToolCallError(resp *MCPResponse, expectedCode int) error <span class="cov0" title="0">{
        if err := AssertValidMCPResponse(resp); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if resp.Error == nil </span><span class="cov0" title="0">{
                return errors.New("expected tool call to fail but it succeeded")
        }</span>

        <span class="cov0" title="0">if resp.Result != nil </span><span class="cov0" title="0">{
                return errors.New("tool call error response should not have result")
        }</span>

        <span class="cov0" title="0">if resp.Error.Code != expectedCode </span><span class="cov0" title="0">{
                return fmt.Errorf("expected error code %d but got %d", expectedCode, resp.Error.Code)
        }</span>

        <span class="cov0" title="0">if resp.Error.Message == "" </span><span class="cov0" title="0">{
                return errors.New("error message is empty")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ExtractTextFromToolResponse extracts text content from a tool response.
//

func ExtractTextFromToolResponse(resp *MCPResponse) (string, error) <span class="cov0" title="0">{
        if resp.Error != nil </span><span class="cov0" title="0">{
                return "", errors.New("cannot extract text from error response")
        }</span>

        <span class="cov0" title="0">resultArray, ok := resp.Result.([]interface{})
        if !ok </span><span class="cov0" title="0">{
                return "", errors.New("result is not an array")
        }</span>

        <span class="cov0" title="0">textParts := extractTextParts(resultArray)

        if len(textParts) == 0 </span><span class="cov0" title="0">{
                return "", errors.New("no text content found in response")
        }</span>

        <span class="cov0" title="0">return joinTextParts(textParts), nil</span>
}

func extractTextParts(resultArray []interface{}) []string <span class="cov0" title="0">{
        var textParts []string

        for _, block := range resultArray </span><span class="cov0" title="0">{
                if text := extractTextFromBlock(block); text != "" </span><span class="cov0" title="0">{
                        textParts = append(textParts, text)
                }</span>
        }

        <span class="cov0" title="0">return textParts</span>
}

func extractTextFromBlock(block interface{}) string <span class="cov0" title="0">{
        blockMap, ok := block.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">blockType, ok := blockMap["type"].(string)
        if !ok || blockType != "text" </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">text, ok := blockMap["text"].(string)
        if !ok </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">return text</span>
}

func joinTextParts(textParts []string) string <span class="cov0" title="0">{
        result := ""

        for i, part := range textParts </span><span class="cov0" title="0">{
                if i &gt; 0 </span><span class="cov0" title="0">{
                        result += " "
                }</span>

                <span class="cov0" title="0">result += part</span>
        }

        <span class="cov0" title="0">return result</span>
}

// CreateToolCallRequest creates a properly formatted tool call request.
func CreateToolCallRequest(toolName string, arguments map[string]interface{}) MCPRequest <span class="cov0" title="0">{
        return MCPRequest{
                JSONRPC: "2.0",
                Method:  "tools/call",
                Params: map[string]interface{}{
                        "name":      toolName,
                        "arguments": arguments,
                },
                ID: fmt.Sprintf("test-%d", time.Now().UnixNano()),
        }
}</span>

// CreateInitializeRequest creates a properly formatted initialize request.
func CreateInitializeRequest() MCPRequest <span class="cov0" title="0">{
        return MCPRequest{
                JSONRPC: "2.0",
                Method:  "initialize",
                Params: map[string]interface{}{
                        "protocolVersion": "1.0",
                        "capabilities": map[string]interface{}{
                                "tools": true,
                        },
                        "clientInfo": map[string]interface{}{
                                "name":    "mcp-e2e-test-client",
                                "version": "1.0.0",
                        },
                },
                ID: fmt.Sprintf("init-%d", time.Now().UnixNano()),
        }
}</span>

// CreateListToolsRequest creates a properly formatted tools/list request.
func CreateListToolsRequest() MCPRequest <span class="cov0" title="0">{
        return MCPRequest{
                JSONRPC: "2.0",
                Method:  "tools/list",
                Params:  nil, // No parameters needed for tools/list
                ID:      fmt.Sprintf("list-%d", time.Now().UnixNano()),
        }
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">// Router controller test utilities allow flexible style
//

package e2e

import (
        "bufio"
        "context"
        "crypto/hmac"
        "crypto/sha256"
        "encoding/base64"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "net/http"
        "os"
        "os/exec"
        "path/filepath"
        "sync"
        "testing"
        "time"

        "go.uber.org/zap"
)

const (
        // DefaultDirectoryPermissions for creating directories.
        DefaultDirectoryPermissions = 0o750
        // DefaultFilePermissions for creating files.
        
        // Channel buffer sizes for router controller.
        requestChannelBufferSize = 100
        responseChannelBufferSize = 100
        errorChannelBufferSize = 10
        
        // Timeouts.
        routerHealthCheckTimeout = 5 * time.Second
        tokenValidityDuration = 24 * time.Hour
        messageRetryDelay = 100 * time.Millisecond
        maxRetryAttempts = 2
        DefaultFilePermissions = 0o600
)

// RouterController manages the router binary subprocess and provides stdio interface.
type RouterController struct {
        t          *testing.T
        logger     *zap.Logger
        binaryPath string
        configPath string
        gatewayURL string
        authToken  string // Added for authentication support
        cmd        *exec.Cmd
        stdin      io.WriteCloser
        stdout     io.ReadCloser
        stderr     io.ReadCloser

        // Communication channels
        requests  chan []byte
        responses chan []byte
        errors    chan error

        // Response tracking
        pendingMu sync.RWMutex
        pending   map[string]chan []byte

        // Lifecycle
        ctx     context.Context 
        cancel  context.CancelFunc
        done    chan struct{}
        started bool
}

// NewRouterController creates a new router controller for the given gateway URL.
func NewRouterController(t *testing.T, gatewayURL string) *RouterController <span class="cov0" title="0">{
        t.Helper()

        logger, err := zap.NewDevelopment()
        if err != nil </span><span class="cov0" title="0">{
                logger = zap.NewNop() // Fallback to no-op logger
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithCancel(context.Background())

        return &amp;RouterController{
                t:          t,
                logger:     logger,
                binaryPath: "", // Will be set during BuildRouter
                configPath: "", // Will be set during BuildRouter
                gatewayURL: gatewayURL,
                authToken:  "",  // Will be set if authentication is needed
                cmd:        nil, // Will be set when router is started
                stdin:      nil, // Will be set when router is started
                stdout:     nil, // Will be set when router is started
                stderr:     nil, // Will be set when router is started
                requests:   make(chan []byte, requestChannelBufferSize),
                responses:  make(chan []byte, responseChannelBufferSize),
                errors:     make(chan error, errorChannelBufferSize),
                pendingMu:  sync.RWMutex{}, // Initialize mutex
                pending:    make(map[string]chan []byte),
                started:    false, // Not started initially
                ctx:        ctx,
                cancel:     cancel,
                done:       make(chan struct{}),
        }</span>
}

// BuildRouter builds the router binary from source.
func (rc *RouterController) BuildRouter() error <span class="cov0" title="0">{
        rc.logger.Info("Building router binary")

        // Find project root using shared infrastructure
        projectRoot, err := FindProjectRoot()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to find project root: %w", err)
        }</span>

        // Build binary
        <span class="cov0" title="0">binaryDir := filepath.Join(projectRoot, "test", "temp")
        if err := os.MkdirAll(binaryDir, DefaultDirectoryPermissions); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create binary directory: %w", err)
        }</span>

        <span class="cov0" title="0">rc.binaryPath = filepath.Join(binaryDir, "mcp-router")

        //nolint:gosec // Test build command
        buildCmd := exec.CommandContext(context.Background(), "go", "build",
                "-o", rc.binaryPath,
                filepath.Join(projectRoot, "services", "router", "cmd", "mcp-router"))
        buildCmd.Dir = projectRoot

        if output, err := buildCmd.CombinedOutput(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to build router: %w\nOutput: %s", err, string(output))
        }</span>

        <span class="cov0" title="0">rc.logger.Info("Router binary built successfully", zap.String("path", rc.binaryPath))

        return nil</span>
}

// Start starts the router process.
func (rc *RouterController) Start() error <span class="cov0" title="0">{
        if rc.started </span><span class="cov0" title="0">{
                return errors.New("router already started")
        }</span>

        // Generate auth token
        <span class="cov0" title="0">rc.generateAuthToken()

        // Create config file
        if err := rc.createConfigFile(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create config file: %w", err)
        }</span>

        // Start the router process
        <span class="cov0" title="0">rc.cmd = exec.CommandContext(rc.ctx, rc.binaryPath, //nolint:gosec // Test router startup 
                "--config", rc.configPath, "--log-level", "debug")

        // Set environment variable for auth token
        rc.cmd.Env = append(os.Environ(), "MCP_AUTH_TOKEN="+rc.authToken)

        // Set up pipes
        var err error

        rc.stdin, err = rc.cmd.StdinPipe()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create stdin pipe: %w", err)
        }</span>

        <span class="cov0" title="0">rc.stdout, err = rc.cmd.StdoutPipe()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create stdout pipe: %w", err)
        }</span>

        <span class="cov0" title="0">rc.stderr, err = rc.cmd.StderrPipe()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create stderr pipe: %w", err)
        }</span>

        // Start the process
        <span class="cov0" title="0">if err := rc.cmd.Start(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start router process: %w", err)
        }</span>

        <span class="cov0" title="0">rc.started = true

        // Start I/O handlers
        go rc.handleStdout()
        go rc.handleStderr()
        go rc.handleRequests()
        go rc.handleResponses()

        rc.logger.Info("Router started successfully")

        return nil</span>
}

// Stop stops the router process.
func (rc *RouterController) Stop() <span class="cov0" title="0">{
        if !rc.started </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">rc.logger.Info("Stopping router controller")

        // Cancel context to signal shutdown
        rc.cancel()

        // Close stdin to signal the router to shut down
        if rc.stdin != nil </span><span class="cov0" title="0">{
                _ = rc.stdin.Close() // Ignore error in test cleanup
        }</span>

        // Wait for process to exit or force kill after timeout
        <span class="cov0" title="0">if rc.cmd != nil &amp;&amp; rc.cmd.Process != nil </span><span class="cov0" title="0">{
                done := make(chan error, 1)

                go func() </span><span class="cov0" title="0">{
                        done &lt;- rc.cmd.Wait()
                }</span>()

                <span class="cov0" title="0">select </span>{
                case &lt;-done:<span class="cov0" title="0"></span>
                        // Process exited normally
                case &lt;-time.After(routerHealthCheckTimeout):<span class="cov0" title="0">
                        // Force kill after timeout
                        rc.logger.Warn("Router process didn't exit gracefully, force killing")
                        _ = rc.cmd.Process.Kill() // Ignore error in test cleanup

                        &lt;-done</span> // Wait for kill to complete
                }
        }

        // Clean up resources
        <span class="cov0" title="0">rc.cleanup()

        // Signal completion
        close(rc.done)

        rc.logger.Info("Router controller stopped")</span>
}

// SendRequestAndWait sends a request and waits for the response.
func (rc *RouterController) SendRequestAndWait(req MCPRequest, timeout time.Duration) ([]byte, error) <span class="cov0" title="0">{
        if !rc.started </span><span class="cov0" title="0">{
                return nil, errors.New("router not started")
        }</span>

        // Create response channel
        <span class="cov0" title="0">respChan := make(chan []byte, 1)

        rc.pendingMu.Lock()
        rc.pending[req.ID] = respChan
        rc.pendingMu.Unlock()

        // Clean up on exit
        defer func() </span><span class="cov0" title="0">{
                rc.pendingMu.Lock()
                delete(rc.pending, req.ID)
                rc.pendingMu.Unlock()
                close(respChan)
        }</span>()

        // Serialize and send request
        <span class="cov0" title="0">reqData, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to serialize request: %w", err)
        }</span>

        <span class="cov0" title="0">select </span>{
        case rc.requests &lt;- reqData:<span class="cov0" title="0"></span>
                // Request sent successfully
        case &lt;-time.After(timeout):<span class="cov0" title="0">
                return nil, errors.New("timeout sending request")</span>
        case &lt;-rc.ctx.Done():<span class="cov0" title="0">
                return nil, errors.New("router controller stopped")</span>
        }

        // Wait for response
        <span class="cov0" title="0">select </span>{
        case respData := &lt;-respChan:<span class="cov0" title="0">
                return respData, nil</span>
        case &lt;-time.After(timeout):<span class="cov0" title="0">
                return nil, errors.New("timeout waiting for response")</span>
        case &lt;-rc.ctx.Done():<span class="cov0" title="0">
                return nil, errors.New("router controller stopped")</span>
        }
}

// Internal methods

func (rc *RouterController) processJSONRPCResponse(resp map[string]interface{}, line []byte) <span class="cov0" title="0">{
        respID := resp["id"]
        if respID == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Log the response ID and its type
        <span class="cov0" title="0">rc.logger.Debug("Received response from router",
                zap.Any("id", respID),
                zap.String("id_type", fmt.Sprintf("%T", respID)),
                zap.String("response", string(line)))

        // Try to match as string first
        id, ok := respID.(string)
        if !ok </span><span class="cov0" title="0">{
                rc.logger.Warn("Response ID is not a string",
                        zap.Any("id", respID),
                        zap.String("type", fmt.Sprintf("%T", respID)))

                return
        }</span>

        <span class="cov0" title="0">rc.pendingMu.RLock()
        respChan, exists := rc.pending[id]

        if !exists </span><span class="cov0" title="0">{
                rc.logger.Warn("No pending request found for response",
                        zap.String("id", id),
                        zap.Any("pending_keys", rc.getPendingKeys()))
                rc.pendingMu.RUnlock()

                return
        }</span>

        <span class="cov0" title="0">rc.logger.Debug("Found pending request for response", zap.String("id", id))

        select </span>{
        case respChan &lt;- line:<span class="cov0" title="0"></span>
                // Response delivered
        default:<span class="cov0" title="0">
                // Channel full or closed
                rc.logger.Warn("Failed to deliver response - channel full or closed", zap.String("id", id))</span>
        }

        <span class="cov0" title="0">rc.pendingMu.RUnlock()</span>
}

func (rc *RouterController) generateAuthToken() <span class="cov0" title="0">{
        // Generate JWT token for authentication
        // This uses the same secret as the test gateway configuration
        secretKey := "test-jwt-secret-for-e2e-testing-only"

        // Create JWT payload
        now := time.Now()
        payload := map[string]interface{}{
                "iss": "mcp-gateway-e2e",
                "aud": "mcp-clients",
                "sub": "test-e2e-client",
                "iat": now.Unix(),
                "exp": now.Add(tokenValidityDuration).Unix(),
                "jti": "test-e2e-jwt-12345",
        }

        // Create header
        header := map[string]interface{}{
                "alg": "HS256",
                "typ": "JWT",
        }

        // Encode header and payload
        headerJSON, _ := json.Marshal(header)   
        payloadJSON, _ := json.Marshal(payload) 

        headerB64 := base64.RawURLEncoding.EncodeToString(headerJSON)
        payloadB64 := base64.RawURLEncoding.EncodeToString(payloadJSON)

        // Create signature
        message := headerB64 + "." + payloadB64
        h := hmac.New(sha256.New, []byte(secretKey))
        h.Write([]byte(message))
        signature := base64.RawURLEncoding.EncodeToString(h.Sum(nil))

        // Combine to create JWT
        rc.authToken = message + "." + signature

        rc.logger.Info("Generated auth token for testing")
}</span>

func (rc *RouterController) createConfigFile() error <span class="cov0" title="0">{
        tempDir := filepath.Dir(rc.binaryPath)
        rc.configPath = filepath.Join(tempDir, "router-config.yaml")

        config := fmt.Sprintf(`
gateway_pool:
  endpoints:
    - url: "%s"
      auth:
        type: "bearer"
        token: "%s"
      tls:
        verify: false
        server_name: "localhost"
      connection:
        timeout_ms: 5000
        keepalive_interval_ms: 30000
      reconnect:
        enabled: true
        initial_interval_ms: 1000
        max_interval_ms: 30000
        multiplier: 2.0
        max_attempts: 5
      circuit_breaker:
        enabled: true
        failure_threshold: 5
        timeout_ms: 10000
        recovery_interval_ms: 30000

local:
  request_timeout_ms: 30000
  rate_limit:
    enabled: false
    requests_per_sec: 10.0
    burst: 5

logging:
  level: "debug"
  format: "console"

metrics:
  enabled: false
  port: 9090
  path: "/metrics"
`, rc.gatewayURL, rc.authToken)

        if err := os.WriteFile(rc.configPath, []byte(config), DefaultFilePermissions); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write config file: %w", err)
        }</span>

        <span class="cov0" title="0">rc.logger.Info("Created router config file", zap.String("path", rc.configPath))

        return nil</span>
}

func (rc *RouterController) handleStdout() <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                if rc.stdout != nil </span><span class="cov0" title="0">{
                        _ = rc.stdout.Close() // Ignore error in test cleanup
                }</span>
        }()

        <span class="cov0" title="0">scanner := bufio.NewScanner(rc.stdout)
        for scanner.Scan() </span><span class="cov0" title="0">{
                line := scanner.Bytes()

                // Try to parse as JSON response
                var resp map[string]interface{}
                if err := json.Unmarshal(line, &amp;resp); err != nil </span><span class="cov0" title="0">{
                        // Not JSON, skip processing
                        continue</span>
                }

                // Process JSON-RPC response
                <span class="cov0" title="0">rc.processJSONRPCResponse(resp, line)

                // Also send to responses channel for debugging
                select </span>{
                case rc.responses &lt;- line:<span class="cov0" title="0"></span>
                default:<span class="cov0" title="0"></span>
                }
        }

        <span class="cov0" title="0">if err := scanner.Err(); err != nil &amp;&amp; !rc.isContextCanceled() </span><span class="cov0" title="0">{
                rc.logger.Error("Error reading stdout", zap.Error(err))

                select </span>{
                case rc.errors &lt;- err:<span class="cov0" title="0"></span>
                default:<span class="cov0" title="0"></span>
                }
        }
}

func (rc *RouterController) handleStderr() <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                if rc.stderr != nil </span><span class="cov0" title="0">{
                        _ = rc.stderr.Close() // Ignore error in test cleanup
                }</span>
        }()

        <span class="cov0" title="0">scanner := bufio.NewScanner(rc.stderr)
        for scanner.Scan() </span><span class="cov0" title="0">{
                line := scanner.Text()
                rc.logger.Debug("Router stderr", zap.String("line", line))
        }</span>

        <span class="cov0" title="0">if err := scanner.Err(); err != nil &amp;&amp; !rc.isContextCanceled() </span><span class="cov0" title="0">{
                rc.logger.Error("Error reading stderr", zap.Error(err))
        }</span>
}

func (rc *RouterController) handleRequests() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                select </span>{
                case req := &lt;-rc.requests:<span class="cov0" title="0">
                        if rc.stdin != nil </span><span class="cov0" title="0">{
                                rc.logger.Debug("Writing request to router stdin", zap.String("request", string(req)))
                                _, writeErr := rc.stdin.Write(append(req, '\n'))

                                if writeErr != nil &amp;&amp; !rc.isContextCanceled() </span><span class="cov0" title="0">{
                                        rc.logger.Error("Error writing to stdin", zap.Error(writeErr))

                                        select </span>{
                                        case rc.errors &lt;- writeErr:<span class="cov0" title="0"></span>
                                        default:<span class="cov0" title="0"></span>
                                        }
                                }
                        }
                case &lt;-rc.ctx.Done():<span class="cov0" title="0">
                        return</span>
                }
        }
}

func (rc *RouterController) handleResponses() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                select </span>{
                case resp := &lt;-rc.responses:<span class="cov0" title="0">
                        rc.logger.Debug("Router response", zap.String("response", string(resp)))</span>
                case &lt;-rc.ctx.Done():<span class="cov0" title="0">
                        return</span>
                }
        }
}

func (rc *RouterController) isContextCanceled() bool <span class="cov0" title="0">{
        select </span>{
        case &lt;-rc.ctx.Done():<span class="cov0" title="0">
                return true</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

func (rc *RouterController) getPendingKeys() []string <span class="cov0" title="0">{
        rc.pendingMu.RLock()
        keys := make([]string, 0, len(rc.pending))

        for k := range rc.pending </span><span class="cov0" title="0">{
                keys = append(keys, k)
        }</span>

        <span class="cov0" title="0">rc.pendingMu.RUnlock()

        return keys</span>
}

func (rc *RouterController) cleanup() <span class="cov0" title="0">{
        // Clean up temporary files
        if rc.configPath != "" </span><span class="cov0" title="0">{
                _ = os.Remove(rc.configPath) // Ignore error in test cleanup
        }</span>

        <span class="cov0" title="0">if rc.binaryPath != "" </span><span class="cov0" title="0">{
                _ = os.Remove(rc.binaryPath) // Ignore error in test cleanup
        }</span>

        // Clean up channels
        <span class="cov0" title="0">rc.pendingMu.Lock()

        for _, ch := range rc.pending </span><span class="cov0" title="0">{
                close(ch)
        }</span>

        <span class="cov0" title="0">rc.pending = make(map[string]chan []byte)
        rc.pendingMu.Unlock()</span>
}

// GetGatewayURL returns the gateway URL.
func (rc *RouterController) GetGatewayURL() string <span class="cov0" title="0">{
        return rc.gatewayURL
}</span>

// GetAuthToken returns the authentication token.
func (rc *RouterController) GetAuthToken() string <span class="cov0" title="0">{
        return rc.authToken
}</span>

// WaitForHealthy waits for the router to become healthy by checking the gateway.
func (rc *RouterController) WaitForHealthy(timeout time.Duration) error <span class="cov0" title="0">{
        rc.logger.Info("Waiting for router to become healthy")

        deadline := time.Now().Add(timeout)
        for time.Now().Before(deadline) </span><span class="cov0" title="0">{
                // Check if router is started and can handle requests
                if rc.started &amp;&amp; rc.cmd != nil &amp;&amp; rc.cmd.Process != nil </span><span class="cov0" title="0">{
                        // Try to send a simple ping request to test connectivity
                        testReq := MCPRequest{
                                JSONRPC: "2.0",
                                ID:      "health-check",
                                Method:  "ping",
                                Params:  map[string]interface{}{},
                        }

                        // Use a short timeout for health check
                        _, err := rc.SendRequestAndWait(testReq, maxRetryAttempts*time.Second)
                        if err == nil </span><span class="cov0" title="0">{
                                rc.logger.Info("Router appears healthy - can handle requests")

                                return nil
                        }</span>

                        // If ping fails, check if router process is still running
                        // and connected (based on logs showing "CONNECTED" state)
                        <span class="cov0" title="0">select </span>{
                        case &lt;-rc.ctx.Done():<span class="cov0" title="0">
                                return errors.New("router context canceled")</span>
                        default:<span class="cov0" title="0"></span>
                                // Process is still running, continue waiting
                        }
                }

                <span class="cov0" title="0">time.Sleep(messageRetryDelay)</span>
        }

        <span class="cov0" title="0">return errors.New("router did not become healthy within timeout")</span>
}

// Helper functions

// FindProjectRoot finds the project root directory by looking for go.mod file.
func FindProjectRoot() (string, error) <span class="cov0" title="0">{
        dir, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get current directory: %w", err)
        }</span>

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                if _, err := os.Stat(filepath.Join(dir, "go.mod")); err == nil </span><span class="cov0" title="0">{
                        return dir, nil
                }</span>

                <span class="cov0" title="0">parent := filepath.Dir(dir)
                if parent == dir </span><span class="cov0" title="0">{
                        return "", errors.New("could not find project root (no go.mod found)")
                }</span>

                <span class="cov0" title="0">dir = parent</span>
        }
}

// NewTestHTTPClient creates an HTTP client suitable for testing.
func NewTestHTTPClient(timeout time.Duration) *http.Client <span class="cov0" title="0">{
        return &amp;http.Client{
                Timeout: timeout,
        }
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">// Package testutil provides utility functions and helpers for testing.
//

package testutil

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "net"
        "net/http"
        "os"
        "os/exec"
        "runtime"
        "testing"
        "time"

        "go.uber.org/zap"
        "go.uber.org/zap/zaptest"
)

const (
        // Test timeouts and intervals.
        defaultClientTimeout = 30 * time.Second
        httpClientTimeout    = 5 * time.Second
        retryDelay           = 100 * time.Millisecond

        // HTTP status codes.
        httpStatusServerError = 500
)

// TestClient provides HTTP client for testing.
type TestClient struct {
        BaseURL   string
        AuthToken string
        Client    *http.Client
}

// NewTestClient creates a new test client.
func NewTestClient() *TestClient <span class="cov0" title="0">{
        baseURL := os.Getenv("MCP_BASE_URL")
        if baseURL == "" </span><span class="cov0" title="0">{
                baseURL = "http://localhost:8080"
        }</span>

        <span class="cov0" title="0">return &amp;TestClient{
                BaseURL: baseURL,
                Client: &amp;http.Client{
                        Timeout: defaultClientTimeout,
                },
        }</span>
}

// SetAuthToken sets the authentication token.
func (c *TestClient) SetAuthToken(token string) <span class="cov0" title="0">{
        c.AuthToken = token
}</span>

// Get performs a GET request.
func (c *TestClient) Get(path string) (*http.Response, error) <span class="cov0" title="0">{
        url := c.BaseURL + path

        req, err := http.NewRequestWithContext(context.Background(), http.MethodGet, url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create GET request: %w", err)
        }</span>

        <span class="cov0" title="0">if c.AuthToken != "" </span><span class="cov0" title="0">{
                req.Header.Set("Authorization", "Bearer "+c.AuthToken)
        }</span>

        <span class="cov0" title="0">return c.Client.Do(req)</span>
}

// Post performs a POST request with JSON body.
func (c *TestClient) Post(path string, body interface{}) (*http.Response, error) <span class="cov0" title="0">{
        var reqBody io.Reader

        if body != nil </span><span class="cov0" title="0">{
                jsonBody, err := json.Marshal(body)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to marshal request body: %w", err)
                }</span>

                <span class="cov0" title="0">reqBody = bytes.NewReader(jsonBody)</span>
        }

        <span class="cov0" title="0">url := c.BaseURL + path

        req, err := http.NewRequestWithContext(context.Background(), http.MethodPost, url, reqBody)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create POST request: %w", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")

        if c.AuthToken != "" </span><span class="cov0" title="0">{
                req.Header.Set("Authorization", "Bearer "+c.AuthToken)
        }</span>

        <span class="cov0" title="0">return c.Client.Do(req)</span>
}

// Put performs a PUT request with JSON body.
func (c *TestClient) Put(path string, body interface{}) (*http.Response, error) <span class="cov0" title="0">{
        var reqBody io.Reader

        if body != nil </span><span class="cov0" title="0">{
                jsonBody, err := json.Marshal(body)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to marshal request body: %w", err)
                }</span>

                <span class="cov0" title="0">reqBody = bytes.NewReader(jsonBody)</span>
        }

        <span class="cov0" title="0">url := c.BaseURL + path

        req, err := http.NewRequestWithContext(context.Background(), http.MethodPut, url, reqBody)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create PUT request: %w", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")

        if c.AuthToken != "" </span><span class="cov0" title="0">{
                req.Header.Set("Authorization", "Bearer "+c.AuthToken)
        }</span>

        <span class="cov0" title="0">return c.Client.Do(req)</span>
}

// Delete performs a DELETE request.
func (c *TestClient) Delete(path string) (*http.Response, error) <span class="cov0" title="0">{
        url := c.BaseURL + path

        req, err := http.NewRequestWithContext(context.Background(), http.MethodDelete, url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create DELETE request: %w", err)
        }</span>

        <span class="cov0" title="0">if c.AuthToken != "" </span><span class="cov0" title="0">{
                req.Header.Set("Authorization", "Bearer "+c.AuthToken)
        }</span>

        <span class="cov0" title="0">return c.Client.Do(req)</span>
}

// CheckPort checks if a port is available on localhost.
func CheckPort(port int) bool <span class="cov0" title="0">{
        address := fmt.Sprintf("localhost:%d", port)

        dialer := &amp;net.Dialer{}

        conn, err := dialer.DialContext(context.Background(), "tcp", address)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = conn.Close() }</span>()

        <span class="cov0" title="0">return true</span>
}

// WaitForPort waits for a port to become available with timeout.
func WaitForPort(port int, timeout time.Duration) error <span class="cov0" title="0">{
        deadline := time.Now().Add(timeout)
        for time.Now().Before(deadline) </span><span class="cov0" title="0">{
                if CheckPort(port) </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">time.Sleep(retryDelay)</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("port %d did not become available within %v", port, timeout)</span>
}

// GetMemoryUsage returns current memory usage statistics.
func GetMemoryUsage() runtime.MemStats <span class="cov0" title="0">{
        var m runtime.MemStats

        runtime.ReadMemStats(&amp;m)

        return m
}</span>

// GetProcessMemory returns process memory usage in bytes.
func GetProcessMemory() uint64 <span class="cov0" title="0">{
        var m runtime.MemStats

        runtime.ReadMemStats(&amp;m)

        return m.Sys
}</span>

// RunCommand executes a shell command and returns its output.
func RunCommand(name string, args ...string) ([]byte, error) <span class="cov0" title="0">{
        cmd := exec.CommandContext(context.Background(), name, args...)

        return cmd.Output()
}</span>

// RunCommandWithTimeout executes a command with a timeout.
func RunCommandWithTimeout(timeout time.Duration, name string, args ...string) ([]byte, error) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), timeout)
        defer cancel()

        cmd := exec.CommandContext(ctx, name, args...)

        return cmd.Output()
}</span>

// WaitForService waits for a service to be ready at the given URL.
func WaitForService(url string, timeout time.Duration) error <span class="cov0" title="0">{
        client := &amp;http.Client{Timeout: httpClientTimeout}
        deadline := time.Now().Add(timeout)

        for time.Now().Before(deadline) </span><span class="cov0" title="0">{
                req, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, url, nil)

                resp, err := client.Do(req)
                if err == nil </span><span class="cov0" title="0">{
                        _ = resp.Body.Close()

                        if resp.StatusCode &lt; httpStatusServerError </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                }

                <span class="cov0" title="0">time.Sleep(1 * time.Second)</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("service at %s did not become ready within %v", url, timeout)</span>
}

// MockServer provides a simple mock HTTP server for testing.
type MockServer struct {
        Server   *http.Server
        Handlers map[string]http.HandlerFunc
}

// NewMockServer creates a new mock server.
func NewMockServer(port int) *MockServer <span class="cov0" title="0">{
        ms := &amp;MockServer{
                Handlers: make(map[string]http.HandlerFunc),
        }

        mux := http.NewServeMux()
        mux.HandleFunc("/", ms.routeHandler)

        const readHeaderTimeout = 10 // seconds for header read timeout
        
        ms.Server = &amp;http.Server{
                Addr:              fmt.Sprintf(":%d", port),
                Handler:           mux,
                ReadHeaderTimeout: readHeaderTimeout * time.Second,
        }

        return ms
}</span>

// AddHandler adds a handler for a specific path.
func (ms *MockServer) AddHandler(path string, handler http.HandlerFunc) <span class="cov0" title="0">{
        ms.Handlers[path] = handler
}</span>

// Start starts the mock server.
func (ms *MockServer) Start() error <span class="cov0" title="0">{
        go func() </span><span class="cov0" title="0">{
                _ = ms.Server.ListenAndServe()
        }</span>()

        // Wait a bit for server to start
        <span class="cov0" title="0">time.Sleep(retryDelay)

        return nil</span>
}

// Stop stops the mock server.
func (ms *MockServer) Stop() error <span class="cov0" title="0">{
        if ms.Server != nil </span><span class="cov0" title="0">{
                return ms.Server.Shutdown(context.Background())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// routeHandler routes requests to registered handlers.
func (ms *MockServer) routeHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if handler, exists := ms.Handlers[r.URL.Path]; exists </span><span class="cov0" title="0">{
                handler(w, r)

                return
        }</span>

        // Default response
        <span class="cov0" title="0">w.WriteHeader(http.StatusNotFound)
        _, _ = w.Write([]byte("Not Found"))</span>
}

// CompareJSON compares two JSON strings for equality.
func CompareJSON(expected, actual string) error <span class="cov0" title="0">{
        var expectedObj, actualObj interface{}

        if err := json.Unmarshal([]byte(expected), &amp;expectedObj); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to unmarshal expected JSON: %w", err)
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal([]byte(actual), &amp;actualObj); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to unmarshal actual JSON: %w", err)
        }</span>

        <span class="cov0" title="0">expectedBytes, _ := json.Marshal(expectedObj)
        actualBytes, _ := json.Marshal(actualObj)

        if !bytes.Equal(expectedBytes, actualBytes) </span><span class="cov0" title="0">{
                return fmt.Errorf("JSON mismatch:\nexpected: %s\nactual: %s", expectedBytes, actualBytes)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// CreateTempDir creates a temporary directory for testing.
func CreateTempDir(prefix string) (string, error) <span class="cov0" title="0">{
        return os.MkdirTemp("", prefix)
}</span>

// CleanupTempDir removes a temporary directory and all its contents.
func CleanupTempDir(dir string) error <span class="cov0" title="0">{
        return os.RemoveAll(dir)
}</span>

// CreateTempFile creates a temporary file with the given content.
func CreateTempFile(content string) (string, error) <span class="cov0" title="0">{
        tmpFile, err := os.CreateTemp("", "test-*.txt")
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create temp file: %w", err)
        }</span>

        <span class="cov0" title="0">if _, err := tmpFile.WriteString(content); err != nil </span><span class="cov0" title="0">{
                _ = tmpFile.Close()
                _ = os.Remove(tmpFile.Name())

                return "", fmt.Errorf("failed to write to temp file: %w", err)
        }</span>

        <span class="cov0" title="0">if err := tmpFile.Close(); err != nil </span><span class="cov0" title="0">{
                _ = os.Remove(tmpFile.Name())

                return "", fmt.Errorf("failed to close temp file: %w", err)
        }</span>

        <span class="cov0" title="0">return tmpFile.Name(), nil</span>
}

// ReadTempFile reads content from a temporary file.
func ReadTempFile(filename string) (string, error) <span class="cov0" title="0">{
        content, err := os.ReadFile(filename) //nolint:gosec // Test file reading
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to read temp file: %w", err)
        }</span>

        <span class="cov0" title="0">return string(content), nil</span>
}

// NewTestLogger creates a test logger for use in tests.
func NewTestLogger(t *testing.T) *zap.Logger <span class="cov0" title="0">{
        t.Helper()

        return zaptest.NewLogger(t)
}</span>

// TempFile creates a temporary file with the given content for testing.
func TempFile(tb testing.TB, content string) (string, func()) <span class="cov0" title="0">{
        tb.Helper()

        tmpFile, err := os.CreateTemp("", "mcp-test-*")
        if err != nil </span><span class="cov0" title="0">{
                tb.Fatalf("Failed to create temp file: %v", err)
        }</span>

        <span class="cov0" title="0">if _, err := tmpFile.WriteString(content); err != nil </span><span class="cov0" title="0">{
                _ = tmpFile.Close()
                _ = os.Remove(tmpFile.Name())

                tb.Fatalf("Failed to write to temp file: %v", err)
        }</span>

        <span class="cov0" title="0">if err := tmpFile.Close(); err != nil </span><span class="cov0" title="0">{
                _ = os.Remove(tmpFile.Name())

                tb.Fatalf("Failed to close temp file: %v", err)
        }</span>

        <span class="cov0" title="0">cleanup := func() </span><span class="cov0" title="0">{
                _ = os.Remove(tmpFile.Name())
        }</span>

        <span class="cov0" title="0">return tmpFile.Name(), cleanup</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">// Package main provides a Redis migration tool for managing schema and data migrations.
package main

import (
        "context"
        "encoding/json"
        "errors"
        "flag"
        "fmt"
        "log"
        "os"
        "path/filepath"
        "time"

        "github.com/go-redis/redis/v8"
        "gopkg.in/yaml.v3"
)

const (
        // retryDelay is the delay between migration retry attempts.
        retryDelay = 100 * time.Millisecond
        
        // File permissions.
        dirPermissions = 0o750
        filePermissions = 0o600
)

// Migration represents a single Redis migration.
type Migration struct {
        ID          string                 `json:"id"                   yaml:"id"`
        Description string                 `json:"description"          yaml:"description"`
        Version     string                 `json:"version"              yaml:"version"`
        Type        string                 `json:"type"                 yaml:"type"` // "schema", "data", "index"
        Script      string                 `json:"script"               yaml:"script"`
        Rollback    string                 `json:"rollback,omitempty"   yaml:"rollback,omitempty"`
        CheckSum    string                 `json:"checksum"             yaml:"checksum"`
        Applied     bool                   `json:"applied"              yaml:"-"`
        AppliedAt   *time.Time             `json:"applied_at,omitempty" yaml:"-"`
        Metadata    map[string]interface{} `json:"metadata,omitempty"   yaml:"metadata,omitempty"`
}

// MigrationHistory tracks applied migrations.
type MigrationHistory struct {
        ID        string    `json:"id"`
        Version   string    `json:"version"`
        AppliedAt time.Time `json:"applied_at"`
        CheckSum  string    `json:"checksum"`
        Success   bool      `json:"success"`
        Error     string    `json:"error,omitempty"`
}

// Migrator handles Redis migrations.
type Migrator struct {
        client     *redis.Client
        migrations []Migration
        config     Config
        ctx        context.Context 
}

// Config holds migrator configuration.
type Config struct {
        RedisURL       string `yaml:"redis_url"`
        RedisPassword  string `yaml:"redis_password"`
        MigrationsPath string `yaml:"migrations_path"`
        HistoryKey     string `yaml:"history_key"`
        BackupEnabled  bool   `yaml:"backup_enabled"`
        BackupPath     string `yaml:"backup_path"`
        DryRun         bool   `yaml:"dry_run"`
        ValidateOnly   bool   `yaml:"validate_only"`
}

func main() <span class="cov0" title="0">{
        config, cmd := parseFlags()
        
        if cmd.create != "" </span><span class="cov0" title="0">{
                handleCreate(cmd.create, config.MigrationsPath)

                return
        }</span>
        
        <span class="cov0" title="0">client := connectRedis(config)
        
        defer func() </span><span class="cov0" title="0">{ _ = client.Close() }</span>()
        
        <span class="cov0" title="0">migrator := setupMigrator(client, config)
        
        executeCommand(migrator, cmd, client)</span>
}

// loadConfig loads configuration from file.
type commandFlags struct {
        status   bool
        rollback string
        create   string
}

func parseFlags() (Config, commandFlags) <span class="cov0" title="0">{
        var (
                configFile     = flag.String("config", "", "Configuration file path")
                migrationsPath = flag.String("migrations", "./migrations/redis", "Path to migrations directory")
                redisURL       = flag.String("redis", "localhost:6379", "Redis URL")
                redisPassword  = flag.String("password", "", "Redis password")
                dryRun         = flag.Bool("dry-run", false, "Perform dry run without applying changes")
                validate       = flag.Bool("validate", false, "Validate migrations only")
                rollback       = flag.String("rollback", "", "Rollback to specified migration ID")
                status         = flag.Bool("status", false, "Show migration status")
                create         = flag.String("create", "", "Create new migration with given name")
        )

        flag.Parse()

        config := Config{
                RedisURL:       *redisURL,
                RedisPassword:  *redisPassword,
                MigrationsPath: *migrationsPath,
                HistoryKey:     "mcp:migrations:history",
                BackupEnabled:  true,
                BackupPath:     "./backups",
                DryRun:         *dryRun,
                ValidateOnly:   *validate,
        }

        if *configFile != "" </span><span class="cov0" title="0">{
                if err := loadConfig(*configFile, &amp;config); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Failed to load config: %v", err)
                }</span>
        }

        <span class="cov0" title="0">return config, commandFlags{
                status:   *status,
                rollback: *rollback,
                create:   *create,
        }</span>
}

func handleCreate(name, path string) <span class="cov0" title="0">{
        if err := createMigration(name, path); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create migration: %v", err)
        }</span>
}

func connectRedis(config Config) *redis.Client <span class="cov0" title="0">{
        client := redis.NewClient(&amp;redis.Options{
                Addr:     config.RedisURL,
                Password: config.RedisPassword,
                DB:       0,
        })

        ctx := context.Background()
        if err := client.Ping(ctx).Err(); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to connect to Redis: %v", err)
        }</span>

        <span class="cov0" title="0">return client</span>
}

func setupMigrator(client *redis.Client, config Config) *Migrator <span class="cov0" title="0">{
        migrator := &amp;Migrator{
                client:     client,
                migrations: nil,
                config:     config,
                ctx:        context.Background(),
        }

        if err := migrator.loadMigrations(); err != nil </span><span class="cov0" title="0">{
                _ = client.Close()
                
                log.Fatalf("Failed to load migrations: %v", err)
        }</span>

        <span class="cov0" title="0">return migrator</span>
}

func executeCommand(migrator *Migrator, cmd commandFlags, client *redis.Client) <span class="cov0" title="0">{
        switch </span>{
        case cmd.status:<span class="cov0" title="0">
                migrator.showStatus()</span>

        case cmd.rollback != "":<span class="cov0" title="0">
                if err := migrator.rollbackTo(cmd.rollback); err != nil </span><span class="cov0" title="0">{
                        _ = client.Close()
                        
                        log.Fatalf("Rollback failed: %v", err)
                }</span>

        case migrator.config.ValidateOnly:<span class="cov0" title="0">
                if err := migrator.validate(); err != nil </span><span class="cov0" title="0">{
                        _ = client.Close()
                        
                        log.Fatalf("Validation failed: %v", err)
                }</span>
                
                <span class="cov0" title="0">log.Println("All migrations are valid")</span>

        default:<span class="cov0" title="0">
                if err := migrator.migrate(); err != nil </span><span class="cov0" title="0">{
                        _ = client.Close()
                        
                        log.Fatalf("Migration failed: %v", err)
                }</span>
        }
}

func loadConfig(path string, config *Config) error <span class="cov0" title="0">{
        data, err := os.ReadFile(path) //nolint:gosec // Tool for controlled migration 
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return yaml.Unmarshal(data, config)</span>
}

// loadMigrations loads all migration files.
//

func (m *Migrator) loadMigrations() error <span class="cov0" title="0">{
        pattern := filepath.Join(m.config.MigrationsPath, "*.yaml")

        files, err := filepath.Glob(pattern)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">for _, file := range files </span><span class="cov0" title="0">{
                migration, err := m.loadMigration(file)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to load %s: %w", file, err)
                }</span>

                <span class="cov0" title="0">m.migrations = append(m.migrations, *migration)</span>
        }

        // Sort migrations by version/ID
        // Implementation depends on versioning scheme

        <span class="cov0" title="0">return nil</span>
}

// loadMigration loads a single migration file.
func (m *Migrator) loadMigration(path string) (*Migration, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path) //nolint:gosec // Tool for controlled migration 
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var migration Migration
        if err := yaml.Unmarshal(data, &amp;migration); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Check if already applied
        <span class="cov0" title="0">applied, appliedAt, err := m.isApplied(migration.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">migration.Applied = applied
        migration.AppliedAt = appliedAt

        return &amp;migration, nil</span>
}

// isApplied checks if a migration has been applied.
func (m *Migrator) isApplied(id string) (bool, *time.Time, error) <span class="cov0" title="0">{
        key := fmt.Sprintf("%s:%s", m.config.HistoryKey, id)
        val, err := m.client.Get(m.ctx, key).Result()

        if errors.Is(err, redis.Nil) </span><span class="cov0" title="0">{
                return false, nil, nil
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return false, nil, err
        }</span>

        <span class="cov0" title="0">var history MigrationHistory
        if err := json.Unmarshal([]byte(val), &amp;history); err != nil </span><span class="cov0" title="0">{
                return false, nil, err
        }</span>

        <span class="cov0" title="0">return history.Success, &amp;history.AppliedAt, nil</span>
}

// migrate applies pending migrations.
func (m *Migrator) migrate() error <span class="cov0" title="0">{
        pending := m.getPendingMigrations()
        if len(pending) == 0 </span><span class="cov0" title="0">{
                log.Println("No pending migrations")

                return nil
        }</span>

        <span class="cov0" title="0">log.Printf("Found %d pending migrations", len(pending))

        // Create backup if enabled
        if m.config.BackupEnabled &amp;&amp; !m.config.DryRun </span><span class="cov0" title="0">{
                if err := m.createBackup(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create backup: %w", err)
                }</span>
        }

        // Apply migrations
        <span class="cov0" title="0">for i := range pending </span><span class="cov0" title="0">{
                if err := m.applyMigration(&amp;pending[i]); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to apply migration %s: %w", pending[i].ID, err)
                }</span>
        }

        <span class="cov0" title="0">log.Println("All migrations applied successfully")

        return nil</span>
}

// getPendingMigrations returns migrations that haven't been applied.
func (m *Migrator) getPendingMigrations() []Migration <span class="cov0" title="0">{
        var pending []Migration

        for i := range m.migrations </span><span class="cov0" title="0">{
                if !m.migrations[i].Applied </span><span class="cov0" title="0">{
                        pending = append(pending, m.migrations[i])
                }</span>
        }

        <span class="cov0" title="0">return pending</span>
}

// applyMigration applies a single migration.
func (m *Migrator) applyMigration(migration *Migration) error <span class="cov0" title="0">{
        log.Printf("Applying migration %s: %s", migration.ID, migration.Description)

        if m.config.DryRun </span><span class="cov0" title="0">{
                log.Println("[DRY RUN] Would execute:")
                log.Println(migration.Script)

                return nil
        }</span>

        // Execute migration script
        <span class="cov0" title="0">start := time.Now()
        result := m.client.Eval(m.ctx, migration.Script, []string{})

        if err := result.Err(); err != nil </span><span class="cov0" title="0">{
                // Record failure
                _ = m.recordMigration(migration, false, err.Error()) 

                return err
        }</span>

        <span class="cov0" title="0">duration := time.Since(start)
        log.Printf("Migration %s completed in %v", migration.ID, duration)

        // Record success
        return m.recordMigration(migration, true, "")</span>
}

// recordMigration records migration in history.
func (m *Migrator) recordMigration(migration *Migration, success bool, errorMsg string) error <span class="cov0" title="0">{
        history := MigrationHistory{
                ID:        migration.ID,
                Version:   migration.Version,
                AppliedAt: time.Now(),
                CheckSum:  migration.CheckSum,
                Success:   success,
                Error:     errorMsg,
        }

        data, err := json.Marshal(history)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">key := fmt.Sprintf("%s:%s", m.config.HistoryKey, migration.ID)

        return m.client.Set(m.ctx, key, data, 0).Err()</span>
}

// rollbackTo rolls back to specified migration.
func (m *Migrator) rollbackTo(targetID string) error <span class="cov0" title="0">{
        target, err := m.findMigration(targetID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if !target.Applied </span><span class="cov0" title="0">{
                return fmt.Errorf("migration %s has not been applied", targetID)
        }</span>

        <span class="cov0" title="0">toRollback := m.getMigrationsToRollback(targetID)
        if len(toRollback) == 0 </span><span class="cov0" title="0">{
                log.Println("No migrations to rollback")

                return nil
        }</span>

        <span class="cov0" title="0">log.Printf("Rolling back %d migrations", len(toRollback))

        if err := m.prepareRollbackBackup(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return m.executeRollbacks(toRollback)</span>
}

// findMigration finds a migration by ID.
func (m *Migrator) findMigration(targetID string) (*Migration, error) <span class="cov0" title="0">{
        for i := range m.migrations </span><span class="cov0" title="0">{
                if m.migrations[i].ID == targetID </span><span class="cov0" title="0">{
                        return &amp;m.migrations[i], nil
                }</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("migration %s not found", targetID)</span>
}

// getMigrationsToRollback finds migrations to rollback.
func (m *Migrator) getMigrationsToRollback(targetID string) []Migration <span class="cov0" title="0">{
        var toRollback []Migration

        for i := range m.migrations </span><span class="cov0" title="0">{
                if m.migrations[i].Applied &amp;&amp; m.migrations[i].ID &gt; targetID </span><span class="cov0" title="0">{
                        toRollback = append(toRollback, m.migrations[i])
                }</span>
        }

        <span class="cov0" title="0">return toRollback</span>
}

// prepareRollbackBackup creates backup before rollback if enabled.
func (m *Migrator) prepareRollbackBackup() error <span class="cov0" title="0">{
        if m.config.BackupEnabled &amp;&amp; !m.config.DryRun </span><span class="cov0" title="0">{
                if err := m.createBackup(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create backup: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// executeRollbacks applies rollback scripts in reverse order.
func (m *Migrator) executeRollbacks(toRollback []Migration) error <span class="cov0" title="0">{
        for i := len(toRollback) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                migration := toRollback[i]
                if migration.Rollback == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("migration %s does not support rollback", migration.ID)
                }</span>

                <span class="cov0" title="0">log.Printf("Rolling back migration %s", migration.ID)

                if m.config.DryRun </span><span class="cov0" title="0">{
                        log.Println("[DRY RUN] Would execute rollback:")
                        log.Println(migration.Rollback)

                        continue</span>
                }

                <span class="cov0" title="0">result := m.client.Eval(m.ctx, migration.Rollback, []string{})
                if err := result.Err(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("rollback failed for %s: %w", migration.ID, err)
                }</span>

                // Remove from history
                <span class="cov0" title="0">key := fmt.Sprintf("%s:%s", m.config.HistoryKey, migration.ID)
                _ = m.client.Del(m.ctx, key).Err()</span> 
        }

        <span class="cov0" title="0">log.Println("Rollback completed successfully")

        return nil</span>
}

// validate validates all migrations.
func (m *Migrator) validate() error <span class="cov0" title="0">{
        for i := range m.migrations </span><span class="cov0" title="0">{
                migration := &amp;m.migrations[i]
                // Check required fields
                if migration.ID == "" </span><span class="cov0" title="0">{
                        return errors.New("migration missing ID")
                }</span>

                <span class="cov0" title="0">if migration.Script == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("migration %s missing script", migration.ID)
                }</span>

                // Validate Lua syntax (basic check)
                // In production, use a Lua parser for full validation

                <span class="cov0" title="0">log.Printf("✓ Migration %s is valid", migration.ID)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// showStatus displays migration status.
func (m *Migrator) showStatus() <span class="cov0" title="0">{
        log.Println("Migration Status:")
        log.Println("-----------------")

        for i := range m.migrations </span><span class="cov0" title="0">{
                migration := &amp;m.migrations[i]
                status := "Pending"

                if migration.Applied </span><span class="cov0" title="0">{
                        status = "Applied at " + migration.AppliedAt.Format(time.RFC3339)
                }</span>

                <span class="cov0" title="0">log.Printf("%s - %s: %s", migration.ID, migration.Description, status)</span>
        }

        // Show summary
        <span class="cov0" title="0">applied := 0
        pending := 0

        for i := range m.migrations </span><span class="cov0" title="0">{
                if m.migrations[i].Applied </span><span class="cov0" title="0">{
                        applied++
                }</span> else<span class="cov0" title="0"> {
                        pending++
                }</span>
        }

        <span class="cov0" title="0">log.Println("\nSummary:")
        log.Printf("  Applied: %d", applied)
        log.Printf("  Pending: %d", pending)
        log.Printf("  Total:   %d", len(m.migrations))</span>
}

// createBackup creates a Redis backup.
func (m *Migrator) createBackup() error <span class="cov0" title="0">{
        if err := os.MkdirAll(m.config.BackupPath, dirPermissions); err != nil </span><span class="cov0" title="0">{ 
                return err
        }</span>

        <span class="cov0" title="0">timestamp := time.Now().Format("20060102-150405")
        backupFile := filepath.Join(m.config.BackupPath, fmt.Sprintf("redis-backup-%s.rdb", timestamp))

        log.Printf("Creating backup: %s", backupFile)

        // Trigger BGSAVE
        if err := m.client.BgSave(m.ctx).Err(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Wait for BGSAVE to complete
        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                info, err := m.client.Info(m.ctx, "persistence").Result()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Check if BGSAVE is in progress
                // Parse info string to check status
                // This is simplified; in production, parse properly
                <span class="cov0" title="0">if !contains(info, "rdb_bgsave_in_progress:1") </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">time.Sleep(retryDelay)</span>
        }

        <span class="cov0" title="0">log.Printf("Backup created successfully")

        return nil</span>
}

// createMigration creates a new migration file.
func createMigration(name, path string) error <span class="cov0" title="0">{
        timestamp := time.Now().Format("20060102150405")
        id := fmt.Sprintf("%s_%s", timestamp, name)
        filename := filepath.Join(path, id+".yaml")

        migration := Migration{
                ID:          id,
                Description: name,
                Version:     "1.0.0",
                Type:        "data",
                Script: `-- Migration: ` + name + `
-- Add your Redis Lua script here
-- Available globals: redis, KEYS, ARGV

local count = 0

-- Example: Migrate key pattern
local cursor = "0"
repeat
    local result = redis.call("SCAN", cursor, "MATCH", "old:pattern:*", "COUNT", 100)
    cursor = result[1]
    local keys = result[2]
    
    for _, key in ipairs(keys) do
        -- Process each key
        local value = redis.call("GET", key)
        -- Transform and save with new key
        -- redis.call("SET", new_key, transformed_value)
        count = count + 1
    end
until cursor == "0"

return count
`,
                Rollback: `-- Rollback for: ` + name + `
-- Add rollback logic here
return 0
`,
                CheckSum:  "",    // Will be calculated when migration is processed
                Applied:   false, // New migration has not been applied
                AppliedAt: nil,   // Not applied yet
                Metadata: map[string]interface{}{
                        "author":     os.Getenv("USER"),
                        "created_at": time.Now().Format(time.RFC3339),
                },
        }

        data, err := yaml.Marshal(migration)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := os.MkdirAll(path, dirPermissions); err != nil </span><span class="cov0" title="0">{ 
                return err
        }</span>

        <span class="cov0" title="0">if err := os.WriteFile(filename, data, filePermissions); err != nil </span><span class="cov0" title="0">{ 
                return err
        }</span>

        <span class="cov0" title="0">log.Printf("Created migration: %s", filename)

        return nil</span>
}

// Helper function.
func contains(s, substr string) bool <span class="cov0" title="0">{
        return s != "" &amp;&amp; substr != "" &amp;&amp; len(s) &gt;= len(substr) &amp;&amp;
                (s == substr || len(s) &gt; len(substr) &amp;&amp; (s[:len(substr)] == substr || contains(s[1:], substr)))
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
